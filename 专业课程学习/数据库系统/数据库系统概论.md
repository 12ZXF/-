CSDN原文链接：https://blog.csdn.net/weixin_43914604/article/details/106527797?utm_source=app&app_version=5.5.0&code=app_1562916241&uLinkId=usr1mkqgl919blen

# 目录

[第1 章绪论](#第1 章绪论)

- [1.1 数据库系统概述](#1.1 数据库系统概述)
- [1.2 数据模型](#1.2 数据模型)
- [1.3 数据库系统结构和组成](#1.3 数据库系统结构和组成)

[第2 章关系数据库](#第2 章关系数据库)

- [2.1 关系数据结构及形式化定义](#2.1 关系数据结构及形式化定义)
- [2.2 关系操作、关系完整性、关系代数](#2.2 关系操作、关系完整性、关系代数)

[第3 章关系数据库标准语言SQL](#第3 章关系数据库标准语言SQL)

- [3.1 SQL概述及数据定义](#3.1 SQL概述及数据定义)
- [3.2 数据查询—SELECT](#3.2 数据查询—SELECT)
- [3.3 基本表更新](#3.3 基本表更新)

[第4 章数据库安全性](#第4 章数据库安全性)

- [4.1 数据库安全性详解](#4.1 数据库安全性详解)

[第5 章数据库完整性](#第5 章数据库完整性)

- [5.1 数据库完整性详解](#5.1 数据库完整性详解)

[第6 章关系数据理论](#第6 章关系数据理论)

-  [6.1 关系数据库的规范化理论](#6.1 关系数据库的规范化理论)

[第7 章数据库设计](#第7 章数据库设计)

- [7.1 数据库设计六步骤](#7.1 数据库设计六步骤)

# 第1 章绪论

## 1.1 数据库系统概述

（数据、数据库、数据库管理系统、数据库系统、数据库的产生和发展）

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.jpg)

### 1.四大基本概念

#### 1.数据–Data

数据(Data)是数据库中存储的基本对象


(1)数据的定义：描述事物的符号记录

(2)数据的种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等

(3)数据的含义：称为数据的语义，**数据与其语义是不可分的**

(4)数据举例

> 1.93是一个数据
>
> - 语义1：学生某门课的成绩
> - 语义2：某人的体重
> - 语义3：计算机系2003级学生人数

> 2.学生档案中的学生记录
> （李明，男，197205，江苏南京市，计算机系，1990）
> **语义：**学生姓名、性别、出生年月、籍贯、所在院系、入学时间
> **解释：**李明是个大学生，1972年5月出生，江苏南京市人，1990年考入计算机系

(5)数据是有结构的：**记录**是计算机存储数据的一种格式或方式

#### 2.数据库–Database

(1)数据库的定义

**数据库**(Database,简称DB)是**长期储存**在计算机内、**有组织**、**可共享**的大量数据的集合。

(2)数据库的基本特征

- 数据按一定的数据模型组织、描述和储存
- 可为各种用户共享，冗余度较小，易扩展
- 数据独立性较高21

#### 3.数据库管理系统(DataBase Management System)

(1)什么是DBMS?

DBMS是位于**用户与操作系统**之间的一层**数据管理软件**，是基础软件，是一个大型复杂的软件系统

(2)DBMS的**用途**

科学地组织和存储数据、高效地获取和维护数据

(3)DBMS的**主要功能**

- **数据定义功能**
  - 提供数据定义语言(DDL)
  - 定义数据库中的数据对象

- **数据组织、存储和管理**
  - 分类组织、存储和管理各种数据
  - 确定组织数据的文件结构和存取方式
  - 实现数据之间的联系
  - 提供多种存取方法提高存取效率

- **数据操纵功能**
  - 提供数据操纵语言(DML)
  - 实现对数据库的基本操作(查询、插入、删除和修改)

- **数据库的事务管理和运行管理**
  - 数据库在建立、运行和维护时由DBMS统一管理和控制
  - 保证数据的安全性、完整性、多用户对数据的并发使用
  - 发生故障后的系统恢复

- **数据库的建立和维护功能(实用程序)**
  - 数据库初始数据装载转换
  - 数据库转储
  - 介质故障恢复
  - 数据库的重组织
  - 性能监视分析等

- **其它功能**
  - DBMS与网络中其它软件系统的通信
  - 两个DBMS系统的数据转换
  - 异构数据库之间的互访和互操作

#### 4.数据库系统–Database System

(1)什么是数据库系统（Database System，简称DBS）

在计算机系统中引入数据库后的系统构成

(2)数据库系统的构成

- 数据库（Database）
- 数据库管理系统（及其开发工具）Database Management System
- 应用系统
- 数据库管理员 Database Administrator

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220616235327695.png" alt="image-20220616235327695" style="zoom:50%;"/>

(3)数据库系统的特点

**数据结构化**

- 整体数据的结构化是数据库的主要特征之一

- 整体结构化
  - 不再仅仅针对某一个应用，而是面向全组织
  - 不仅数据内部结构化，整体是结构化的，数据之间具有联系

- 数据库中实现的是数据的真正结构化
  - 数据的结构用数据模型描述，无需程序定义和解释
  - 数据可以变长
  - 数据的最小存取单位是数据项

**数据的共享性高，冗余度低，易扩充**

- 数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。

- 数据共享的好处
  - 减少数据冗余，节约存储空间
  - 避免数据之间的不相容性与不一致性
  - 使系统易于扩充

**数据独立性高**

- 物理独立性：指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。
- 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。
- 数据独立性是由DBMS的二级映像功能来保证的

**数据由DBMS统一管理和控制**

DBMS提供的数据控制功能

- **数据的安全性（Security）保护·**：保护数据，以防止不合法的使用造成的数据的泄密和破坏。
- **数据的完整性（Integrity）检查**：将数据控制在有效的范围内，或保证数据之间满足一定的关系。
- **并发（Concurrency）控制**：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。
- **数据库恢复（Recovery）**：将数据库从错误状态恢复到某一已知的正确状态。

**应用程序与数据的对应关系(数据库系统)**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220616235718279.png" alt="image-20220616235718279" style="zoom: 50%;"/>

### 2.数据管理技术的产生和发展

#### （1）什么是数据管理

- 对数据进行分类、组织、编码、存储、检索和维护
- 数据处理的中心问题

#### （2）数据管理技术的发展过程

- 人工管理阶段(20世纪40年代中–50年代中)
- 文件系统阶段(20世纪50年代末–60年代中)
- 数据库系统阶段(20世纪60年代末–现在)

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625180837990.png" alt="image-20220625180837990" style="zoom: 33%;"/>

#### （3）时期

20世纪60年代末以来

## 1.2 数据模型

（概念模型、逻辑模型–物理模型、层次模型、网状模型、关系模型、面向对象模型、对象关系模型）

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.2%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.jpg)

### 1.数据模型的概念

- 在数据库中用数据模型这个工具来抽象、表示和处理现实世界中的数据和信息。
- 通俗地讲数据模型就是现实世界的模拟。

**数据模型应满足三方面要求**：

- 能比较真实地模拟现实世界
- 容易为人所理解
- 便于在计算机上实现

### 2.两大类数据模型

数据模型分为两类（分属两个不同的层次）

(1)概念模型：也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。

(2)逻辑模型和物理模型

- **逻辑模型**主要包括**网状模型、层次模型、关系模型、面向对象模型**等，按计算机系统的观点对数据建模，用于DBMS实现。
- **物理模型**是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。

#### 客观对象的抽象过程—两步抽象

- 现实世界中的客观对象抽象为概念模型；
- 把概念模型转换为某一DBMS支持的数据模型。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617193138946.png" alt="image-20220617193138946" style="zoom:50%;"/>

### 3.数据模型的组成要素

#### (1)数据结构

**数据结构**是所研究的对象类型的集合。这些对象是数据库的组成成分，数据结构指对象和对象间联系的表达和实现，是对系统静态特征的描述，包括两个方面：

- 数据本身：类型、内容、性质。例如关系模型中的域、属性、关系等。
- 数据之间的联系：数据之间是如何相互关联的，例如关系模型中的主键、外键联系等。

#### (2)数据操作

##### 数据操作

- 对数据库中各种对象(型)的实例(值)允许执行的操作，及有关的操作规则

##### 数据操作的类型

- 查询
- 更新(包括插入、删除、修改)

#### (3)数据的完整性约束条件

数据的完整性约束条件是一组完整性规则的集合，规定数据库状态及状态变化所应满足的条件，以保证数据的正确性、有效性和相容性。

**完整性规则**：给定的数据模型中数据及其联系所具有的制约和储存规则

### 4.概念模型

#### (1)用途与基本要求

##### 概念模型的用途:

- 概念模型用于信息世界的建模
- 是现实世界到机器世界的一个中间层次
- 是数据库设计的有力工具
- 数据库设计人员和用户之间进行交流的语言

##### 对概念模型的基本要求:

- 较强的语义表达能力
- 能够方便、直接地表达应用中的各种语义知识
- 简单、清晰、易于用户理解

#### (2)信息世界中的基本概念

- (1)实体（Entity）

  - 客观存在并可相互区别的事物称为实体。

  - 可以是具体的人、事、物或抽象的概念。

- (2)属性（Attribute）

  - 实体所具有的某一特性称为属性。

  - 一个实体可以由若干个属性来刻画。

- (3)码（Key）

  - 唯一标识实体的属性集称为码。

- (4)域（Domain）

  - 属性的取值范围称为该属性的域。

- (5)实体型（Entity Type）

  - 用实体名及其属性名集合来抽象和刻画同类实体称为实体型

- (6)实体集（Entity Set）

  - 同一类型实体的集合称为实体集

- (7)联系（Relationship）

  - 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。

  - 实体**内部的联系**通常是指组成实体的各属性之间的联系
  - 实体**之间的联系**通常是指不同实体集之间的联系

#### (3)两个实体型之间的联系

用图形来表示两个实体之间的这三类联系

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617193647365.png" alt="image-20220617193647365" style="zoom: 33%;"/>

##### ①一对一联系（1:1）

###### 实例

- 一个班级只有一个正班长

- 一个班长只在一个班中任职

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617193751069.png" alt="image-20220617193751069" style="zoom: 33%;"/>

###### 定义

如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然。则称实体集A与实体集B具有一对一联系，记为1:1

##### ②一对多联系（1:n）

###### 实例

- 一个班级中有若干名学生，

- 每个学生只在一个班级中学习

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617193908525.png" alt="image-20220617193908525" style="zoom:33%;"/>

###### 定义

如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n

##### ③多对多联系（m:n）

###### 实例

- 课程与学生之间的联系：

- 一门课程同时有若干个学生选修
- 一个学生可以同时选修多门课程

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617193952498.png" alt="image-20220617193952498" style="zoom:33%;"/>

###### 定义

如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n

#### (4)两个以上实体型之间的联系

##### ①一对多联系（1:m||1:n）

若实体集E1，E2，…，En存在联系，对于实体集Ej（j=1，2，…，i-1i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的。

###### 实例

课程、教师与参考书三个实体型，一门课程可以有若干个教师讲授，使用若干本参考书，每一个教师只讲授一门课程，每一本参考书只供一门课程使用

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194155595.png" alt="image-20220617194155595" style="zoom:33%;"/>

##### ②一对一联系（1:1:1）

###### 实例

一个独生子女只有一个父亲，一个母亲
一个父亲也只有一个独生子女
一个母亲也只有一个独生子女

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194228989.png" alt="image-20220617194228989" style="zoom:33%;"/>

##### ③多对多联系（m:n:p）

###### 实例

供应商、项目、零件三个实体型
一个供应商可以供给多个项目多种零件
每个项目可以使用多个供应商供应的零件
每种零件可由不同供应商供给

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194305006.png" alt="image-20220617194305006" style="zoom:33%;"/>

#### (5)单个实体型内的联系

##### ①一对多联系（1:n）

###### 实例

职工实体型内部具有**领导与被领导**的联系，某一职工（干部）“领导”若干名职工，一个职工仅被另外一个职工直接领导，这是一对多的联系

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194355842.png" alt="image-20220617194355842" style="zoom:33%;"/>

##### ②一对一联系（1:1）

###### 实例

身份证可以唯一确认一个人的身份，人与身份证**有确认和被确认**的关系
一个身份证唯一确定一个人
一个人也唯一确认一个身份证

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194456355.png" alt="image-20220617194456355" style="zoom:33%;"/>

##### ③多对多联系（m:n）

###### 实例

饮料和厂商之间有**制造和被制造**的关系
多个饮料可以被多个厂商制造
多个厂商可以制造出多种饮料

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194523673.png" alt="image-20220617194523673" style="zoom:33%;"/>

#### (6)概念模型的一种表示方法

##### ①实体－联系方法(E-R方法)

E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用E-R图来描述现实世界的概念模型。E-R方法也称为E-R模型。

##### ②实体型

用矩形表示，矩形框内写明实体名。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194600893.png" alt="image-20220617194600893" style="zoom: 33%;"/>

##### ③属性

用椭圆形表示，并用无向边将其与相应的实体连接起来

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194623933.png" alt="image-20220617194623933" style="zoom:33%;"/>

##### ④联系

联系本身：
用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194644098.png" alt="image-20220617194644098" style="zoom:33%;"/>

##### ⑤联系的表示方法

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194702428.png" alt="image-20220617194702428" style="zoom:33%;"/>

##### ⑥联系的表示方法示例

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194729003.png" alt="image-20220617194729003" style="zoom:33%;"/>

##### ⑦联系的属性

联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194750983.png" alt="image-20220617194750983" style="zoom:33%;"/>

##### ⑧一个实例

**用E-R图表示某个工厂物资管理的概念模型**

- 实体

  仓库：仓库号、面积、电话号码
  零件：零件号、名称、规格、单价、描述
  供应商：供应商号、姓名、地址、电话号码、帐号
  项目：项目号、预算、开工日期
  职工：职工号、姓名、年龄、职称

**实体之间的联系如下：**

- (1)一个仓库可以存放多种零件，一种零件可以存放在多个仓库中。仓库和零件具有多对多的联系。用库存量来表示某种零件在某个仓库中的数量。

- (2)一个仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，仓库和职工之间是一对多的联系。职工实体型中具有一对多的联系
- (3)职工之间具有领导-被领导关系。即仓库主任领导若干保管员。
- (4)供应商、项目和零件三者之间具有多对多的联系

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617194919588.png" alt="image-20220617194919588" style="zoom: 50%;"/>

### 5.非关系模型

#### （1）层次模型(Hierarchical Model)

- 层次模型是数据库系统中最早出现的数据模型
- 层次数据库系统的典型代表是IBM公司的IMS（Information Management System）数据库管理系统
- 层次模型用树形结构来表示各类实体以及实体间的联系

##### ①数据结构

满足下面两个条件的基本层次联系的集合为层次模型

- 有且只有一个结点没有双亲结点，这个结点称为根结点
- 根以外的其它结点有且只有一个双亲结点

层次模型中的几个术语：根结点，双亲结点，兄弟结点，叶结点

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617195659884.png" alt="image-20220617195659884" style="zoom: 33%;"/>

##### ②特点

- 结点的双亲是唯一的
- 只能直接处理一对多的实体联系
- 每个记录类型可以定义一个排序字段，也称为·码字段
- 任何记录值只有按其路径查看时，才能显出它的全部意义
- 没有一个子女记录值能够脱离双亲记录值而独立存在

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617195757230.png" alt="image-20220617195757230" style="zoom: 50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617195835696.png" alt="image-20220617195835696" style="zoom: 50%;"/>

##### ③多对多联系在层次模型中的表示

###### 方法：

将多对多联系分解成一对多联系

###### 分解方法：

冗余结点法，虚拟结点法

##### ④数据操纵与完整性约束

层次模型的数据操纵：查询，插入，删除，更新

层次模型的完整性约束条件：

- 无相应的双亲结点值就不能插入子女结点值
- 如果删除双亲结点值，则相应的子女结点值也被同时删除
- 更新操作时，应更新所有相应记录，以保证数据的一致性

##### ⑤存储结构

###### 邻接法：

按照层次树前序遍历（T-L-R）的顺序把所有记录值依次邻接存放，即通过物理空间的位置相邻来实现层次顺序。又可分为：子女－兄弟链接法和层次序列链接法。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200021870.png" alt="image-20220617200021870" style="zoom:50%;"/>

**❶子女-兄弟链接法**
每个记录设两类指针，分别指向最左边的子女（每个记录型对应一个）和最近的兄弟

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200102974.png" alt="image-20220617200102974" style="zoom:50%;"/>

**❷层次序列链接法**
按树的前序穿越顺序链接各记录值

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200125713.png" alt="image-20220617200125713" style="zoom:50%;"/>

##### ⑥优缺点

###### 优点：

- 层次模型的数据结构比较简单清晰
- 查询效率高，性能优于关系模型，不低于网状模型
- 层次数据模型提供了良好的完整性支持

###### 缺点：

- 多对多联系表示不自然
- 对插入和删除操作的限制多，应用程序的编写比较复杂
- 查询子女结点必须通过双亲结点
- 由于结构严密，层次命令趋于程序化

#### （2）网状模型(Network Model)

网状数据库系统采用网状模型作为数据的组织方式

典型代表是DBTG系统：

- 亦称CODASYL系统
- 70年代由DBTG提出的一个系统方案
- 奠定了数据库系统的基本概念、方法和技术

实际系统:

- Cullinet Software Inc.公司的 IDMS
- Univac公司的 DMS1100
- Honeywell公司的IDS/2
- HP公司的IMAGE

##### ①数据结构

###### 网状模型:

**满足下面两个条件的基本层次联系的集合：**

1. 允许一个以上的结点无双亲；
2. 一个结点可以有多于一个的双亲。

**表示方法(与层次数据模型相同):**

- 实体型：用记录类型描述每个结点表示一个记录类型（实体）
- 属性：用字段描述每个记录类型可包含若干个字段
- 联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系

**网状模型与层次模型的区别:**

- 网状模型允许多个结点没有双亲结点
- 网状模型允许结点有多个双亲结点
- 网状模型允许两个结点之间有多种联系（复合联系）
- 网状模型可以更直接地去描述现实世界
- 层次模型实际上是网状模型的一个特例

网状模型中子女结点与双亲结点的联系可以不唯一，要为每个联系命名，并指出与该联系有关的双亲记录和子女记录

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200433387.png" alt="image-20220617200433387" style="zoom: 67%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200509600.png" alt="image-20220617200509600" style="zoom:50%;"/>

**多对多联系在网状模型中的表示:**

**方法**：将多对多联系直接分解成一对多联系

**例如**：一个学生可以选修若干门课程，·某一课程可以被多个学生选修，学生与课程之间是多对多联系·

引进一个学生选课的联结记录，由3个数据项组成：学号，课程号，成绩
表示某个学生选修某一门课程及其成绩

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200622404.png" alt="image-20220617200622404" style="zoom: 50%;"/>

##### ②网状数据模型的操纵与完整性约束（续）

网状数据库系统（如DBTG）对数据操纵加了一些限制，提供了一定的完整性约束

- 码：唯一标识记录的数据项的集合
- 一个联系中双亲记录与子女记录之间是一对多联系
- 支持双亲记录和子女记录之间某些约束条件

##### ③存储结构

###### 关键：

实现记录之间的联系

###### 常用方法：

单向链接，双向链接，环状链接，向首链接

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617200840194.png" alt="image-20220617200840194" style="zoom:50%;"/>

##### ④优缺点

###### 优点

能够更为直接地描述现实世界，如一个结点可以有多个双亲；
具有良好的性能，存取效率较高；

###### 缺点

结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握；
DDL、DML语言复杂，用户不容易使用；

### 6.关系模型

关系数据库系统采用关系模型作为数据的组织方式
1970年美国IBM公司San Jose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型
计算机厂商新推出的数据库管理系统几乎都支持关系模型

#### （1）数据结构

在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。

##### 几个名词解释：

- 关系（Relation）：一个关系对应通常说的一张表


- 元组（Tuple）：表中的一行即为一个元组


- 属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名


- 主键（Key）：表中的某个属性组，它可以唯一确定一个元组。

- 域（Domain）：属性的取值范围。


- 分量：元组中的一个属性值。


- 关系模式

  对关系的描述

  关系名（属性1，属性2，…，属性n）

  学生（学号，姓名，年龄，性别，系，年级）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617201142905.png" alt="image-20220617201142905" style="zoom: 50%;"/>

举几个例子：

- 例1

  学生、系、系与学生之间的·一对多联系：

  学生（学号，姓名，年龄，性别，系号，年级）

  系(系号，系名，办公地点)

- 例2

  系、系主任、系与系主任间的一对一联系

- 例3

  学生、课程、学生与课程之间的多对多联系：

  学生（学号，姓名，年龄，性别，系号，年级）

  课程（课程号，课程名，学分）

  选修（学号，课程号，成绩）

##### 规范化：

- 关系必须是规范化的，满足一定的规范条件

- 最基本的规范条件：**关系的每一个分量必须是一个不可分的数据项,不允许表中还有表**
- 图1.27中工资和扣除是可分的数据项,不符合关系模型要求

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617201422040.png" alt="image-20220617201422040" style="zoom:67%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617201453057.png" alt="image-20220617201453057" style="zoom: 67%;"/>

#### （2）关系数据模型的操纵与完整性约束

数据操作是集合操作，操作对象和操作结果都是关系。查询，插入，删除，更新

数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”

关系的完整性约束条件：

- 实体完整性
- 参照完整性
- 用户定义的完整性

#### （3）存储结构

- 实体及实体间的联系都用表来表示

- 表以文件形式存储

  有的DBMS一个表对应一个操作系统文件；

  有的DBMS自己设计文件结构；

#### （4）优缺点

##### 优点

建立在严格的数学概念的基础上;

概念单一:

- 实体和各类联系都用关系来表示;
- 对数据的检索结果也是关系;

关系模型的存取路径对用户透明;

- 具有更高的数据独立性，更好的安全保密性
- 简化了程序员的工作和数据库开发建立的工作;

##### 缺点

存取路径对用户透明导致查询效率往往不如非关系数据模型;
为提高性能，必须对用户的查询请求进行优化,增加了开发DBMS的难度;

### 7.面向对象数据模型

将语义数据模型和面向对象程序设计方法结合起来，用面向对象观点来描述现实世界实体(对象)的逻辑组织、对象间限制、联系等的模型。

一系列面向对象核心概念构成了面向对象数据模型( Object Oriented Data Model,00模型)的基础，主要包括以下一些概念:

- (1)现实世界中的任何事物都被建模为对象。每个对象具有一个唯一的对象标识(OID)。

- (2)对象是其状态和行为的封装，其中状态是对象属性值的集合，行为是变更对象状

  态的方法集合。

- (3)具有相同属性和方法的对象的全体构成了类，类中的对象称为类的实例。

- (4)类的属性的定义域也可以是类，从而构成了类的复合。类具有继承性，一个类可以继承另一个类的属性与方法，被继承类和继承类也称为超类和子类。类与类之间的复合与继承关系形成了一个有向无环图，称为类层次。

- (5)对象是被封装起来的，它的状态和行为在对象外部不可见，从外部只能通过对象显式定义的消息传递对对象进行操作。

面向对象数据库(OODB)的研究始于20世纪80年代，有许多面向对象数据库产品相继问世，较著名的有Object Store、02、ONTOS等。

与传统数据库一样，面向对象数据库系统对数据的操纵包括数据查询、增加、删除、修改等，也具有并发控制、故障恢复、存储管理等完整的功能。不仅能支持传统数据库应用，也能支持非传统领域的应用，包括CAD/CAM、OA、CIMS、GIS以及图形、图像等多媒体领域、工程领域和数据集成等领域。

尽管如此，由于面向对象数据库操作语言过于复杂，没有得到广大用户，特别是开发人员的认可，加上面向对象数据库企图完全替代关系数据库管理系统的思路，增加了企业系统升级的负担，客户不接受，面向对象数据库产品终究没有在市场上获得成功。

### 8.对象关系模型

- 对象关系数据库系统(Object Relational DataBase System, ORDBS)是关系数据库与面向对象数据库的结合。
- 它保持了关系数据库系统的非过程化数据存取方式和数据独立性，继承了关系数据库系统已有的技术，支持原有的数据管理，又能支持00模型和对象管理。各数据库厂商都在原来的产品基础上进行了扩展。
- 1999 年发布的SQL标准(也称为SQL99)，增加了SQL/Object Language Binding,提供了面向对象的功能标准。SQL99对ORDBS标准的制定滞后于实际系统的实现。所以各个ORDBS产品在支持对象模型方面虽然思想一致，但是所采用的术语、语言语法、扩展的功能都不尽相同。



## 1.3 数据库系统结构和组成

(内模式、外模式、模式、人员……)

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E6%88%90.jpg)

### 1.数据库系统结构

#### （1）两种角度

从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构

从数据库最终用户角度看（数据库系统外部的体系结构），数据库系统的结构分为:

- 单用户结构
- 主从式结构
- 分布式结构
- 客户/服务器
- 浏览器/应用服务器/数据库服务器多层结构等

#### （2）数据库系统模式的概念

> 模式是数据库结构的描述、关系模式是表的结构的描述;

##### “型”和“值”的概念

型(Type):对某一类数据的结构和属性的说明
值(Value):是型的一个具体赋值

###### 例如

学生记录型：（学号，姓名，性别，系别，年龄，籍贯）
一个记录值：（900201，李明，男，计算机，22，江苏）

##### 模式（Schema）

- 数据库逻辑结构和特征的描述
- 是型的描述
- 反映的是数据的结构及其联系
- 模式是相对稳定的

###### 实例（Instance）

- 模式的一个具体值
- 反映数据库某一时刻的状态
- 同一个模式可以有很多实例
- 实例随数据库中的数据的更新而变动

一个数据库只有一个模式，可以把模式看成唯一的数据库，实例就是数据库里面的多个表

###### 例如

在学生选课数据库模式中，包含学生记录、课程记录和学生选课记录

2003年的一个学生数据库实例，包含：

- 2003年学校中所有学生的记录
- 学校开设的所有课程的记录
- 所有学生选课的记录

2002年度学生数据库模式对应的实例与2003年度学生数据库模式对应的实例是不同的

#### （3）数据库系统的三级模式结构

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617202917550.png" alt="image-20220617202917550" style="zoom:50%;"/>

##### ①模式（Schema）

**模式（也称逻辑模式）**

- 数据库中全体数据的逻辑结构和特征的描述
- 所有用户的公共数据视图，综合了所有用户的需求

一个数据库只有一个模式，可以把模式看成唯一的数据库，实例就是数据库里面的多个表

**模式的地位：是数据库系统模式结构的中间层**

- 与数据的物理存储细节和硬件环境无关
- 与具体的应用程序、开发工具及高级程序设计语言无关

**模式的定义:**

- 数据的逻辑结构（数据项的名字、类型、取值范围等）
- 数据之间的联系
- 数据有关的安全性、完整性要求

##### ②外模式（External Schema）

**外模式（也称子模式或用户模式）**

- 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述
- 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示，可以看成把数据库的部分数据，运用在不同的应用程序上，在UI界面上显示

一个数据库只有一个模式，可以把模式看成唯一的数据库，实例就是数据库里面的多个表

**外模式的地位：介于模式与应用之间**

- 模式与外模式的关系：一对多

  外模式通常是模式的子集;

  一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求;

  对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同;

- 外模式与应用的关系：一对多

  同一外模式也可以为某一用户的多个应用系统所使用;

  但一个应用程序只能使用一个外模式;可以看成把数据库的部分数据，运用在不同的应用程序上，在UI界面上显示

**外模式的用途**

1. 保证数据库安全性的一个有力措施；
2. 每个用户只能看见和访问所对应的外模式中的数据；

##### ③内模式（Internal Schema）

**内模式（也称存储模式）**

是数据物理结构和存储方式的描述
是数据在数据库内部的表示方式:

- 记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）
- 索引的组织方式
- 数据是否压缩存储
- 数据是否加密
- 数据存储记录结构的规定

一个数据库只有一个内模式

例如学生记录，如果按堆存储，则插入一条新记录总是放在学生记录存储的最后边.

如果按学号升序存储，则插入一条记录就要找到它应在的位置插入，如图1.29（b）所示
如果按照学生年龄聚簇存放，假如新插入的S3是16岁，则应插入的位置如图1.29（c）所示

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617203546204.png" alt="image-20220617203546204" style="zoom:50%;"/>

##### ④数据库模式、外模式、内模式总结

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617203650993.png" alt="image-20220617203650993" style="zoom:50%;"/>

###### 数据库模式

- 即全局逻辑结构是数据库的中心与关键
- 独立于数据库的其他层次
- 设计数据库模式结构时应首先确定数据库的逻辑模式

###### 数据库的外模式

- 面向具体的应用程序
- 定义在逻辑模式之上
- 独立于存储模式和存储设备
- 当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动
- 设计外模式时应充分考虑到应用的扩充性

###### 数据库的内模式

- 依赖于它的全局逻辑结构
- 独立于具体的存储设备
- 将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率

#### （4）数据库的二级映像功能与数据独立性

三级模式是对数据的三个抽象级别

二级映象在DBMS内部实现这三个抽象层次的联系和转换

- 外模式/模式映像

- 模式/内模式映像

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617203812900.png" alt="image-20220617203812900" style="zoom:50%;"/>

##### ①外模式/模式映象

- 模式：描述的是数据的全局逻辑结构
- 外模式：描述的是数据的局部逻辑结构
- 同一个模式可以有任意多个外模式
- 每一个外模式，数据库系统都有一个外模式/模式映象，定义外模式与模式之间的对应关系,看成数据库的数据与API调用的部分数据之间的关系(I think)
- 映象定义通常包含在各自外模式的描述中

###### 保证数据的逻辑独立性

- 当模式改变时，数据库管理员修改有关的外模式/模式映象，使外模式保持不变
- 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。

##### ②模式/内模式映象

**模式/内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。**

例如，说明逻辑记录和字段在内部是如何表示的

- 数据库中模式/内模式映象是唯一的
- 该映象定义通常包含在模式描述中

**保证数据的物理独立性**

- 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式/内模式映象，使模式保持不变.

- 应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。

**特定的应用程序**

- 在外模式描述的数据结构上编制的
- 依赖于特定的外模式
- 与数据库的模式和存储结构独立，不同的应用程序有时可以共用同一个外模式

**数据库的二级映像**

- 保证了数据库外模式的稳定性
- 从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改

**数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去**

**数据的存取由DBMS管理**

- 用户不必考虑存取路径等细节
- 简化了应用程序的编制
- 大大减少了应用程序的维护和修改

### 2.数据库的组成

数据库，数据库管理系统（及其开发工具），应用系统，数据库管理员，硬件平台及数据库，软件，人员

#### （1）硬件平台及数据库

**数据库系统对硬件资源的要求**

(1)足够大的内存

- 操作系统
- DBMS的核心模块
- 数据缓冲区
- 应用程序

(2)足够大的外存

- 磁盘或磁盘阵列
- 数据库
- 光盘、磁带
- 数据备份

(3)较高的通道能力，提高数据传送率

#### （2）软件

- DBMS
- 支持DBMS运行的操作系统
- 与数据库接口的高级语言及其编译系统
- 以DBMS为核心的应用开发工具
- 为特定应用环境开发的数据库应用系统

#### （3）人员

数据库管理员，系统分析员和数据库设计人员，应用程序员，用户。

不同的人员涉及不同的数据抽象级别，具有不同的数据视图，如下图所示

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617204537002.png" alt="image-20220617204537002" style="zoom:50%;"/>

##### ①数据库管理员(DBA)

**具体职责：**

1.决定数据库中的信息内容和结构
2.决定数据库的存储结构和存取策略
3.定义数据的安全性要求和完整性约束条件
4.监控数据库的使用和运行

- 周期性转储数据库
- 数据文件
- 日志文件
- 系统故障恢复
- 介质故障恢复
- 监视审计文件

5.数据库的改进和重组

- 性能监控和调优
- 定期对数据库进行重组织，以提高系统的性能
- 需求增加和改变时，数据库须需要重构造

##### ②系统分析员

**具体职责：**

- 负责应用系统的需求分析和规范说明
- 与用户及DBA协商，确定系统的硬软件配置
- 参与数据库系统的概要设计

##### ③数据库设计人员

**具体职责：**

- 参加用户需求调查和系统分析
- 确定数据库中的数据
- 设计数据库各级模式

##### ④应用程序员

**具体职责：**

设计和编写应用系统的程序模块
进行调试和安装

##### ⑤用户

用户是指最终用户（End User）。最终用户通过应用系统的用户接口使用数据库。

###### 1.偶然用户

不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息。企业或组织机构的高中级管理人员

###### 2.简单用户

主要工作是查询和更新数据库。银行的职员、机票预定人员、旅馆总台服务员

###### 3.复杂用户

工程师、科学家、经济学家、科技工作者等。直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的API编制自己的应用程序



# 第2 章关系数据库

## 2.1 关系数据结构及形式化定义

（关系、关系模式、关系数据库）

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/2.1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89.jpg)

### 1.关系

**什么是关系？**

- 单一的数据结构----关系

  现实世界的实体以及实体间的各种联系均用关系来表示

- 逻辑结构----二维表

  从用户角度，关系模型中数据的逻辑结构是一张二维表

- 建立在集合代数的基础上

#### （1）域（Domain）

域是一组具有相同数据类型的值的集合。

例：整数，实数，介于某个取值范围的整数，长度指定长度的字符串集合，{‘男’，‘女’}
………………

#### （2）笛卡尔积（Cartesian Product）

##### 笛卡尔积

给定一组域D1，D2，…，Dn，这些域中可以有相同的。
D1，D2，…，Dn的笛卡尔积为：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617212735232.png" alt="image-20220617212735232" style="zoom:50%;"/>

所有域的所有取值的一个组合；不能重复；

##### 元组（Tuple）

笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组（n-tuple）或简称元组(Tuple);
(张清玫，计算机专业，李勇)、(张清玫，计算机专业，刘晨)等都是元组;

##### 分量（Component）

笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个分量;
张清玫、计算机专业、李勇、刘晨等都是分量;

##### 基数（Cardinal number）

可以把基数看做笛卡尔积元素的个数，及元组的个数；
若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1，2，…，n），则D1×D2×…×Dn的基数M为：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617212858862.png" alt="image-20220617212858862" style="zoom: 33%;"/>

##### 笛卡尔积的表示方法

笛卡尔积可表示为一个二维表;
表中的每行对应一个元组，表中的每列对应一个域;

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617213313558.png" alt="image-20220617213313558" style="zoom:50%;"/>

#### （3）关系（Relation）

##### 关系

笛卡尔积·D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，表示为：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617213422005.png" alt="image-20220617213422005" style="zoom:33%;"/>

R：关系名
n：关系的目或度（Degree）

##### 元组

关系中的每个元素是关系中的元组，通常用t表示。

##### 单元关系与二元关系

当n=1时，称该关系为单元关系（Unary relation）或一元关系;
当n=2时，称该关系为二元关系（Binary relation）;

##### 关系的表示

关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617213505528.png" alt="image-20220617213505528" style="zoom: 50%;"/>

##### 属性

关系中不同列可以对应相同的域;
为了加以区分，必须对每列起一个名字，称为属性（Attribute）;
n目关系必有n个属性;

##### 码（键，key）

###### 超键（super key）

若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为超键。

###### 候选码（Candidate key）

若关系中的某一属性组的值能唯一地标识一个元组，且该属性组不存在任何能唯一地标识一个元组的真子集，则称该属性组为候选码，也称键;键是超键的真子集，键也一定是超键，但超键不一定是键。

###### 全码（All-key）

最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）;

###### 主键（主键）

若一个关系有多个候选键，则选定其中一个为主键（Primary key）;

###### 主属性

候选码的诸属性称为主属性（Prime attribute）;
不包含在任何侯选码中的属性称为非主属性（ Non-Prime attribute）或非码属性（Non-key attribute）;

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617213653313.png" alt="image-20220617213653313" style="zoom:50%;"/>

**D1，D2，…，Dn的笛卡尔积的某个子集才有实际含义**

例：上面表2.1 的笛卡尔积没有实际意义
取出有实际意义的元组来构造关系
关系：SAP(SUPERVISOR，SPECIALITY，POSTGRADUATE)
假设：导师与专业：1:1，导师与研究生：1:n
主键：POSTGRADUATE（假设研究生不会重名）
SAP关系可以包含三个元组:｛(张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)，(刘逸，信息专业，王敏)}

#### （4）三类关系

- 基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示

- 查询表：查询结果对应的表

- 视图表：由基本表或其他视图表导出的表，是**虚表**，不对应实际存储的数据

  

- 基本关系(二维表)的性质
  - ①列是同质的（Homogeneous）;
  - ②不同的列可出自同一个域,其中的每一列称为一个属性,不同的属性要给予不同的属性名;
  - ③列的顺序无所谓，列的次序可以任意交换;
  - ④任意两个元组的候选码不能相同;
  - ⑤行的顺序无所谓，行的次序可以任意交换;
  - ⑥分量必须取原子值,这是规范条件中最基本的一条; 

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617214107146.png" alt="image-20220617214107146" style="zoom: 67%;"/>

### 2.关系模式

#### （1）什么是关系模式

**关系模式（Relation Schema）是型**
**关系是值**
**关系模式是对关系的描述:**

- 元组集合的结构
  - 属性构成
  - 属性来自的域
  - 属性与域之间的映象关系

- 元组语义以及完整性约束条件

- 属性间的数据依赖关系集合

#### （2）定义关系模式

**关系模式可以形式化地表示为：**

- R（U，D，DOM，F）
- R 关系名
- U 组成该关系的属性名集合
- D 属性组U中属性所来自的域
- DOM 属性向域的映象集合
- F 属性间的数据依赖关系集合

**例：**
导师和研究生出自同一个域——人，取不同的属性名，并在模式中定义属性向域的映象，即说明它们分别出自哪个域;
DOM（SUPERVISOR-PERSON）= DOM（POSTGRADUATE-PERSON）=PERSON

**关系模式通常可以简记为**
R (U)或 R (A1，A2，…，An)
R: 关系名
A1，A2，…，An : 属性名
注：域名及属性向域的映象常常直接说明为属性的类型、长度

### 3.关系模式和关系的对比

- 关系模式

  对关系的描述

  静态的、稳定的

- 关系

  关系模式在某一时刻的状态或内容

  动态的、随时间不断变化的

  关系模式和关系往往统称为关系

> 在数据库学科中可以把关系模式理解为表的结构、属性之间的关系、约束条件，把关系理解为二维表

### 4.关系数据库

关系数据库

- 在一个给定的应用领域中，所有关系的集合构成一个关系数据库

关系数据库模式包括

- 若干域的定义;
- 在这些域上定义的若干关系模式;

关系数据库的型与值

- 关系数据库的型: 关系数据库模式,对关系数据库的描述。
- 关系数据库的值: 关系模式在某一时刻对应的关系的集合，简称为关系数据库



## 2.2 关系操作、关系完整性、关系代数

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/2.2%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E3%80%81%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%80%A7%E3%80%81%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.jpg)

### 1.关系操作

#### （1）基本关系操作

常用的关系操作

- 查询：选择、投影、连接、除、并、交、差
- 数据更新：插入、删除、修改
- 查询的表达能力是其中最主要的部分
- 选择、投影、并、差、笛卡尔基是5种基本操作

关系操作的特点

- 集合操作方式：操作的对象和结果都是集合，一次一集合的方式

#### （2）关系数据库语言的分类

**关系代数语言**

- 用对关系的运算来表达查询要求；
- 代表：ISBL；
- 关系演算语言：用谓词来表达查询要求；

**元组关系演算语言**

- 谓词变元的基本对象是元组变量；
- 代表：APLHA, QUEL；

**域关系演算语言**

- 谓词变元的基本对象是域变量；
- 代表：QBE；

具有关系代数和关系演算双重特点的语言；

- 代表：SQL（Structured Query Language）；

### 2.关系的完整性

#### （1）关系的三类完整性约束

**实体完整性和参照完整性：**

- 关系模型必须满足的完整性约束条件;
- 称为关系的**两个不变性**，应该由关系系统自动支持;

**用户定义的完整性**：应用领域需要遵循的约束条件，体现了具体领域中的语义约束;

#### （2）实体完整性（Entity Integrity）

**若属性A是基本关系R的主属性，则属性A不能取空值**

例：
SAP(SUPERVISOR，SPECIALITY，POSTGRADUATE)
POSTGRADUATE：
主键（假设研究生不会重名）
不能取空值

**实体完整性规则的说明**

(1)实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
(2)现实世界中的实体是可区分的，即它们具有某种唯一性标识。
(3)关系模型中以主键作为唯一性标识。
(4)主键中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为**实体完整性**

#### （3）参照完整性

##### ❶关系间的引用

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220117603.png" alt="image-20220617220117603" style="zoom: 50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220147765.png" alt="image-20220617220147765" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220207239.png" alt="image-20220617220207239" style="zoom:50%;"/>

##### ❷外键（Foreign Key）

设F是基本关系R的一个或一组属性，但不是关系R的键。如果F与基本关系S的主键Ks相对应，则称F是基本关系R的外键,即该键是另一个表的主键。
基本关系R称为参照关系（Referencing Relation），即本表。
基本关系S称为被参照关系（Referenced Relation）或目标关系（Target Relation），即外键对应的主键所在的表。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220241906.png" alt="image-20220617220241906" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220301185.png" alt="image-20220617220301185" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220315165.png" alt="image-20220617220315165" style="zoom:50%;"/>

- 关系R和S不一定是不同的关系
- 目标关系S的主键Ks 和参照关系的外键F必须定义在同一个（或一组）域上
- 外键并不一定要与相应的主键同名，当外键与相应的主键属于不同关系时，往往取相同的名字，以便于识别

##### ❸参照完整性规则

若属性（或属性组）F是基本关系R的外键它与基本关系S的主键Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：

- 或者取空值（F的每个属性值均为空值）

- 或者等于S中某个元组的主键值
- 外键的值要么为空，要么为S中某个元组的主键值

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220354265.png" alt="image-20220617220354265" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220412196.png" alt="image-20220617220412196" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220424231.png" alt="image-20220617220424231" style="zoom:50%;"/>

#### （4）用户定义的完整性

- 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求
- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220445231.png" alt="image-20220617220445231" style="zoom:33%;"/>

### 3.关系代数

#### （1）关系代数运算符

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220514723.png" alt="image-20220617220514723" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220531744.png" alt="image-20220617220531744" style="zoom:50%;"/>

#### （2）集合运算

如果数据表R和数据表S具有相同的列结构，对应的列来自于相同的数据类型域并具有相同的含义，那么这两个数据表是兼容的。**只有兼容的数据表才能使用集合运算。**

##### ①并（Union）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220611893.png" alt="image-20220617220611893" style="zoom: 50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220642209.png" alt="image-20220617220642209" style="zoom:50%;"/>

##### ②差（Difference）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220658299.png" alt="image-20220617220658299" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220712507.png" alt="image-20220617220712507" style="zoom:50%;"/>

##### ③交（Intersection）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220729806.png" alt="image-20220617220729806" style="zoom: 50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220818274.png" alt="image-20220617220818274" style="zoom:50%;"/>

##### ④笛卡尔积（Cartesian Product）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220836588.png" alt="image-20220617220836588" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220854358.png" alt="image-20220617220854358" style="zoom:50%;"/>

#### （3）自然关系运算

##### ①几个记号

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220912420.png" alt="image-20220617220912420" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220926250.png" alt="image-20220617220926250" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617220942916.png" alt="image-20220617220942916" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221000346.png" alt="image-20220617221000346" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221014922.png" alt="image-20220617221014922" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221029310.png" alt="image-20220617221029310" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221045484.png" alt="image-20220617221045484" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221101844.png" alt="image-20220617221101844" style="zoom:50%;"/>

##### ②选择（Selection）

使用where运算符，表示从数据表中选择出满足where指定条件的数据（条件可加and，or，not）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221143775.png" alt="image-20220617221143775" style="zoom:50%;"/>



<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221159971.png" alt="image-20220617221159971" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221220095.png" alt="image-20220617221220095" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221234013.png" alt="image-20220617221234013" style="zoom:50%;"/>

##### ③投影（Projection）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221257907.png" alt="image-20220617221257907" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221328936.png" alt="image-20220617221328936" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221349243.png" alt="image-20220617221349243" style="zoom:50%;"/>

##### ④连接（Join）

等值连接和自然连接

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221407991.png" alt="image-20220617221407991" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221426302.png" alt="image-20220617221426302" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221440485.png" alt="image-20220617221440485" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221455695.png" alt="image-20220617221455695" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221506855.png" alt="image-20220617221506855" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221519250.png" alt="image-20220617221519250" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221552113.png" alt="image-20220617221552113" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221606994.png" alt="image-20220617221606994" style="zoom:50%;"/>

###### ❶外连接，左连接、右连接

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221625427.png" alt="image-20220617221625427" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221638568.png" alt="image-20220617221638568" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221653476.png" alt="image-20220617221653476" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221706469.png" alt="image-20220617221706469" style="zoom:50%;"/>

##### ⑤除（Division）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221719046.png" alt="image-20220617221719046" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221752212.png" alt="image-20220617221752212" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221807249.png" alt="image-20220617221807249" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221820726.png" alt="image-20220617221820726" style="zoom:50%;"/>

##### ⑥综合举例

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221838504.png" alt="image-20220617221838504" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221854455.png" alt="image-20220617221854455" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221912145.png" alt="image-20220617221912145" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221926908.png" alt="image-20220617221926908" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617221938204.png" alt="image-20220617221938204" style="zoom:50%;"/>



<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617222020097.png" alt="image-20220617222020097" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617222032257.png" alt="image-20220617222032257" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220617222043605.png" alt="image-20220617222043605" style="zoom:50%;"/>

#### （4）运算优先级

投影>选择>乘积>连接>除法>交>并>差



# 第3 章关系数据库标准语言SQL

资料整理在：[sql](C:\Users\86184\桌面\网安笔记\编程知识大全（各种编程语言）\SQL\SQL.pdf)

## 3.1 SQL概述及数据定义

（模式SCHEMA、表TABLE、索引INDEX）

### 1.思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.1SQL%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.jpg)

### 2.SQL概述

#### （1）什么是SQL?

SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言，是一个通用的、功能极强的关系数据库语言

#### （2）SQL的特点

##### ①综合统一

数据定义语言 DDL(Data Definition Language)：用于定义SQL基本表，视图，索引等

数据操纵语言 DML（Data Manipulation Language）：分为数据查询和数据更新（插入，删除和更新）两大类操作

数据控制语言 DCL(Data Control Language)：用于数据表和视图等数据库对象的访问授权，完整性规则的描述和事务控制等。

集数据定义语言 DDL(Data Definition Language)，数据操纵语言 DML（Data Manipulation Language），数据控制语言 DCL(Data Control Language)功能于一体。

可以独立完成数据库生命周期中的全部活动：

- 定义关系模式，插入数据，建立数据库；
- 对数据库中的数据进行查询和更新；
- 数据库重构和维护
- 数据库安全性、完整性控制等

用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。

数据操作符统一

##### ②高度非过程化

1. 非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径
2. SQL只要提出“做什么”，无须了解存取路径。
3. 存取路径的选择以及SQL的操作过程由系统自动完成。

##### ③面向集合的操作方式

非关系数据模型采用面向记录的操作方式，操作对象是一条记录
SQL采用集合操作方式：

- 操作对象、查找结果可以是元组的集合
- 一次插入、删除、更新操作的对象可以是元组的集合

##### ④以同一种语法结构提供多种使用方式

SQL是独立的语言：能够独立地用于联机交互的使用方式

SQL又是嵌入式语言：SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用

##### ⑤语言简洁，易学易用

SQL功能极强，完成核心功能只用了9个动词。

| SQL功能  | 动词                   |
| -------- | ---------------------- |
| 数据查询 | SELECT                 |
| 数据定义 | CREATE、DROP、ALTER    |
| 数据操纵 | INSERT、UPDATE、DELETE |
| 数据控制 | GRANT、REVOKE          |

#### （3）SQL的基本概念

SQL支持关系数据库三级模式结构：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621173452130.png" alt="image-20220621173452130" style="zoom:50%;"/>

##### 基础表

1. 本身独立存在的表（CREATE TABLE语句创建的表）
2. **SQL中一个关系就对应一个基础表**
3. 一个(或多个)基础表对应一个存储文件
4. 一个表可以带若干索引

##### 存储文件

1. 逻辑结构组成了关系数据库的内模式
2. 物理结构是任意的，对用户透明

##### 视图（view）

1. 从一个或几个基本表导出的表
2. 数据库中**只存放视图的定义**而不存放视图对应的数据
3. 视图是一个虚表
4. 用户可以在视图上再定义视图

> - 在SQL中，视图是基于SQL语句的结果集的可视化的表。
> - 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。
> - 我们可以向视图添加SQL函数、WHERE以及JOIN语句，我们也可以提交数据，就像这些来自于某个单一的表。
> - 注释：数据库的设计和结构不会受到视图中的函数、where或join语句的影响。

#### （4）SQL基本语法规则

- 大写字母：代表保留关键字
- 小写字母：表示数据库对象标识符和表达式
- {}大括号中的内容为必选参数，其中的多个选项用竖线|分隔开
- |竖线：表示参数之间的“或”关系
- []方括号：表示列出的选项是可选的，用户可以不选择
- 省略号：表示重复前面的语法
- 注释
  - 单行注释：用两个破折号"\--"表示
  - 块注释：用“/**/”表示

### 3.数据字典(系统定义表，系统目录)

**数据字典**是关系数据库管理系统内部的一组系统表，它**记录了数据库中所有的定义信息**，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。在进行查询优化和查询处理时，数据字典中的信息是其重要依据。

### 4.数据定义

#### （1）数据定义概览

SQL的数据定义功能: 模式定义、表定义、视图和索引的定义

![image-20220621173633812](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621173633812.png)

#### （2）模式的定义与删除—SCHEMA

定义模式实际上定义了一个**命名空间**

- 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。
- 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。
- CREATE SCHEMA <模式名> AUTHORIZATION <用户名>[<表定义子句>|<视图定义子句>|<授权定义子句>]
- 如果没有指定<模式名>，那么<模式名>隐含为<用户名>

##### ①定义模式

dbo database owner数据库的创建者,创建该对象的用户. guest 顾客能够访问数据库中对象的数据,要求dbo分配权限给guest,一般给他查看的权限select。

先创建一个数据库用户。

[例1]定义一个学生-课程模式S-T

```sql
 CREATE SCHEMA "S-T" AUTHORIZATION BitHachi;
//为用户BitHachi定义了一个模式S-T
```
如果没有指定<模式名>，那么<模式名>隐含为<用户名>

```sql
CREATE SCHEMA AUTHORIZATION BitHachi；
<模式名>隐含为用户名BitHachi
这个不知道咋回事，没出结果，默认模式BitHachi没创建出来，没显示
```

[例2]为用户BitHachi创建了一个模式S-T，并在其中定义了一个表TAB1。

```sql
CREATE SCHEMA "S-T" AUTHORIZATION BitHachi
CREATE TABLE TAB1(
COL1 SMALLINT,
COL2 INT,
COL3 CHAR(20),
COL4 NUMERIC(10,3),
COL5 DECIMAL(5,2)
);
```

##### ②删除模式

- DROP SCHEMA <模式名> <CASCADE|RESTRICT>
- CASCADE(级联)：删除模式的同时把该模式中所有的数据库对象全部删除
- RESTRICT(限制)：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。
- 当该模式中没有任何下属的对象时才能执行。
- 以下是运行结果，至于为什么是错误的，暂且放在这里，等熟悉相关知识之后，再来解决。

```sql
DROP SCHEMA "S-T" CASCADE;
```

![image-20220621174205536](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174205536.png)

```sql
DROP SCHEMA "S-T" RESTRICT;
```


![image-20220621174229670](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174229670.png)

#### （3）基本表的定义、删除与修改—TABLE

##### ①定义基本表的标准格式

```sql
CREATE TABLE <表名>(
<列名> <数据类型>[ <列级完整性约束条件> ]
[，<列名> <数据类型>[ <列级完整性约束条件>]]
………
[，<表级完整性约束条件> ]
);
```


如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。

示例：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174338132.png" alt="image-20220621174338132" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174357445.png" alt="image-20220621174357445" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174414261.png" alt="image-20220621174414261" style="zoom:50%;"/>

##### ②数据类型

**数据类型**分为系统数据类型和用户定义数据类型。

- **用户定义数据类型**可以使用系统存储过程sp_addtype建立，也可以在企业管理器窗口采用交互式方式建立。

SQL中域的概念用数据类型来实现

定义表的属性时需要指明其数据类型及长度

选用哪种数据类型：取值范围，要做哪些运算

以下是系统数据类型，不同数据库的数据类型可能有所不同，可查相关文档。

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg)

##### ③修改基本表

```sql
ALTER TABLE <表名>
[ ADD <新列名> <数据类型> [ 完整性约束]]
[ DROP <完整性约束名> ]
[ ALTER COLUMN<列名> <数据类型> ]；
```

[例8]向Student表增加“入学时间”列，其数据类型为日期型。

不论基本表中原来是否已有数据，新增加的列一律为空值。

```sql
 ALTER TABLE Student ADD S_entrance DATE;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174642596.png" alt="image-20220621174642596" style="zoom: 67%;"/>

[例9]将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。

```sql
ALTER TABLE Student ALTER COLUMN Sage INT;
```

![image-20220621174724867](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174724867.png)

[例10]增加课程名称必须取唯一值的约束条件。

```sql
	ALTER TABLE Course ADD UNIQUE(Cname);
```
![image-20220621174746932](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174746932.png)

##### ④删除基本表

###### 标准格式：

```sql
DROP TABLE <表名>［RESTRICT| CASCADE］；
```

RESTRICT：删除表是有限制的。

- 欲删除的基本表没有被其它数据库对象引用时，才能将其删除
- 如果存在依赖该表的对象，则此表不能被删除

CASCADE：删除该表没有限制。

- 在删除基本表的同时，相关的依赖对象**一起删除**（级联删除）

[例11]删除Student表

基本表定义被删除，数据被删除
表上建立的索引、视图、触发器等一般也将被删除
还是和上述删除模式情况一样，加了CASCADE和RESTRUCT删除不了

```sql
 DROP TABLE  Student  CASCADE ;
```


［例12］若表上建有视图，选择RESTRICT时表不能删除

```sql
CREATE VIEW IS_Student 
AS 
 SELECT Sno,Sname,Sage
 FROM  Student
	 WHERE Sdept='IS';
 DROP TABLE Student RESTRICT; 
```
![image-20220621174925844](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174925844.png)

---ERROR: cannot drop table Student because other objects depend on it

![image-20220621174959635](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621174959635.png)

[例12]如果选择CASCADE时可以删除表，视图也自动被删除

这里还是跟之前的情况一样，删除不了，可能是我用的数据库不同叭

```sql
DROP TABLE Student CASCADE; 	
--NOTICE: drop cascades to view IS_Student
	SELECT * FROM IS_Student;
--ERROR: relation " IS_Student " does not exist 
```

![image-20220621175042659](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621175042659.png)

#### （4）索引—INDEX

**索引**是关系数据库的内部实现技术，属于内模式的范畴。数据库索引包含的数据量比一次能调入内存的数据大，其数据是存放在磁盘上的，记录会永久存在。

**数据库索引的结构**：

- 由一系列存储在磁盘上的索引项组成
- 由两列组成：
  - 第一列是索引键，由行中某些（通常是一列）中的值串接而成
  - 第二列是行指针，只想数据行所在的磁盘存储位置

- 一个索引项对应于索引中的一行：当发生行更新的时候，索引也将做出响应；如果一行按某一列中的值访问，索引将提供这种访问

建立索引的**目的**：提高对表中行数据进行查找的效率，降低磁盘访问次数

**谁可以建立索引？**

- DBA 或表的属主（即建立表的人）
- DBMS一般会自动建立以下列上的索引
- PRIMARY KEY
- UNIQUE

**谁维护索引？**DBMS自动完成

使用索引：DBMS自动选择是否使用索引以及使用哪些索引

RDBMS中索引一般采用B+树、HASH索引来实现

- B+树索引具有动态平衡的优点
- HASH索引具有查找速度快的特点

采用B+树，还是HASH索引则由具体的RDBMS来决定

**索引分类：**

CREATE INDEX语句定义索引时，可以定义索引是唯一索引、非唯一索引或聚簇索引

- 唯一索引(UNIQUE):是指一个索引键对应一个数据行的索引
- 聚簇索引：是一种要求行的物理存储顺序与索引键顺序完全相同的索引。一张表只允许建立一个聚簇索引。
  - 优点：检索速度快
  - 缺点：建立索引时间长
- 非聚簇索引：包含一个索引值和一个指向数据行的指针，索引值是被索引列的键值。非聚簇索引不改变行的物理存储顺序。
  - 优点：建立索引速度快
  - 缺点：比聚簇索引占用的空间多

##### ①建立索引的标准格式

###### 语句格式

```sql
CREATE [UNIQUE][CLUSTER] INDEX <索引名> 
ON <表名>(<列名>[<次序>][,<列名>[<次序>]]…)；	
```


[例13]

```sql
 CREATE CLUSTERED	INDEX Stusname
 ON  Student(Sname);
```
![image-20220621175243500](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621175243500.png)

- 在Student表的Sname（姓名）列上建立一个聚簇索引
- 在最经常查询的列上建立聚簇索引以提高查询效率
- 一个基本表上最多只能建立一个聚簇索引
- 经常更新的列不宜建立聚簇索引

[例14]为学生-课程数据库中的Student，Course，SC三个表建立索引。

Student表按学号升序建唯一索引
Course表按课程号升序建唯一索引
SC表按学号升序和课程号降序建唯一索引

```sql
CREATE UNIQUE INDEX  Stusno ON Student(Sno);
CREATE UNIQUE INDEX  Coucno ON Course(Cno);
CREATE UNIQUE INDEX  SCno ON SC(Sno ASC,Cno DESC);
```

![image-20220621175331478](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621175331478.png)

##### ②删除索引

DROP INDEX <索引名> ON <表名>;
DROP INDEX <表名>.<索引名>;

删除索引时，系统会从数据字典中删去有关该索引的
描述。
[例15]删除Student表的Stusname索引

```sql
DROP INDEX Stusno ON Student;
//等价
DROP INDEX Student.Stusno;
```

![image-20220621175431890](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220621175431890.png)

## 3.2 数据查询—SELECT

（单表查询、连接查询、嵌套查询、集合查询、多表查询）

### 1.思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.2%20%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E2%80%94SELECT.jpg)

### 2.Student/SC/Course表数据及结构

本篇文章都是围绕这三个表展开的。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090322238.png" alt="image-20220624090322238" style="zoom:67%;"/>

### 3.SELECT语句的一般格式

先从整体上了解一下SELECT的格式，关键字的位置。

```sql
SELECT [ALL|DISTINCT]
<目标列表达式> [别名][ ，<目标列表达式> [别名]]…
FROM <表名或视图名> [别名][ ，<表名或视图名> [别名]]…
[WHERE <条件表达式>]
[GROUP  BY<列名1>
[HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]
```

### 4.单表查询

#### （1）选择表中的若干列

##### ①查询指定列

[例1]查询全体学生的学号与姓名。

```sql
SELECT Sno,Sname 
FROM Student;
```

[例2]查询全体学生的姓名、学号、所在系。

```sql
SELECT Sname,Sno,Sdept 
FROM Student;
```

##### ②查询全部列

选出所有属性列：在SELECT关键字后面列出所有列名，将<目标列表达式>指定为*
[例3]查询全体学生的详细记录。

```sql
SELECT  Sno,Sname,Ssex,Sage,Sdept 
FROM Student;
//两种方式
SELECT *FROM Student;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090548300.png" alt="image-20220624090548300" style="zoom:50%;"/>

##### ③查询经过计算的值

SELECT子句的<目标列表达式>可以为：

- 算术表达式
- 字符串常量
- 函数

- 列别名

###### ❶算术表达式

[例4]查全体学生的姓名及其出生年份。这里假定目前年份是2004年。

```sql
SELECT Sname,2004-Sage 
FROM Student;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090648565.png" alt="image-20220624090648565" style="zoom:50%;"/>

###### ❷字符串常量及函数

[例5]查询全体学生的姓名、出生年份和所有系，要求用小写字母表示所有系名，这里假定目前年份是2004年。

```sql
SELECT Sname,'Year of Birth: ',2004-Sage, LOWER(Sdept)
 FROM Student;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090723351.png" alt="image-20220624090723351" style="zoom:50%;"/>

###### ❸使用列别名改变查询结果的列标题

```sql
SELECT Sname NAME,'Year of Birth: ' BIRTH,
2000-Sage  BIRTHDAY,
LOWER(Sdept) DEPARTMENT
FROM Student;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090754065.png" alt="image-20220624090754065" style="zoom:50%;"/>

#### （2）选择表中的若干元组（行）

##### ①关键词DISTINCT去掉表中重复的行

如果没有指定DISTINCT关键词，则缺省为ALL

```sql
SELECT Sno FROM SC;
/*等价于：*/
SELECT ALL  Sno  FROM SC;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090834857.png" alt="image-20220624090834857" style="zoom:50%;"/>

[例6]查询选修了课程的学生学号。指定DISTINCT关键词，去掉表中重复的行

```sql
SELECT DISTINCT Sno
FROM SC;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624090901815.png" alt="image-20220624090901815" style="zoom:50%;"/>

##### ②查询满足条件的元组（行）

常用的查询条件

| 查询条件             | 谓词                                                |
| -------------------- | --------------------------------------------------- |
| 比较                 | =，>，<，>=，<=，!=，<>，!>，!<；NOT+上述比较运算符 |
| 确定范围             | BETWEEN AND，NOT BETWEEN AND                        |
| 确定集合             | IN，NOT IN                                          |
| 字符匹配             | LIKE，NOT LIKE                                      |
| 空值                 | IS NULL，IS NOT NULL                                |
| 多重条件（逻辑运算） | AND，OR，NOT                                        |

###### ❶比较大小

[例7]查询计算机科学系全体学生的名单。

```sql
SELECT Sname
FROM Student
WHERE Sdept='CS';
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091223275.png" alt="image-20220624091223275" style="zoom:50%;"/>

[例8]查询所有年龄在20岁以下的学生姓名及其年龄。

```sql
SELECT Sname,Sage 
FROM Student 
WHERE Sage < 20;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091245331.png" alt="image-20220624091245331" style="zoom:50%;"/>

[例9]查询考试成绩有不及格的学生的学号。

```sql
SELECT DISTINCT Sno
FROM  SC
WHERE Grade<60;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091312861.png" alt="image-20220624091312861" style="zoom:50%;"/>

###### ❷确定范围

谓词:

BETWEEN … AND …
NOT BETWEEN … AND …

[例10]查询年龄在20~23岁（包括20岁和23岁）之间的学生的

```sql
SELECT Sname,Sdept,Sage
FROM  Student
WHERE Sage 
BETWEEN 20 AND 23; 
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091347389.png" alt="image-20220624091347389" style="zoom:50%;"/>

[例11]查询年龄不在20~23岁之间的学生姓名、系别和年龄

```sql
SELECT Sname,Sdept,Sage
FROM  Student
WHERE Sage NOT BETWEEN 20 AND 23;
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091411103.png" alt="image-20220624091411103" style="zoom:50%;"/>

###### ❸确定集合

谓词：

IN <值表>,
NOT IN <值表>

[例12]查询信息系（IS）、数学系（MA）和计算机科学系（CS）学生的姓名和性别。

```sql
SELECT Sname,Ssex
FROM  Student
WHERE Sdept IN ('IS','MA','CS');
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091445529.png" alt="image-20220624091445529" style="zoom:50%;"/>

[例13]查询既不是信息系、数学系，也不是计算机科学系的学生的姓名和性别。

```sql
SELECT Sname,Ssex
FROM Student
WHERE Sdept NOT IN ('IS','MA','CS');
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091510854.png" alt="image-20220624091510854" style="zoom:50%;"/>

###### ❹字符匹配

谓词：

[NOT] LIKE ‘<匹配串>’[ESCAPE ‘<换码字符>’]
匹配串为固定字符串

[例14]查询学号为201215121的学生的详细情况。

```sql
SELECT *
FROM  Student 
WHERE  Sno LIKE '201215121';
/*等价于：*/
SELECT *
FROM  Student 
WHERE Sno = '201215121';
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624091542563.png" alt="image-20220624091542563" style="zoom: 50%;"/>

匹配串为含通配符的字符串

**%匹配任意多个字符**
[例15]查询所有姓刘学生的姓名、学号和性别。

```sql
SELECT Sname,Sno,Ssex
FROM Student
WHERE  Sname LIKE '刘%';
```

**_匹配任意单个字符**

[例16]查询姓"欧阳"且全名为三个汉字的学生的姓名。

```sql
SELECT Sname
FROM  Student
WHERE  Sname LIKE '欧阳_';
```

[例17]查询名字中第2个字为"阳"字的学生的姓名和学号。

```sql
SELECT Sname,Sno
FROM Student
WHERE Sname LIKE '_阳%';
```

[例18]查询所有不姓刘的学生姓名。

```sql
SELECT Sname,Sno,Ssex
FROM Student
WHERE Sname NOT LIKE '刘%';
```

###### ❺使用换码字符’'将通配符转义为普通字符

ESCAPE '＼'表示“＼”为换码字符

[例19]查询DB_Design课程的课程号和学分。

```sql
SELECT Cno,Ccredit
FROM Course
WHERE Cname LIKE 'DB\_Design' ESCAPE '\';
```

[例20]查询以"DB_"开头，且倒数第3个字符为 i的课程的详细情况。

```sql
SELECT *
FROM  Course
WHERE  Cname LIKE 'DB\_%i_ _' ESCAPE '\';
```

###### ❻涉及空值的查询

谓词：

IS NULL
IS NOT NULL
“IS”不能用“=”代替

[例21]某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号。

```sql
SELECT Sno,Cno
FROM  SC
WHERE  Grade IS NULL;
```


[例22]查所有有成绩的学生学号和课程号。

```sql
SELECT Sno,Cno
FROM  SC
WHERE  Grade IS NOT NULL;
```

###### ❼多重条件查询

**逻辑运算符：**

- AND和 OR来联结多个查询条件
- AND的优先级高于OR
- 可以用括号改变优先级

**可用来实现多种其他谓词**

- [NOT] IN
- [NOT] BETWEEN … AND …

[例23]查询计算机系年龄在20岁以下的学生姓名。

```sql
SELECT Sname
FROM  Student
WHERE Sdept= 'CS' AND Sage<20;
```


改写[例12]查询信息系（IS）、数学系（MA）和计算机科学系（CS）学生的姓名和性别。

```sql
SELECT Sname,Ssex
FROM Student
WHERE Sdept IN ('IS','MA','CS');
/*可改写为：*/
SELECT Sname,Ssex
FROM  Student
WHERE  Sdept= 'IS' OR Sdept= 'MA' OR Sdept= 'CS';
```

#### （3）ORDER BY子句

##### ORDER BY子句

可以按一个或多个属性列排序；
升序：ASC；
降序：DESC；
缺省值为升序；

##### 当排序列含空值时

ASC：排序列为空值的元组最后显示
DESC：排序列为空值的元组最先显示

[例24]查询选修了3号课程的学生的学号及其成绩，查询结果按分数降序排列。

```sql
SELECT Sno,Grade
FROM  SC
WHERE  Cno= '3'
ORDER BY Grade DESC;
```

[例25]查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。

```sql
SELECT *
FROM  Student
ORDER BY Sdept,Sage DESC;
```

#### （4）聚集函数（聚合函数）

**计数**：
COUNT（[DISTINCT|ALL]*）
COUNT（[DISTINCT|ALL]<列名>）

**总和：**
SUM（[DISTINCT|ALL]<列名>）

**平均值：**
AVG（[DISTINCT|ALL]<列名>）

**最大最小值：**
MAX（[DISTINCT|ALL]<列名>）
MIN（[DISTINCT|ALL]<列名>）

[例26]查询学生总人数。

```sql
SELECT COUNT(*)
FROM  Student;
```

[例27]查询选修了课程的学生人数。

```sql
SELECT COUNT(DISTINCT Sno)
FROM SC;
```

[例28]计算2号课程的学生平均成绩。

```sql
SELECT AVG(Grade)
FROM SC
WHERE Cno= '2';
```


[例29]查询选修2号课程的学生最高分数。

```sql
SELECT MAX(Grade)
FROM SC
WHERE Cno= '2';
```


[例30]查询学生201215121选修课程的总学分数。

```sql
SELECT SUM(Ccredit)
FROM  SC, Course
WHERE Sno='201215121' AND SC.Cno=Course.Cno;
```

#### （5）GROUP BY子句

GROUP BY子句分组：细化聚集函数的作用对象

- 未对查询结果分组，聚集函数将作用于整个查询结果
- 对查询结果分组后，聚集函数将分别作用于每个组
- 作用对象是查询的中间结果表
- 按指定的一列或多列值分组，值相等的为一组

HAVING短语与WHERE子句的区别：

- 作用对象不同
- WHERE子句作用于基表或视图，从中选择满足条件的元组
- HAVING短语作用于组，从中选择满足条件的组。

[例31]求各个课程号及相应的选课人数。

```sql
SELECT Cno,COUNT(Sno)
FROM  SC
GROUP BY Cno;
```


[例32]查询选修了2门以上课程的学生学号。

```sql
SELECT Sno
FROM  SC
GROUP BY Sno
HAVING  COUNT(*)>2;
```

### 5.连接查询

连接查询：同时涉及多个表的查询

连接条件或连接谓词：用来连接两个表的条件

一般格式：

- [<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2>
- [<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>

连接字段：连接谓词中的列名称。连接条件中的各连接字段类型必须是可比的，但名字不必是相同的

#### （1）连接操作的执行过程

##### ①嵌套循环法(NESTED-LOOP)

- 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。
- 表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。
- 重复上述操作，直到表1中的全部元组都处理完毕

##### ②排序合并法(SORT-MERGE)

常用于=连接

- 首先按连接属性对表1和表2排序
- 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续
- 找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续
- 重复上述操作，直到表1或表2中的全部元组都处理完毕为止

##### ③索引连接(INDEX-JOIN)

1. 对表2按连接字段建立索引
2. 对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组

#### （2）等值与非等值连接查询

**等值连接**：连接运算符为=

[例33]查询每个学生及其选修课程的情况

```sql
SELECT  Student.*,SC.*
FROM  Student,SC
WHERE  Student.Sno = SC.Sno;
```

**自然连接**

[例34]对[例33]用自然连接完成。

```sql
SELECT  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade
FROM  Student,SC
WHERE  Student.Sno = SC.Sno;
```

#### （3）自身连接

- 自身连接：一个表与其自己进行连接
- 需要给表起别名以示区别
- 由于所有属性名都是同名属性，因此必须使用别名前缀

[例35]查询每一门课的间接先修课（即先修课的先修课）

```sql
SELECT  FIRST.Cno,SECOND.Cpno
FROM  Course  FIRST,Course  SECOND
WHERE FIRST.Cpno = SECOND.Cno;
```

#### （4）连接JOIN

SQL join 用于把来自两个或多个表的行结合起来。
标准格式：

```sql
SELECT column_name(s)
FROM table1//左表
<xxx JOIN> table2//右表
ON table1.column_name=table2.column_name;
```


分类：

- INNER JOIN (JOIN)
- LEFT JOIN (LEFT OUTER JOIN)
- RIGHT JOIN (RIGHT OUTER JOIN)
- FULL JOIN (FULL OUTER JOIN)

这里就以SC和Course两个表来检验这四类连接

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624094105281.png" alt="image-20220624094105281" style="zoom:50%;"/>

##### ① INNER JOIN (JOIN)

INNER JOIN：关键字在表中存在至少一个匹配时返回行。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624094258078.png" alt="image-20220624094258078" style="zoom:33%;"/>

```sql
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC INNER JOIN Course ON (SC.Cno=Course.Cno);
/*INNER JOIN 与 JOIN结果相同*/
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC  JOIN Course ON (SC.Cno=Course.Cno);
```

##### ② LEFT JOIN (LEFT OUTER JOIN)

LEFT JOIN：关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624094326433.png" alt="image-20220624094326433" style="zoom:33%;"/>

```sql
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC LEFT JOIN Course ON (SC.Cno=Course.Cno);
/*LEFT JOIN 与 LEFT OUTER JOIN结果相同*/
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC LEFT OUTER JOIN Course ON (SC.Cno=Course.Cno);
```

##### ③ RIGHT JOIN (RIGHT OUTER JOIN)

RIGHT JOIN：关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624094341655.png" alt="image-20220624094341655" style="zoom:33%;"/>

```sql
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC RIGHT JOIN Course ON (SC.Cno=Course.Cno);
/*RIGHT JOIN 与 RIGHT OUTER JOIN结果相同*/
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC RIGHT OUTER JOIN Course ON (SC.Cno=Course.Cno);
```

##### ④ FULL JOIN (FULL OUTER JOIN)

FULL JOIN：关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。结合了 LEFT JOIN 和 RIGHT JOIN 的结果。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624094400499.png" alt="image-20220624094400499" style="zoom:33%;"/>

```sql
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC FULL JOIN Course ON (SC.Cno=Course.Cno);
/*FULL JOIN 与 FULL OUTER JOIN结果相同*/
SELECT Sno,SC.Cno,Grade,Course.Cno,Cname,Cpno,Ccredit
FROM  SC FULL OUTER JOIN Course ON (SC.Cno=Course.Cno);
```

#### （5）复合条件连接

复合条件连接：WHERE子句中含多个连接条件

[例37]查询选修2号课程且成绩在88分以上的所有学生

```sql
SELECT Student.Sno, Sname
FROM  Student,SC
WHERE Student.Sno = SC.Sno AND 
/*连接谓词*/
SC.Cno= '2' AND SC.Grade > 88; 
/*其他限定条件*/
```

[例38]查询每个学生的学号、姓名、选修的课程名及成绩

```sql
SELECT Student.Sno,Sname,Cname,Grade
FROM  Student,SC,Course /*多表连接*/
WHERE Student.Sno = SC.Sno 
and SC.Cno = Course.Cno;
```

### 6.嵌套查询

#### （1）嵌套查询概述

一个SELECT-FROM-WHERE语句称为一个查询块
将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询
一个例子：

```sql
SELECT Sname/*外层查询/父查询*/
 FROM Student
 WHERE Sno IN
(SELECT Sno /*内层查询/子查询*/
 FROM SC
 WHERE Cno= '2');
```

- 子查询的限制：·不能使用ORDER BY子句·
- 层层嵌套方式反映了 SQL语言的结构化
- 有些嵌套查询可以用连接运算替代

#### （2）不相关子查询

子查询的查询条件不依赖于父查询

- 由里向外逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。

#### （3）相关子查询

子查询的查询条件依赖于父查询

- 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表
- 然后再取外层表的下一个元组
- 重复这一过程，直至外层表全部检查完为止

#### （4）带有IN谓词的子查询

[例39]查询与“刘晨”在同一个系学习的学生。此查询要求可以分步来完成

①确定“刘晨”所在系名

```sql
SELECT  Sdept 
FROM  Student 
WHERE  Sname= '刘晨';
```

②查找所有在CS系学习的学生。

```sql
SELECT  Sno,Sname,Sdept 
FROM  Student 
WHERE  Sdept= 'CS';
```

将第一步查询嵌入到第二步查询的条件中

```sql
SELECT Sno,Sname,Sdept
FROM Student
WHERE Sdept  IN
(SELECT Sdept
FROM Student
WHERE Sname= '刘晨');
```


此查询为不相关子查询。
[例40]查询选修了课程名为“信息系统”的学生学号和姓名

```sql
SELECT Sno,Sname /*③最后在Student关系中取出Sno和Sname*/
FROM  Student 
WHERE Sno  IN
( SELECT Sno 	/*②然后在SC关系中找出选修了3号课程的学生学号*/
	 FROM  SC 
	 WHERE  Cno IN
		( SELECT Cno /*①首先在Course关系中找出“信息系统”的课程号,为3号*/
		 FROM Course 
		 WHERE Cname= '信息系统'
)
);
```


用连接查询实现[例40]

```sql
SELECT Student.Sno,Sname
FROM  Student,SC,Course
WHERE Student.Sno = SC.Sno 
AND SC.Cno = Course.Cno 
AND Course.Cname='信息系统';
```

#### （5）带有比较运算符的子查询

带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用>、<、=、>=、<= 、!=或< >等比较运算符。
与ANY或ALL谓词配合使用

例：假设一个学生只可能在一个系学习，并且必须属于一个系，则在[例39]可以用= 代替IN：

```sql
SELECT Sno,Sname,Sdept
FROM Student
WHERE Sdept =
(SELECT Sdept
FROM Student
WHERE Sname= '刘晨');
/*两种方式都可以*/
SELECT Sno,Sname,Sdept
FROM Student
WHERE
(SELECT Sdept
FROM Student
WHERE Sname= '刘晨')
= Sdept ;
```

［例41］找出每个学生超过他选修课程平均成绩的课程号。

```sql
SELECT Sno, Cno
FROM  SC  x
WHERE Grade >=(SELECT AVG(Grade)/*相关子查询*/
	 FROM  SC y
 WHERE y.Sno=x.Sno
						);
```


［例41］可能的执行过程：
1.从外层查询中取出SC的一个元组x，将元组x的Sno值（201215121）传送给内层查询。

```sql
SELECT AVG(Grade)
FROM SC y
WHERE y.Sno='201215121';
```


2.执行内层查询，得到值88（近似值），用该值代替内层查询，得到外层查询：

```sql
SELECT Sno, Cno
FROM  SC x
WHERE Grade >=88; 
```


3.执行这个查询，得到
（200215121，1）
（200215121，3）

4.外层查询取出下一个元组重复做上述1至3步骤，直到外层的SC元组全部处理完毕。结果为:

#### （6）带有ANY（SOME）或ALL谓词的子查询

谓词语义：

ANY：任意一个值
ALL：所有值
需要配合使用比较运算符:

|               |                                              |
| ------------- | -------------------------------------------- |
| \> ANY        | 大于子查询结果中的某个值                     |
| \> ALL        | 大于子查询结果中的所有值                     |
| < ANY         | 小于子查询结果中的某个值                     |
| < ALL         | 小于子查询结果中的所有值                     |
| \>= ANY       | 大于等于子查询结果中的某个值                 |
| \>= ALL       | 大于等于子查询结果中的所有值                 |
| <= ANY        | 小于等于子查询结果中的某个值                 |
| <= ALL        | 小于等于子查询结果中的所有值                 |
| = ANY         | 等于子查询结果中的某个值                     |
| =ALL          | 等于子查询结果中的所有值（通常没有实际意义） |
| !=（或<>）ANY | 不等于子查询结果中的某个值                   |
| !=（或<>）ALL | 不等于子查询结果中的任何一个值               |


[例42]查询其他系中比计算机科学某一学生年龄小的学生姓名和年龄

```sql
SELECT Sname,Sage
FROM  Student
WHERE Sage < ANY (SELECT  Sage
 FROM  Student
 WHERE Sdept= 'CS')
			 AND Sdept <> 'CS'; /*父查询块中的条件*/
```

**执行过程：**

关系数据库管理系统（Relational Database Management System：RDBMS）

1.RDBMS执行此查询时，首先处理子查询，找出 CS系中所有学生的年龄，构成一个集合(20，19)

2.处理父查询，找所有不是CS系且年龄小于20 或19的学生

**用聚集函数实现[例42]**

```sql
SELECT Sname,Sage
FROM  Student
WHERE Sage < (SELECT MAX(Sage)
 FROM Student
 WHERE Sdept= 'CS')
 AND Sdept <> 'CS';
```


[例43]查询其他系中比计算机科学系所有学生年龄都小的学生姓名及年龄。

**方法一：用ALL谓词**

```sql
SELECT Sname,Sage
FROM Student
WHERE Sage < ALL (SELECT Sage
 FROM Student
 WHERE Sdept= 'CS')
 AND Sdept <> 'CS';
```

**方法二：用聚集函数**

```sql
SELECT Sname,Sage
FROM Student
WHERE Sage < (SELECT MIN(Sage)
 FROM Student
 WHERE Sdept= 'CS')
 AND Sdept <> 'CS';
```

ANY（或SOME），ALL谓词与聚集函数、IN谓词的等价转换关系

|      | =    | <>或!= | <    | <=    | >     | >=     |
| ---- | ---- | ------ | ---- | ----- | ----- | ------ |
| ANY  | IN   | -      | <MAX | <=MAX | \>MIN | \>=MIN |
| ALL  | -    | NOT IN | <MIN | <=MIN | \>MAX | \>=MAX |

#### （7）带有EXISTS谓词的子查询

##### EXISTS谓词

存在量词∃
带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。

- 若内层查询结果非空，则外层的WHERE子句返回真值
- 若内层查询结果为空，则外层的WHERE子句返回假值

由EXISTS引出的子查询，其目标列表达式通常都用*，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义

##### NOT EXISTS谓词

若内层查询结果非空，则外层的WHERE子句返回假值
若内层查询结果为空，则外层的WHERE子句返回真值

[例44]查询所有选修了1号课程的学生姓名。

**思路分析：**

- 本查询涉及Student和SC关系
- 在Student中依次取每个元组的Sno值，用此值去检查SC关系
- 若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno=‘1’，则取此Student.Sname送入结果关系

1.用嵌套查询

```sql
SELECT Sname
FROM Student
WHERE EXISTS(SELECT *
 FROM SC
 WHERE Sno=Student.Sno 
			AND Cno= '1');
```


2.用连接运算

```sql
SELECT Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno 
AND SC.Cno= '1';
```


[例45]查询没有选修1号课程的学生姓名。

```sql
SELECT Sname
FROM Student
WHERE NOT EXISTS(SELECT *
 FROM SC
 WHERE Sno=Student.Sno 
			 AND Cno= '1');
```

**不同形式的查询间的替换**

一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换
所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换
用EXISTS/NOT EXISTS实现全称量词(难点)
SQL语言中没有全称量词∀（For all）
可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624100418985.png" alt="image-20220624100418985" style="zoom:50%;"/>

例：[例39]查询与“刘晨”在同一个系学习的学生。
可以用带EXISTS谓词的子查询替换：

```sql
SELECT Sno,Sname,Sdept
FROM Student S1
WHERE EXISTS(SELECT *
 FROM Student S2
 WHERE S2.Sdept = S1.Sdept
		 AND S2.Sname = '刘晨');
```


[例46]查询选修了全部课程的学生姓名。

```sql
SELECT Sname
FROM Student
WHERE NOT EXISTS(SELECT *
 FROM Course
 WHERE NOT EXISTS(SELECT *
 FROM SC
 WHERE Sno= Student.Sno
 AND Cno= Course.Cno)
);
```

**用EXISTS/NOT EXISTS实现逻辑蕴含(难点)**

SQL语言中没有蕴函(Implication)逻辑运算
可以利用谓词演算将逻辑蕴函谓词等价转换为：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624100535451.png" alt="image-20220624100535451" style="zoom:50%;"/>

[例47]查询至少选修了学生201215122选修的全部课程的学生号码。
解题思路：
用逻辑蕴函表达：查询学号为x的学生，对所有的课程y，只要201215122学生选修了课程y，则x也选修了y。
形式化表示：
用P表示谓词“学生201215122选修了课程y”
用q表示谓词“学生x选修了课程y”

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220624100606281.png" alt="image-20220624100606281" style="zoom:50%;"/>

**用NOT EXISTS谓词表示：**

```sql
SELECT DISTINCT Sno
FROM SC SCX
WHERE NOT EXISTS(SELECT *
 FROM SC SCY
 WHERE SCY.Sno = '201215122'
			 AND NOT EXISTS(SELECT *
 FROM SC SCZ
 WHERE SCZ.Sno=SCX.Sno 
						AND SCZ.Cno=SCY.Cno
							)
				);
```

### 7.集合查询

#### （1）集合操作的种类

并操作UNION
交操作INTERSECT
差操作EXCEPT
参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同

#### （2）集合操作举例

[例48]查询计算机科学系的学生及年龄不大于19岁的学生。
**方法一：**

```sql
SELECT *
FROM Student
WHERE Sdept= 'CS'
UNION SELECT *
 FROM Student
 WHERE Sage<=19;
```

UNION：将多个查询结果合并起来时，系统自动去掉重复元组。
UNION ALL：将多个查询结果合并起来时，保留重复元组
**方法二：**

```sql
SELECT  DISTINCT *
FROM Student
WHERE Sdept= 'CS'
OR  Sage<=19;
```


[例49]查询选修了课程1或者选修了课程2的学生。

```sql
SELECT Sno
FROM SC
WHERE Cno='1'
UNION
SELECT Sno
FROM SC
WHERE Cno= '2';
```


[例50]查询计算机科学系的学生与年龄不大于19岁的学生的交集

```sql
SELECT *
FROM Student
WHERE Sdept='CS'
INTERSECT
SELECT *
FROM Student
WHERE Sage<=19;
```


[例50]实际上就是查询计算机科学系中年龄不大于19岁的学生

```sql
SELECT *
FROM Student
WHERE Sdept= 'CS'
AND  Sage<=19;
```


[例51]查询选修课程1的学生集合与选修课程2的学生集合的交集

```sql
SELECT Sno
FROM SC
WHERE Cno='1'
INTERSECT
SELECT Sno
FROM SC
WHERE Cno='2';
```


[例51]实际上是查询既选修了课程1又选修了课程2 的学生

```sql
SELECT Sno
FROM SC
WHERE Cno='1' AND Sno IN
(SELECT Sno
FROM SC
WHERE Cno='2');
```


[例52]查询计算机科学系的学生与年龄不大于19岁的学生的差集。

```sql
SELECT *
FROM Student
WHERE Sdept='CS'
EXCEPT
SELECT *
FROM Student
WHERE Sage <=19;
```

[例52]实际上是查询计算机科学系中年龄大于19岁的学生

```sql
SELECT *
FROM Student
WHERE Sdept= 'CS'
AND  Sage>19;
```



## 3.3 基本表更新

（INSERT、UPDATE、ALTER、DELETE）与视图VIEW（定义、查询、更新）

### 1.思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.3%20%E5%9F%BA%E6%9C%AC%E8%A1%A8%E6%9B%B4%E6%96%B0.jpg)

### 2.基本表更新—TABLE

#### （1）插入数据—INSERT INTO

##### 两种插入数据方式

1. 插入元组
2. 插入子查询结果

可以一次插入多个元组

##### ①插入元组

###### 语句格式

```sql
INSERT
INTO <表名> [(<属性列1>[，<属性列2 >…)]
VALUES (<常量1> [，<常量2>]…)
```
功能:将新元组插入指定表中

###### INTO子句

- 属性列的顺序可与表定义中的顺序不一致
- 没有指定属性列
- 指定部分属性列

###### VALUES子句

- 提供的值必须与INTO子句匹配
- 值的个数
- 值的类型

[例1］将一个新学生元组（学号：200215128；姓名：陈冬；性别：男；所在系：IS；年龄：18岁）插入到Student表中。

```sql
INSERT INTO  Student (Sno，Sname，Ssex，Sdept，Sage)
VALUES ('200215128'，'陈冬'，'男'，'IS'，18)；
```
[例2］将学生张成民的信息插入到Student表中。

```sql
INSERT INTO  Student
VALUES ('200215126','张成民','男',18,'CS'); 
```


［例3］插入一条选课记录(‘200215128’，'1')。

```sql
INSERT INTO SC(Sno,Cno)//RDBMS将在新插入记录的Grade列上自动地赋空值
VALUES ('200215128','1');
//等价于
INSERT
INTO SC
VALUES ('200215128','1',NULL);
```

##### ②插入子查询结果

###### 语句格式

```sql
INSERT 
INTO <表名> [(<属性列1> [，<属性列2>…)]
子查询；
```
###### 功能

将子查询结果插入指定表中

INTO子句(与插入元组类似)

###### 子查询

- SELECT子句目标列必须与INTO子句匹配
- 值的个数
- 值的类型

[例4]对每一个系，求学生的平均年龄，并把结果存入数据库。

第一步：建表

```sql
CREATE  TABLE  Dept_age(
Sdept  CHAR(15),/*系名*/
Avg_age SMALLINT		/*学生平均年龄*/
); 
```

第二步：插入数据

```sql
INSERT INTO  Dept_age(Sdept,Avg_age)
SELECT  Sdept,AVG(Sage)
FROM  Student
GROUP BY Sdept;
```

**RDBMS在执行插入语句时会检查所插元组是否破坏表上已定义的完整性规则**

- 实体完整性
- 参照完整性
- 用户定义的完整性
- NOT NULL约束
- UNIQUE约束
- 值域约束

#### （2）修改数据—UPDATE SET

##### 语句格式

```sql
UPDATE <表名>
SET <列名>=<表达式>[，<列名>=<表达式>]…
[WHERE <条件>];
```

##### 功能

修改指定表中满足WHERE子句条件的元组

##### SET子句

- 指定修改方式
- 要修改的列
- 修改后取值

##### WHERE子句

- 指定要修改的元组

- 缺省表示要修改表中的所有元组

##### 三种修改方式

1. 修改某一个元组的值
2. 修改多个元组的值
3. 带子查询的修改语句

##### ①修改某一个元组的值

[例5]将学生201215121的年龄改为22岁

```sql
UPDATE  Student
SET Sage=22
WHERE  Sno='201215121'; 
```

[例6]将所有学生的年龄增加1岁

```sql
UPDATE Student
SET Sage= Sage+1;
```

[例7]将计算机科学系全体学生的成绩置零。

```sql
UPDATE SC
SET  Grade=0
WHERE 'CS'=(
				SELECT  Sdept
				FROM  Student
				WHERE  Student.Sno = SC.Sno
			);
```

**RDBMS在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则**

- 实体完整性
- 主键不允许修改
- 用户定义的完整性
- NOT NULL约束
- UNIQUE约束
- 值域约束

#### （3）删除数据—DELETE

##### 三种删除方式

1. 删除某一个元组的值
2. 删除多个元组的值
3. 带子查询的删除语句

##### ①删除某一个元组的值

```sql
DELETE
FROM Student
WHERE Sno= '200215128';
```

##### ②删除多个元组的值

[例9]删除所有的学生选课记录。

```sql
 DELETE
 FROM SC；
```
##### ③带子查询的删除语句

[例10]删除计算机科学系所有学生的选课记录。

```sql
DELETE
FROM SC
WHERE 'CS'=(
				SELECT Sdept
				FROM Student
				WHERE Student.Sno=SC.Sno
			);
```

### 3.视图—VIEW

#### 视图的作用：

1. 视图能够简化用户的操作
2. 视图使用户能以多种角度看待同一数据
3. 视图对重构数据库提供了一定程度的逻辑独立性
4. 视图能够对机密数据提供安全保护
5. 适当的利用视图可以更清晰的表达查询

#### 视图的特点

- 虚表，是从一个或几个基本表（或视图）导出的表
- 只存放视图的定义，不存放视图对应的数据
- 基表中的数据发生变化，从视图中查询出的数据也随之改变

#### 基于视图的操作

查询，删除，受限更新，定义基于该视图的新视图

> 视图的UPDATE、DELETE、INSERT INTO(有受限)，与基本表同步。

#### （1）定义视图

##### ①建立视图

###### 语句格式

```sql
CREATE  VIEW <视图名> [(<列名> [，<列名>]…)]
AS <子查询>
[WITH  CHECK  OPTION]；
```

- 组成视图的属性列名：全部省略或全部指定

- **子查询不允许含有ORDER BY子句和DISTINCT短语**


- RDBMS执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句。


- 在对视图查询时，按视图的定义从基本表中将数据查出。
- WITH  CHECK  OPTION使用要求：要求创建的视图是可更新视图，其次，如果在视图上执行的INSERT或UPDATE操作会导致在基础表上更新了数据但在视图上找不到更新数据的情况，那么这些INSERT或UPDATE操作将不允许被执行。


[例1]建立信息系IS学生的视图。

```sql
CREATE VIEW IS_Student
AS 
SELECT Sno,Sname,Sage
FROM  Student
WHERE  Sdept= 'IS';
```

[例2]建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系IS的学生。
对IS_Student视图的更新操作：

1. 修改操作：自动加上Sdept= 'IS’的条件
2. 删除操作：自动加上Sdept= 'IS’的条件
3. 插入操作：自动检查Sdept属性值是否为’IS’
   - 如果不是，则拒绝该插入操作
   - 如果没有提供Sdept属性值，则自动定义Sdept为’IS’

```sql
CREATE VIEW IS_Student
AS 
SELECT Sno,Sname,Sage
FROM  Student
WHERE  Sdept= 'IS'
WITH CHECK OPTION;
```

###### 基于多个基表的视图

[例3]建立信息系选修了1号课程的学生视图。

```sql
CREATE VIEW IS_S1(Sno,Sname,Grade)
AS 
SELECT Student.Sno,Sname,Grade
FROM  Student,SC
WHERE  Sdept= 'IS'
AND Student.Sno=SC.Sno 
AND SC.Cno= '1';
```

###### 基于视图的视图

[例4]建立信息系选修了1号课程且成绩在90分以上的学生的视图。

```sql
CREATE VIEW IS_S2
AS
SELECT Sno,Sname,Grade
FROM  IS_S1
WHERE  Grade>=90;
```

###### 带表达式的视图

[例5]定义一个反映学生出生年份的视图。

```sql
CREATE  VIEW BT_S(Sno,Sname,Sbirth)
AS 
SELECT Sno,Sname,2000-Sage
FROM  Student;
```

###### 分组视图

[例6]将学生的学号及他的平均成绩定义为一个视图

```sql
CREATE  VIEW S_G(Sno,Gavg)
AS 
SELECT Sno,AVG(Grade)
FROM  SC
GROUP BY Sno;
```

###### 不指定属性列

[例7]将Student表中所有女生记录定义为一个视图

```sql
CREATE VIEW F_Student(F_Sno,name,sex,age,dept)
AS
SELECT *
FROM  Student
WHERE Ssex='女';
```

###### 缺点：

修改基表Student的结构后，Student表与F_Student视图的映象关系被破坏，导致该视图不能正确工作。

##### ②删除视图

###### 语句格式

DROP VIEW <视图名>;

- 该语句从数据字典中删除指定的视图定义
- 如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除
- 删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除

[例8］删除视图IS_S1

```sql
DROP VIEW IS_S1;
```

关于级联删除CASCADE，不知道为什么，删除模式、删除表、删除视图，有约束却删除不了，有待解决，先放这里。

#### （2）查询视图

**用户角度**：查询视图与查询基本表相同

**RDBMS实现视图查询的方法**

##### 视图消解法（View Resolution）:

- 进行有效性检查
- 转换成等价的对基本表的查询
- 执行修正后的查询

关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为**视图消解(view resolution)**。

[例9]在信息系学生的视图中找出年龄小于等于20岁的学生。

```sql
SELECT  Sno,Sage
FROM  IS_Student
WHERE  Sage<=20;
```


视图消解转换后的查询语句为：

```sql
SELECT  Sno，Sage 
 FROM  Student
 WHERE  Sdept= 'IS' AND  Sage<=20；
```

[例10]查询选修了1号课程的信息系学生

```sql
SELECT  IS_Student.Sno,Sname
FROM  IS_Student,SC
WHERE  IS_Student.Sno =SC.Sno AND SC.Cno= '1';
```

**视图消解法的局限**：有些情况下，视图消解法不能生成正确查询。
[例11]在S_G视图中查询平均成绩在90分以上的学生学号和平均成绩

```sql
SELECT *
FROM  S_G
WHERE  Gavg>=90;
```


S_G视图的子查询定义：

```sql
CREATE VIEW S_G (Sno,Gavg)
AS 
SELECT  Sno,AVG(Grade)
FROM  SC
GROUP BY Sno;
```

```sql
错误：
SELECT Sno,AVG(Grade)
FROM  SC
WHERE  AVG(Grade)>=90
GROUP BY Sno;

正确：
SELECT  Sno,AVG(Grade)
FROM  SC
GROUP BY Sno
HAVING AVG(Grade)>=90;
```

#### （3）更新视图

##### ①更新数据—UPDATE SET

[例12]将信息系学生视图IS_Student中学号201215125的学生姓名改为“刘辰”。

```sql
UPDATE  IS_Student
SET  Sname= '刘辰'
WHERE  Sno= '201215125';
转换后的语句：		//基本表和视图表同步更新
UPDATE  Student
SET Sname= '刘辰'
WHERE Sno= '201215125'
AND Sdept= 'IS'; 
```

##### ②插入数据—INSERT INTO

[例13]向信息系学生视图IS_Student中插入一个新的学生记录：200215111，赵新，20岁

视图IS_Student的定义

```sql
CREATE VIEW IS_Student
AS 
SELECT Sno,Sname,Sage
FROM  Student
WHERE  Sdept= 'IS';
//如果加了WITH CHECK OPTION，则视图不能进行插入数据操作
CREATE VIEW IS_Student
AS 
SELECT Sno,Sname,Sage
FROM  Student
WHERE  Sdept= 'IS'
WITH CHECK OPTION;

//插入数据
INSERT
INTO IS_Student
VALUES('200215111','赵新',20);
//插入后基本表Student字段Sdept为空，视图表IS_Student无数据
转换为对基本表的更新：
INSERT
INTO  Student(Sno,Sname,Sage,Sdept)
VALUES('200215129','赵新2',20,'IS');
```

##### ③删除数据—DELETE

[例14]删除信息系学生视图IS_Student中学号为200215129的记录

```sql
DELETE
FROM IS_Student
WHERE Sno= '200215129';
转换为对基本表的更新：
DELETE
FROM Student
WHERE Sno= '200215129' AND Sdept= 'IS';
```

##### ④更新视图的限制

**更新视图的限制**：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新
例：视图S_G为不可更新视图。

[例6]将学生的学号及他的平均成绩定义为一个视图

```sql
CREATE VIEW S_G(Sno,Gavg)
AS
SELECT Sno,AVG(Grade)
FROM SC
GROUP BY Sno
```

```sql
UPDATE  S_G
SET  Gavg=90
WHERE  Sno= '200215121';
```


这个对视图的更新无法转换成对基本表SC的更新

- 允许对行列子集视图进行更新


- 对其他类型视图的更新不同系统有不同限制






# 第4 章数据库安全性

## 4.1 数据库安全性详解

（存取控制、DAC&MAC、视图机制、审计Audit…）

### 思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/4.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E8%AF%A6%E8%A7%A3%E2%80%94.jpg)

### 1.数据库安全性概述

#### （1）为什么要研究数据库的安全性？

##### 问题的提出：

- 数据库的一大特点是数据可以共享
- 数据共享必然带来数据库的安全性问题
- 数据库系统中的数据共享不能是无条件的共享
- 例：军事秘密、国家机密、新产品实验数据、市场需求分析、市场营销策略、销售计划、客户档案、医疗档案、银行储蓄数据

##### 非法使用数据库的情况：

编写合法程序绕过DBMS及其授权机制（黑客等）
直接或编写应用程序执行非授权操作（黑客等）
通过多次合法查询数据库从中推导出一些保密数据（黑客等）

#### （2）安全标准简介

信息安全标准发展史

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625150610742.png" alt="image-20220625150610742" style="zoom:67%;"/>

##### ① TCSEC/TDI标准的基本内容

TCSEC/TDI，从四个方面来描述安全性级别划分的指标：

1. 安全策略
2. 责任
3. 保证
4. 文档

##### ② TCSEC/TDI安全级别划分

- 按系统可靠或可信程度逐渐增高

- 各安全级别之间：偏序向下兼容


<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625150752031.png" alt="image-20220625150752031" style="zoom:50%;"/>

###### B2以上的系统：

- 还处于理论研究阶段
- 应用多限于一些特殊的部门，如军队等
- 美国正在大力发展安全产品，试图将目前仅限于少数领域应用的B2安全级别下放到商业应用中来，并逐步成为新的商业标准

### 2.数据库安全性控制概述

计算机系统中，安全措施是一级一级层层设置的，以下为计算机系统的安全模型：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625150955936.png" alt="image-20220625150955936" style="zoom:50%;"/>

用户要求进入计算机系统时，系统首先根据输入的用户标识进行用户身份鉴定，只有合法的用户才准许进入计算机系统;对已进入系统的用户，数据库管理系统还要进行存取控制，只允许用户执行合法操作;操作系统也会有自己的保护措施;数据最后还可以以密码形式存储到数据库中（例如md5加密密码等信息）。

![image-20220625151021718](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625151021718.png)

#### 数据库安全性控制的常用方法：

1. 用户标识和鉴定
2. 存取控制
3. 视图
4. 审计
5. 密码存储

### 3.数据库安全性控制

#### （1）用户标识与鉴别（Identification & Authentication）

- 是系统提供的最外层安全保护措施
- 用户标识：每个用户标识由用户名(user name)和用户标识号(UID)两部分组成。UID在系统的整个生命周期内是唯–的。系统内部记录着所有合法用户的标识
- 口令：系统核对口令以鉴别用户身份（口令可理解为密码）
- 用户标识和口令易被窃取，每个用户预先约定好一个计算过程或者函数

**常用的用户身份鉴别方法有以下几种：**

###### ①静态口令鉴别

- 这种方式是当前常用的鉴别方法。
- **静态口令一般由用户自己设定，鉴别时只要按要求输入正确的口令，系统将允许用户使用数据库管理系统。**
- 这些口令是静态不变的，在实际应用中，用户常常用自己的生日、电话、简单易记的数字等内容作为口令，很容易被破解。而一旦被破解，非法用户就可以冒充该用户使用数据库。
- **这种方式虽然简单，但容易被攻击，安全性较低。**

###### ②动态口令鉴别

- 它是目前较为安全的鉴别方式。
- 这种方式的口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法。
- **常用的方式如短信密码和动态令牌方式，每次鉴别时要求用户使用通过短信或令牌等途径获取的新口令登录数据库管理系统。**
- 与静态口令鉴别相比，这种认证方式增加了口令被窃取或破解的难度，安全性相对高一些。

###### ③生物特征鉴别

它是一种通过生物特征进行认证的技术，其中，生物特征是指生物体唯一具有的，可测量、识别和验证的稳定生物特征，如指纹、虹膜和掌纹等。
这种方式通过采用图像处理和模式识别等技术实现了基于生物特征的认证，-与传统的口令鉴别相比，无疑产生了质的飞跃，安全性较高。

###### ④智能卡鉴别

智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能。
智能卡由用户随身携带，登录数据库管理系统时用户将智能卡插入专用的读卡器进行身份验证。
由于每次从智能卡中读取的数据是静态的，通过内存扫描或网络监听等技术还是可能截取到用户的身份验证信息，存在安全隐患。
因此，实际应用中一般采用个人身份识别码(PIN)和智能卡相结合的方式。这样，即使PIN或智能卡中有一种被窃取，用户身份仍不会被冒充。

#### （2）存取控制

数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。

##### ①存取控制机制组成:

**定义用户权限**,并将用户权限登记到数据字典中；用户对某一数据对象的操作权力称为权限。

**合法权限检查**,每当用户发出存取数据库的操作请求后(请求一般应包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找数据字典，根据安全规则进行合法权限检查，若用户的操作请求超出了定义的权限，系统将拒绝执行此操作。

**定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。**

- C2级的数据库管理系统支持自主存取控制( Discretionary Access Control, DAC),
- B1级的数据库管理系统支持强制存取控制( Mandatory Access Control, MAC)。

**这两类方法的简单定义是:**

(1)在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。
(2)在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。强制存取控制因此相对比较严格。

#### (3）自动存取控制方法—DAC: Discretionary Access Control

- 通过 SQL 的 GRANT语句和 REVOKE语句实现
- 用户权限组成：数据对象，操作类型
- 定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作
- 定义存取权限称为**授权**

关系数据库系统中存取控制对象

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625151705871.png" alt="image-20220625151705871" style="zoom: 50%;"/>

##### ①授权与回收—针对用户

###### 1️⃣授权—GRANT

```sql
GRANT语句的一般格式：
 GRANT <权限>[,<权限>]...
[ON <对象类型> <对象名>]
 TO <用户>[,<用户>]...
[WITH GRANT OPTION];
```

语义：将对指定操作对象的指定操作权限授予指定的用户

- WITH GRANT OPTION使用：允许对这张表有访问权限的用户授予其它用户同样的权限
- 一个用户创建表或者视图后就自动是表或视图的所有者，自动拥有表或视图的所有权限，而且不能被撤销。

**发出GRANT：**

- DBA
- 数据库对象创建者（即属主Owner）
- 拥有该权限的用户

**按受权限的用户:**

- 一个或多个具体用户
- PUBLIC（全体用户）

**WITH GRANT OPTION子句:**

- 指定：可以再授予
- 没有指定：不能传播

**不允许循环授权：**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625151835148.png" alt="image-20220625151835148" style="zoom: 33%;"/>

[例1]把查询Student表权限授给用户U1

```sql
 GRANT  SELECT 
 ON  TABLE  Student
 TO  U1;
```
<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625151936907.png" alt="image-20220625151936907" style="zoom:67%;"/>

[例2]把对Student表和Course表的全部权限授予用户U2和U3

```sql
 GRANT ALL PRIVILIGES 
 ON TABLE Student, Course 
 TO U2, U3;
```
[例3]把对表SC的查询权限授予所有用户

```sql
 GRANT SELECT 
 ON TABLE SC 
 TO PUBLIC;
```
[例4]把查询Student表和修改学生学号的权限授给用户U4

对属性列的授权时必须明确指出相应属性列名

```sql
GRANT UPDATE(Sno), SELECT 
ON TABLE Student 
TO U4;
```

[例5]把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户

```sql
GRANT INSERT 
ON TABLE SC 
TO U5
WITH GRANT OPTION;
```

执行例5后，U5不仅拥有了对表SC的INSERT权限，
还可以传播此权限：
[例6]

```sql
GRANT INSERT ON TABLE SC TO U6
WITH GRANT OPTION;
```

同样，U6还可以将此权限授予U7：

[例7]
GRANT INSERT ON TABLE SC TO U7;
但U7不能再传播此权限,因为没有写这条语句WITH GRANT OPTION。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625152215170.png" alt="image-20220625152215170" style="zoom: 50%;"/>

###### 2️⃣回收—REVOKE

授予的权限可以由DBA或其他授权者用REVOKE语句收回
REVOKE语句的一般格式为：

```sql
 REVOKE <权限>[,<权限>]...
[ON <对象类型> <对象名>]
 FROM <用户>[,<用户>]...;
```
[例8]把用户U4修改学生学号的权限收回

```sql
	REVOKE UPDATE(Sno)
	ON TABLE Student 
	FROM U4;
```
[例9]收回所有用户对表SC的查询权限

```sql
	REVOKE SELECT 
	ON TABLE SC 
	FROM PUBLIC;
```
[例10]把用户U5对SC表的INSERT权限收回

```sql
	REVOKE INSERT 
	ON TABLE SC 
	FROM U5 CASCADE ;
```
将用户U5的INSERT权限收回的时候必须级联（CASCADE）收回系统只收回直接或间接从U5处获得的权限

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625152333838.png" alt="image-20220625152333838" style="zoom:50%;"/>

###### 3️⃣小结:SQL灵活的授权机制

DBA：拥有所有对象的所有权限，不同的权限授予不同的用户

用户：拥有自己建立的对象的全部的操作权限
GRANT：授予其他用户

被授权的用户。“继续授权”（WITH GRANT OPTION）许可：可以再授予给其它用户

所有授予出去的权力在必要时又都可用REVOKE语句收回

###### 4️⃣创建数据库模式的权限

**DBA在创建用户时实现**

```sql
CREATE USER语句格式
 CREATE  USER <username> 
［WITH］［DBA | RESOURCE | CONNECT］
```

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625152624172.png" alt="image-20220625152624172" style="zoom:67%;"/>

##### ②数据库角色—针对角色

数据库角色：被命名的一组与数据库操作相关的权限

- 角色是权限的集合，结合我刚刚上面截得黑色背景图片了解
- 可以为一组具有相同权限的用户创建一个角色
- 简化授权的过程

###### 1️⃣角色的创建

CREATE ROLE <角色名>

###### 2️⃣给角色授权

```sql
GRANT <权限>［，<权限>］…
 ON <对象类型>对象名
 TO <角色>［，<角色>］…
```

###### 3️⃣将一个角色授予其他的角色或用户

```sql
GRANT <角色1>［，<角色2>］…
TO <角色3>［，<用户1>］…
［WITH ADMIN OPTION］
```

###### 4️⃣角色权限的收回

```sql
REVOKE <权限>［，<权限>］…
ON <对象类型> <对象名>
FROM <角色>［，<角色>］…
```

[例11]　通过角色来实现将一组权限授予一个用户。
步骤如下：

1.首先创建一个角色 R1：CREATE ROLE R1；

2.然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限

```sql
GRANT SELECT，UPDATE，INSERT 
ON TABLE Student 
TO R1；
```

3.将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限

```sql
GRANT  R1 
TO 王平，张明，赵玲；
```

4.可以一次性通过R1来回收王平的这3个权限

```sql
REVOKE  R1 
FROM 王平；
```

[例12]　角色的权限修改

```sql
 GRANT DELETE 
 ON TABLE Student
 TO R1
```
[例13]　角色权限的收回

```sql
REVOKE SELECT 
ON TABLE Student
FROM  R1；
```
#### （4）强制存取控制方法—MAC: Mandatory Access Control

**自主存取控制缺点:**

1. 可能存在数据的“无意泄露”
2. 原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记
3. 解决：对系统控制下的所有主客体实施强制存取控制策略

**强制存取控制（MAC):**

- 保证更高程度的安全性
- 用户能不能直接感知或进行控制,因为对数据进行了加密
- 适用于对数据有严格而固定密级分类的部门：军事部门，政府部门

**在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。**

- **主体**是系统中的活动实体，DBMS所管理的实际用户，代表用户的各进程

- **客体**是系统中的被动实体，是受主体操纵的：文件，基表，索引，视图

**对于主体和客体，数据库管理系统为它们每个实例(值)指派一个敏感度标记(label)。**
**敏感度标记（Label）分为若干个级别：**

- 绝密（Top Secret）
- 机密（Secret）
- 可信（Confidential）
- 公开（Public）
- 主体的敏感度标记称为许可证级别（Clearance Level）
- 客体的敏感度标记称为密级（Classification Level）
- 密级：T>=S>=C>=P

**强制存取控制规则：**

(1)仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体
(2)仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体
修正规则：主体的许可证级别<=客体的密级→主体能写客体

**规则的共同点:**

禁止了拥有高许可证级别的主体更新低密级的数据对象

#### （5）DAC与MAC共同构成DBMS的安全机制

实现MAC时要首先实现DAC。原因：较高安全性级别提供的安全保护要包含较低级别的所有保护
先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有通过MAC检查的数据对象方可存取。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625153347620.png" alt="image-20220625153347620" style="zoom:50%;"/>

### 4.视图机制

**把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护**

- 主要功能是提供数据独立性，无法完全满足要求
- 间接实现了支持存取谓词的用户权限定义

[例14]建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明

先建立计算机系学生的视图CS_Student

```sql
 CREATE VIEW CS_Student AS 
 SELECT *
 FROM  Student
 WHERE  Sdept='CS'；
```

在视图上进一步定义存取权限：

```sql
 GRANT  SELECT
 ON  CS_Student 
 TO 王平；

 GRANT ALL PRIVILIGES
 ON  CS_Student 
 TO 张明；
```
### 5.审计（Audit）—日志

#### 什么是审计：

- 审计日志（Audit Log）：将用户对数据库的所有操作记录在上面
- DBA利用审计日志找出非法存取数据的人、时间和内容
- C2以上安全级别的DBMS必须具有

#### 审计分为:

##### 1.用户级审计

针对自己创建的数据库表或视图进行审计;
记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作

##### 2.系统级审计

DBA设置;
监测成功或失败的登录要求;
监测GRANT和REVOKE操作以及其他数据库级权限下的操作;

AUDIT语句：设置审计功能

NOAUDIT语句：取消审计功能

［例15］对修改SC表结构或修改SC表数据的操作进行审计

```sql
AUDIT ALTER，UPDATE 
ON  SC；
```
[例16］取消对SC表的一切审计

```sql
NOAUDIT  ALTER，UPDATE 
ON  SC；
```
### 6.数据加密

数据加密：防止数据库中数据在存储和传输中失密的有效手段

数据加密分为存储加密和传输加密

#### （1）存储加密

对于存储加密，一般提供透明和非透明两种存储加密方式。

- 透明存储加密是内核级加密保护方式，对用户完全透明
- 非透明存储加密则是通过多个加密函数实现的。

**透明存储加密**是数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密。由于数据加密对用户透明，数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可。当对加密数据进行增、删、改、查询操作时，数据库管理系统将自动对数据进行加、解密工作。基于数据库内核的数据存储加密、解密方法性能较好，安全完备性较高。

#### （2）传输加密

在客户/服务器结构中，数据库用户与服务器之间若采用明文方式传输数据，容易被网络恶意用户截获或篡改，存在安全隐患。因此，为保证二者之间的安全数据交换，数据库管理系统提供了传输加密功能。
常用的传输加密方式如**链路加密和端到端加密**。

##### ①链路加密

链路加密对传输数据在链路层进行加密，它的传输信息由报头和报文两部分组成，前者是路由选择信息，而后者是传送的数据信息。这种方式对报文和报头均加密。

##### ②端到端加密

端到端加密对传输数据在发送端加密，接收端解密。它只加密报文，不加密报头。与链路加密相比，它只在发送端和接收端需要密码设备，而中间节点不需要密码设备，因此它所需密码设备数量相对较少。但这种方式不加密报头，从而容易被非法监听者发现并从中获取敏感信息。

### 7.统计数据库安全性

###### 1.统计数据库

允许用户查询聚集类型的信息（如合计、平均值等）
不允许查询单个记录信息

###### 2.统计数据库中特殊的安全性问题:

隐蔽的信息通道
能从合法的查询中推导出不合法的信息

###### 3.统计数据库安全性规则：

规则1：任何查询至少要涉及N(N足够大)个以上的记录

规则2：任意两个查询的相交数据项不能超过M个

规则3：任一用户的查询次数不能超过1+(N-2)/M

> 数据库安全机制的设计目标：试图破坏安全的人所花费的代价>> 得到的利益



# 第5 章数据库完整性

## 5.1 数据库完整性详解

（PRIMARY KEY、REFERENCES、CHECK、CONSTRAINT、DOMAIN、TRIGGER）

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E8%AF%A6%E8%A7%A3.jpg)

### 1.数据库完整性概述

#### 简单介绍：

首先先概述一下数据库完整性指的是什么，数据库完整性指的是数据的正确性和相容性。
**数据的正确性**是指数据是符合现实世界语义、反映当前实际状况的;比如说人类的性别，只能是男和女。
数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的。比如说年龄一般都在1-100岁，当然也有超过一百岁的，反正没有两百岁，三百岁成仙的人类。

**既然我们学的是数据库，那么数据库管理系统就应该为数据完整性实现如下的功能：**

1.提供定义完整性约束条件的机制

- 完整约束条件也称完整性规则，是数据库中数据必须满足的语义条件规则
- 为保证数据的正确、有效和相容性的一些规则
- 数据的主键、外键、一些约束规则

2.提供完整性检查的方法

- 数据库管理系统中检查数据是否满足完整性规则的机制称为完整性检查
- 一般在执行INSERT、UPDATE、DELETE时检查

3.违约处理

数据库管理系统若发现用户的操作违背了完整性约束条件将采取一定的动作，如拒绝(NO ACTION)执行该操作或级联(CASCADE)执行其他操作，进行违约处理以保证数据的完整性。

此前写的一篇文章提到了关系完整性约束的基本概念**关系完整性的基本概念**，而本篇文章讲的是利用SQL如何去实现这些约束机制，如何实现完整性规则

### 2.实体完整性—PRIMARY KEY

#### （1）实体完整性的定义

##### 关系模型的实体完整性

CREATE TABLE中用PRIMARY KEY定义

##### 单属性构成的键有两种说明方法

1. 定义为列级约束条件
2. 定义为表级约束条件

##### 对多个属性构成的键只有一种说明方法

定义为表级约束条件

举几个例子：将Student表中的Sno属性定义为键

```sql
(1)在列级定义主键
CREATE TABLE Student
(Sno  CHAR(9) PRIMARY KEY，
Sname  CHAR(20) NOT NULL，
Ssex  CHAR(2)，
Sage  SMALLINT，
Sdept  CHAR(20));

(2)在表级定义主键
CREATE TABLE Student
(Sno  CHAR(9)，
Sname  CHAR(20) NOT NULL，
Ssex  CHAR(2)，
Sage  SMALLINT，
Sdept  CHAR(20)，
PRIMARY KEY (Sno)
); 

将SC表中的Sno，Cno属性组定义为键
CREATE TABLE SC
(Sno  CHAR(9) NOT NULL，
Cno  CHAR(4) NOT NULL，
Grade  SMALLINT，
PRIMARY KEY (Sno，Cno)/*只能在表级定义主键*/
); 
```

#### （2）实体完整性检查和违约处理

**插入或对主键列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：**

1. 检查主键值是否唯一，如果不唯一则拒绝插入或修改
2. 检查主键的各个属性是否为空，只要有一个为空就拒绝插入或修改

**检查记录中主键值是否唯一的一种方法是进行全表扫描**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625154455575.png" alt="image-20220625154455575" style="zoom:50%;"/>

- 全表扫描是十分耗时的。为了避免对基本表进行全表扫描，关系数据库管理系统一般都在主键上自动建立一个索引，如图5.2的B+树索引，通过索引查找基本表中是否已经存在新的主键值将大大提高效率。
- 例如，如果新插入记录的主键值是25，通过主键索引，从B+树的根结点开始查找，只要读取三个结点就可以知道该主键值已经存在，所以不能插入这条记录。这三个结点是根结点(51)、中间结点(1230)和叶结点(15 20 25)。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625154527476.png" alt="image-20220625154527476" style="zoom:50%;"/>

### 2.参照完整性—REFERENCES

#### （1）参照完整性定义

##### 关系模型的参照完整性定义

在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外键
用REFERENCES短语指明这些外键参照哪些表的主键

##### 举个例子

例如，关系SC中一个元组表示一个学生选修的某门课程的成绩，
（Sno，Cno）是主键。
Sno，Cno分别参照引用Student表的主键和Course表的主键

定义SC中的参照完整性

```sql
CREATE TABLE SC
(Sno  CHAR(9) NOT NULL，
Cno  CHAR(4) NOT NULL，
Grade  SMALLINT，
PRIMARY KEY (Sno， Cno)，/*在表级定义实体完整性*/
FOREIGN KEY (Sno) REFERENCES Student(Sno)，
/*在表级定义参照完整性*/
FOREIGN KEY (Cno) REFERENCES Course(Cno)
/*在表级定义参照完整性*/
);
```

#### （2）参照完整性检查和违约处理

可能破坏参照完整性的情况及违约处理

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625154720855.png" alt="image-20220625154720855" style="zoom:50%;"/>

##### 参照完整性违约处理

1. 拒绝(NO ACTION)执行：默认策略
2. 级联(CASCADE)操作
3. 设置为空值（SET-NULL）：对于参照完整性，除了应该定义外键，还应定义外键列是否允许空值

［例4］显式说明参照完整性的违约处理示例

```sql
CREATE TABLE SC
(Sno  CHAR(9) NOT NULL，
Cno  CHAR(4) NOT NULL，
Grade  SMALLINT，
PRIMARY KEY（Sno，Cno），				
FOREIGN KEY (Sno) REFERENCES Student(Sno)
ON DELETE CASCADE /*级联删除SC表中相应的元组*/
ON UPDATE CASCADE，/*级联更新SC表中相应的元组*/
FOREIGN KEY (Cno) REFERENCES Course(Cno)	
ON DELETE NO ACTION 	
/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/
ON UPDATE CASCADE 
/*当更新course表中的cno时，级联更新SC表中相应的元组*/
)；
```

- 经过测试，当UPDATE更新Student和Course表数据时，SC也自动更新

- 当删除Student的数据时，SC同步删除相应数据
- 当删除Course的数据时，拒绝删除，因为SC中有相应的外键数据，并设置了NO ACTION
- 当删除SC的数据时，对Student和Course无影响

### 3.用户定义的完整性—CHECK

用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求
RDBMS提供，而不必由应用程序承担

#### （1）属性上的约束条件定义

##### CREATE TABLE时定义

列值非空（NOT NULL）
列值唯一（UNIQUE）
检查列值是否满足一个布尔表达式（CHECK）

###### 1.不允许取空值

［例5］在定义SC表时，说明Sno、Cno、Grade属性不允许取空值。

```sql
CREATE TABLE SC
(Sno  CHAR(9) NOT NULL，	
Cno  CHAR(4) NOT NULL，	
Grade  SMALLINT NOT NULL，	
PRIMARY KEY (Sno， Cno)，
/*如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，
则在列级不允许取空值的定义就不必写了*/
）;
```

###### 2.列值唯一

［例6］建立部门表DEPT，要求部门名称Dname列取值唯一，
部门编号Deptno列为主键

```sql
CREATE TABLE DEPT
(Deptno  NUMERIC(2)，
Dname  CHAR(9) UNIQUE，/*要求Dname列值唯一*/
Location  CHAR(10)，
PRIMARY KEY (Deptno)
)；
```

###### 3.用CHECK短语指定列值应该满足的条件

［例7］Student表的Ssex只允许取“男”或“女”。

```sql
CREATE TABLE Student
(Sno  CHAR(9) PRIMARY KEY，
 Sname CHAR(8) NOT NULL，
 Ssex  CHAR(2) CHECK (Ssex IN (‘男’，‘女’))，
/*性别属性Ssex只允许取'男'或'女'*/
 Sage  SMALLINT，
 Sdept  CHAR(20)
);
```
#### （2）属性上的约束条件检查和处理

插入元组或修改属性的值时，RDBMS检查属性上的约束条件是否被满足
如果不满足则操作被拒绝执行

#### （3）元组上的约束条件的定义

在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制
同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件
［例9］当学生的性别是男时，其名字不能以Ms.打头。


```sql
CREATE TABLE Student
(Sno  CHAR(9)，
 Sname  CHAR(8) NOT NULL，
 Ssex  CHAR(2)，
 Sage  SMALLINT，
 Sdept  CHAR(20)，
 PRIMARY KEY (Sno)，
 CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%')
/*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/
)；
```

性别是女性的元组都能通过该项检查，因为Ssex=‘女’成立；
当性别是男性时，要通过检查则名字一定不能以Ms.打头

#### （4）元组上的约束条件检查和违约处理

插入元组或修改属性的值时，RDBMS检查元组上的约束条件是否被满足
如果不满足则操作被拒绝执行

### 4.完整性约束命名子句—CONSTRAINT

#### CONSTRAINT 约束语句格式：

```sql
CONSTRAINT <完整性约束条件名>
［PRIMARY KEY短语
|FOREIGN KEY短语
|CHECK短语］
```

#### 举个例子：

［例10］建立学生登记表Student，要求学号在90000~99999之间，
姓名不能取空值，年龄小于30，性别只能是“男”或“女”。

```sql
CREATE TABLE Student
(Sno  NUMERIC(6)
 CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999)，
 Sname  CHAR(20)
 CONSTRAINT C2 NOT NULL，
 Sage  NUMERIC(3)
 CONSTRAINT C3 CHECK (Sage < 30)，
 Ssex  CHAR(2)
 CONSTRAINT C4 CHECK (Ssex IN ('男'，'女'))，
 CONSTRAINT StudentKey PRIMARY KEY(Sno)
)；
```

在Student表上建立了5个约束条件，包括主键约束（命名为StudentKey）
以及C1、C2、C3、C4四个列级约束。

这个没有C2应该是为主键就忽略没显示叭

#### 修改表中的完整性限制

使用ALTER TABLE语句修改表中的完整性限制
［例13］修改表Student中的约束条件，要求学号改为在900000~999999之间，
年龄由小于30改为小于40
可以先删除原来的约束条件，再增加新的约束条件

```sql
ALTER TABLE Student
DROP CONSTRAINT C1;
ALTER TABLE Student
ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999);
ALTER TABLE Student
DROP CONSTRAINT C3;
ALTER TABLE Student
ADD CONSTRAINT C3 CHECK (Sage < 40);
```

### 5.域中的完整性限制—DOMAIN

关于域的定义有些数据库可能不同，或者定义失败，得观看相关的手册深入学习，但是SQL中是有定义DOMAIN，初学先了解一下叭。

SQL支持域的概念，并可以用CREATE DOMAIN语句建立一个域以及该域应该满足的完整性约束条件。

```sql
［例14］建立一个性别域，并声明性别域的取值范围
 CREATE DOMAIN GenderDomain CHAR(2)
 CHECK (VALUE IN ('男'，'女'));
这样［例10］中对Ssex的说明可以改写为Ssex GenderDomain

［例15］建立一个性别域GenderDomain，并对其中的限制命名
 CREATE DOMAIN GenderDomain CHAR(2)
 CONSTRAINT GD CHECK ( VALUE IN ('男'，'女'));

［例16］删除域GenderDomain的限制条件GD。
 ALTER  DOMAIN  GenderDomain 
 DROP CONSTRAINT GD;

［例17］在域GenderDomain上增加限制条件GDD。
 ALTER  DOMAIN  GenderDomain 
 ADD CONSTRAINT GDD CHECK (VALUE IN ('1'，'0')); 

通过［例16］和［例17］，就把性别的取值范围由('男'，'女')改为('1'，'0')
```

### 6.断言—ASSERTION

关于断言还是和域一样，不同的数据库可能实现方式不同，初学先了解，后期再深入

- 在SQL中可以使用数据定义语言中的CREATE ASSERTION语句，通过声明性断言(declarative assertions)来指定更具一般性的约束。
- 可以定义涉及多个表或聚集操作的比较复杂的完整性约束。
- 断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。

#### （1）定义断言

标准语句格式：**CREATE ASSERTION <断言名> <CHECK子句>**

每个断言都被赋予一个名字，<CHECK子句>中的约束条件与WHERE子句的条件表达式类似。

```sql
[例5.18]限制数据库课程最多60名学生选修。
CREATE ASSERTION ASSE_SC_DB_ NUM
CHECK(60>=(SELECT count(*)/*此断言的谓词涉及聚集操作count的SQL语句*/
FROM Course,SC
WHERE SC.Cno=Course.Cno AND Course.Cname=数据库)
);
每当学生选修课程时，将在SC表中插入一条元组(Sno, Cno, NULL),
ASSE_SC_DB_NUM断言被触发检查。如果选修数据库课程的人数已经超过60人，
CHECK子句返回值为“假”，对SC表的插入操作被拒绝。

[例5.19]限制每一门课程最多60名学生选修。
CREATE ASSERTION ASSE_SC_CNUMI
CHECK(60>=ALL( SELECT count (*)/*此断言的谓词，涉及聚集操作count */
FROM SC							/*和分组函数group by的SQL语句*/
GROUP by cno );

[例5.20 限制每个学期每一门课程最多60名学生选修]
首先修改SC表的模式，增加一个“学期(TERM)”的属性。
ALTER TABLE SC ADD TERM DATE;
/*先修改SC表，增加TERM属性，它的类型是DATE*/

然后定义断言:
CREATE ASSERTION ASSE_SC_CNUM2
CHECK (60>=ALL ( select count (*) from SC group by Cno,TERM )); 
```

#### （2）删除断言

DROP ASSERTION <断言名>;

如果断言很复杂，则系统在检测和维护断言上的开销较高，这是在使用断言时应该注意的。

### 7.触发器—TRIGGER

触发器（Trigger）是用户定义在关系表或视图上的一类由事件驱动的特殊过程，由服务器自动激活，将表的插入，删除或者更新操作发生前或者发生后定义为相应事件，为这些事件定义相应的动作，以保证数据完整性和实现其它功能。**创建触发器属于一种过程性约束**。

#### （1）定义触发器

##### CREATE TRIGGER语法格式:

```sql
 CREATE TRIGGER <触发器名> 
{BEFORE | AFTER} <触发事件> ON <表名>
 FOR EACH {ROW | STATEMENT}
 //ROW 是每一数据行都执行一次动作，STATEMENT 只在操作结束时执行一次动作
［WHEN <触发条件>］
<触发动作体>
```
##### 定义触发器的语法说明:

1.创建者：表的拥有者

2.触发器名

3.表名：触发器的目标表,不能建立在视图上

4.触发事件：INSERT、DELETE、UPDATE

5.触发器类型：

- 行级触发器（FOR EACH ROW）;

- 语句级触发器（FOR EACH STATEMENT）;

![image-20220625155801267](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625155801267.png)

例如,假设在［例11］的TEACHER表上创建了一个AFTER UPDATE触发器。如果表TEACHER有1000行，执行如下语句：UPDATE TEACHER SET Deptno=5;

如果该触发器为语句级触发器，那么执行完该语句后，触发动作只发生一次
如果是行级触发器，触发动作将执行1000次

6.触发条件
触发条件为真，则执行触发动作体，否则不执行;
省略WHEN触发条件时，只要触发器激活（触发器事件）则立刻执行触发动作体;

7.触发动作体
触发动作体可以是一个匿名PL/SQL过程块;
也可以是对已创建存储过程的调用;

```sql
[例18］定义一个BEFORE行级触发器，
为教师表Teacher定义完整性规则“教授的工资不得低于4000元，
如果低于4000元，自动改为4000元”。
 CREATE TRIGGER Insert_Or_Update_Sal 
 BEFORE INSERT OR UPDATE ON Teacher 
/*触发事件是插入或更新操作*/
 FOR EACH ROW /*行级触发器*/
 AS BEGIN /*定义触发动作体，是PL/SQL过程块*/
 IF (new.Job='教授') AND (new.Sal < 4000) THEN 
 new.Sal :=4000; 
 END IF;
 END; 


［例19］定义AFTER行级触发器，当教师表Teacher的工资发生变化后
就自动在工资变化表Sal_log中增加一条相应记录

首先建立工资变化表Sal_log
 CREATE TABLE Sal_log
(Eno  NUMERIC(4) references teacher(eno)，
 Sal  NUMERIC(7，2)，
 Username  char(10)，
 Date  TIMESTAMP
)；

[例19]（续）
CREATE TRIGGER Insert_Sal 	
 AFTER INSERT ON Teacher 	/*触发事件是INSERT*/
 FOR EACH ROW
 AS BEGIN
 INSERT INTO Sal_log VALUES(
 new.Eno，new.Sal，CURRENT_USER，CURRENT_TIMESTAMP);
 END;

[例19]（续）
CREATE TRIGGER Update_Sal 	
 AFTER UPDATE ON Teacher 	/*触发事件是UPDATE */
 FOR EACH ROW
 AS BEGIN 
 IF (new.Sal <> old.Sal) THEN INSERT INTO Sal_log VALUES(
 new.Eno，new.Sal，CURRENT_USER，CURRENT_TIMESTAMP);
 END IF;
 END;
```

> 这个可以在Oracle数据库里运行，但是因为我用的是SQL Sever数据库，所以运行不了，不同的数据库，触发器的实现略有不同，详情请查看相关数据库手册。

#### （2）激活触发器

触发器的执行，是由触发事件激活的，并由数据库服务器自动执行，一个数据表上可能定义了多个触发器

同一个表上的多个触发器激活时遵循如下的执行顺序：
（1）执行该表上的BEFORE触发器；
（2）激活触发器的SQL语句；
（3）执行该表上的AFTER触发器。

```sql
［例20］执行修改某个教师工资的SQL语句，激活上述定义的触发器。
 UPDATE Teacher SET Sal=800 WHERE Ename='王五';
执行顺序是：
执行触发器Insert_Or_Update_Sal
执行SQL语句“UPDATE Teacher SET Sal=800 WHERE Ename='王五';”
执行触发器Insert_Sal；
执行触发器Update_Sal
```

#### （3）删除触发器

删除触发器的SQL语法：**DROP TRIGGER <触发器名> ON <表名>;**

触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。

［例21］删除教师表Teacher上的触发器Insert_Sal

DROP TRIGGER Insert_Sal ON Teacher;



# 第6 章关系数据理论

## 6.1 关系数据库的规范化理论

（数据依赖对表的影响[插入-删除-修改-冗余]、1NF-2NF-3NF-BCNF-4NF、函数依赖与多值依赖）

思维导图

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.1%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.jpg)

### 1.为什么要学习关系数据库规范化理论？

**感性认识：**

- 当我们面对一个实际问题时，我们应该如何去建数据库，建表，库的结构，表的结构我们该如何组织，才能更好的解决问题。

- 如何省内存，提高查询修改删除更新的效率？
- 如何避免可能出现的隐患，如修改删除更新插入等异常？
- 以上就是关系数据库规范化理论研究解决的问题,说白了就是告诉你如何才能设计出合适的库和表

**下面我们回顾几个概念和问题，以便更好地学习后面的关系数据库规范化理论**

#### （1）基本概念回顾

关系：可简单的理解为二维表

关系模式：即二维表的逻辑结构

关系数据库：指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。

关系数据库的模式：即关系数据库的逻辑结构

#### （2）关系模式的形式化定义

这里我们回顾一下《数据库系统概论》中对二维表结构的定义

> 关系模式由五部分组成，即它是一个五元组：
> R(U, D, DOM, F)
> R：关系名,即表名
> U：组成该关系的属性名集合
> D：属性组U中属性所来自的域。数据的取值范围和类型
> DOM：属性向域的映象集合
> F：属性组U上的一组数据依赖。

**关系数据库规范化理论研究的就是R、F、U，之间的关系。**
**因为D和DOM对研究表的设计关系不大，所以在学习关系数据库规范化理论时可以将五元组简化成三元组**

> 三元组：R（U, F）
> 当且仅当U上的一个关系r满足F时，r称为关系模式 R（U, F）的一个关系

#### （3）什么是数据依赖F？

这里我们对F中的数据依赖进行简单解释，后面会详细叙述**函数依赖**和**多值依赖**。

> 数据依赖是一个关系内部属性与属性之间的一种约束关系。
> 这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系。
> 它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。

**数据依赖分类：**

1. 函数依赖（Functional Dependency，简记为FD）

> 函数依赖极为普遍地存在于现实生活中。比如描述一个学生的关系，可以有学号(Sno)、姓名(Sname)、系名(Sdept)等几个属性。由于一个学号只对应一个学生，一个学生只在一一个系学习。因而当“学号”值确定之后，学生的姓名及所在系的值也就被唯一地确定了。属性间的这种依赖关系类似于数学中的函数y=f(x)，自变量x确定之后，相应的函数值y也就唯一地确定了。

2. 多值依赖（Multivalued Dependency，简记为MVD）
3. 其他

#### （4）数据依赖F对关系模式的影响

因为关系数据库规范化理论主要研究的是三元组R(U,F)，U我们都好理解，最重要的是F，这里我们简单的了解一下F对关系模式，即表的逻辑结构的影响，让我们理性的认识为什么学习关系数据库规范化理论

**举个例子：**

> [例1]建立一个描述学校教务的数据库,数据库涉及的对象有：
> 学生的学号（Sno）、所在系（Sdept）、系主任姓名（Mname）、课程名（Cname）、成绩（Grade）

这里我们用单一的关系模式Student来表示这些对象：
Student <U、F>
该关系的属性集合：
U ＝｛ Sno, Sdept, Mname, Cname, Grade ｝

**这里说明一下现实世界的事实语义，关于这些对象之间的联系：**
①一个系有若干学生，但一个学生只属于一个系。
②一个系只有一名(正职)负责人。
③一个学生可以选修多门课程，每门课程有若干学生选修。
④每个学生学习每一一门课程有一个成绩。

**于是得到属性组U上的一组函数依赖F：**
F={Sno-> Sdept, Sdept->Mname,(Sno, Cno)->Grade}
(如图所示)

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625160652316.png" alt="image-20220625160652316" style="zoom: 33%;"/>

如果只考虑函数依赖这一种数据依赖，可以得到一个描述学生的关系模式Student <U,F>。表6.1是某一时刻关系模式Student的一个实例，即数据表。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625160723330.png" alt="image-20220625160723330" style="zoom:50%;"/>

**这个关系模式设计的并不好,存在以下问题:**

1️⃣数据冗余(Data redundancy)
比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，如表6.1所示。这将浪费大量的存储空间。

2️⃣更新异常(update anomalies )
由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。比如，某系更换系主任后，必须修改与该系学生有关的每一个元组。

3️⃣插入异常(insertion anomalies )
如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。

4️⃣删除异常( deletion anomalies)
如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢掉了。

**鉴于存在以上种种问题，可以得出这样的结论:**

1. Student关系模式不是一个好的模式。
2. “好”的模式：不会发生插入异常、删除异常、更新异常，数据冗余应尽可能少
3. 原因：由存在于模式中的某些数据依赖引起的
4. 解决方法：通过分解关系模式来消除其中不合适的数据依赖

**可以把这个单一模式分成3个关系模式：**

1. S（Sno，Sdept，Sno → Sdept）;
2. SC（Sno，Cno，Grade，（Sno，Cno）→ Grade）;
3. DEPT（Sdept，Mname，Sdept→ Mname）

这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。一个模式的数据依赖会有哪些不好的性质，如何改造一个不好的模式，这就是接下来2.规范化要讨论的内容

### 2.规范化—改造关系模式

**解决插入异常、删除异常、更新异常和数据冗余问题。**

#### （1）规范化研究什么？

- 规范化讨论如何根据属性间依赖情况来判定关系是否具有某些不合适的性质
- 通常按属性间依赖情况来区分**关系规范化程度**为第一范式、第二范式、第三范式和第四范式等
- 用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。

**其中函数依赖、码是为学习范式1NF,2NF,3NF……打基础**

#### （2）函数依赖

这里我们讨论数据依赖F中的函数依赖，分为以下几种类型：

- 函数依赖
- 平凡函数依赖与非平凡函数依赖
- 完全函数依赖与部分函数依赖
- 传递函数依赖

##### ①函数依赖

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161251472.png" alt="image-20220625161251472" style="zoom:50%;"/>

**注意：**函数依赖不是指关系模式R的某个或某些关系满足的约束条件，而是指R的一切关系均要满足的约束条件。

A->B：读作“A函数决定B”或者“B函数依赖A”，表示的意思是：A列中一个值只对应于B中的一个值（一个A对应一个B）

**以下是一个错误的例子：**
sno->sdept，sno应该唯一决定sdept

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161338950.png" alt="image-20220625161338950" style="zoom:50%;"/>

> 函数依赖和别的数据依赖样是语义范畴的概念，只能根据语义来确定一个函数依赖。
> 例如，姓名→年龄这个函数依赖只有在该部门没有同名人的条件下成立。如果允许有同名人，则年龄就不再函数依赖于姓名了。

##### ②平凡函数依赖与非平凡函数依赖

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161407937.png" alt="image-20220625161407937" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161423672.png" alt="image-20220625161423672" style="zoom:50%;"/>

##### ③完全函数依赖与部分函数依赖

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161439568.png" alt="image-20220625161439568" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161454685.png" alt="image-20220625161454685" style="zoom:50%;"/>

##### ④传递函数依赖

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161527393.png" alt="image-20220625161527393" style="zoom:50%;"/>

**直接依赖这里我们举个例子：**
BH(sno,idCard,address)

> X：sno 学号
> Y：idCard 身份证号
> Z：address 住址
> X->Y，Y->X，X<->Y，Y->Z
> 所以我们说Z直接依赖于X

#### （3）Armstrong公理

无损分解

#### （4）码

码是关系模式中的一个重要概念。在码的定义中有关码的若干定义，这里用函数依赖的概念来定义码。码唯一决定一个实体集

##### ①候选码、超码、主键

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161625199.png" alt="image-20220625161625199" style="zoom:50%;"/>

##### ②主属性和非主属性

###### 主属性与非主属性

- 包含在任何一个候选码中的属性，称为主属性（Prime attribute）
- 不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）

**举几个例子：**

[例2]
关系模式S(Sno,Sdept,Sage)，单个属性Sno是码，
SC（Sno，Cno，Grade）中，（Sno，Cno）是码

[例3]
关系模式R（P，W，A）
P：演奏者 W：作品 A：听众
一个演奏者可以演奏多个作品
某一作品可被多个演奏者演奏
听众可以欣赏不同演奏者的不同作品
码为(P，W，A)，即All-Key

##### ③外部码

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625161739138.png" alt="image-20220625161739138" style="zoom:50%;"/>

#### （4）范式

- 范式是符合某一种级别的关系模式的集合
- 关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同的范式。
- 级别越高，表设计的越合理

**范式的种类**：

- 第一范式（1NF）
- 第二范式(2NF)
- 第三范式(3NF)
- BC范式(BCNF)
- 第四范式(4NF)
- 第五范式(5NF)

**各种范式之间存在联系：**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162204019.png" alt="image-20220625162204019" style="zoom:50%;"/>

某一关系模式R为第n范式，可简记为R∈nNF。一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫**规范化**

##### ①1NF

###### 1NF的定义:

- 如果一个关系模式R的所有属性都是不可分的基本数据项，即每一个列必须包含一个单一的，非结构化的值，则R∈1NF
- 关系模型中不含有多值属性的列或者含有内部结构的列存在。即关系模型中的属性具有原子性。
- **第一范式是对关系模式的最起码的要求**。**不满足第一范式的数据库模式不能称为关系数据库**
- 但是满足第一范式的关系模式并不一定是一个好的关系模式

**以下是一个满足1NF，但不是好的关系模式的例子：**

> 关系模式 S-L-C(Sno, Sdept, Sloc, Cno, Grade)
> Sloc为学生住处，假设每个系的学生住在同一个地方

这个例子中存在函数依赖，不是一个好的关系模式

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162327825.png" alt="image-20220625162327825" style="zoom:50%;"/>

**图形化表示：**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162404273.png" alt="image-20220625162404273" style="zoom:50%;"/>

**S-L-C不是一个好的关系模式，一个关系模式 R不属于2NF,就会产生以下几个问题:**

(1)插入异常。假若要插入一个学生Sno=S7， Sdept =PHY， Sloc =BLD2，但该生还未选课，即这个学生无Cno,这样的元组就插不进S-L-C中。因为插入元组时必须给定码值，而这时码值的一部分为空，因而学生的固有信息无法插入。

(2)删除异常。假定某个学生只选一门课，如S4就选了一门课C3，现在C3这门课他也不选了，那么C3这个数据项就要删除。而C3是主属性，删除了C3，整个元组就必须一起删除，使得S4的其他信息也被删除了，从而造成删除异常，即不应删除的信息也删除了。

(3)修改复杂。某个学生从数学系(MA)转到计算机科学系(CS)，这本来只需修改此学生元组中的Sdept分量即可，但因为关系模式S-L-C中还含有系的住处Sloc属性，学生转系将同时改变住处，因而还必须修改元组中的Sloc分量。另外，如果这个学生选修了k门课，Sdept、 Sloc重复存储了k次，不仅存储冗余度大，而且必须无遗漏地修改k个元组中全部Sdept、Sloc 信息，造成修改的复杂化。

**为什么会有这些问题呢？**

**原因**：Sdept、 Sloc部分函数依赖于码。
**解决方法**(也就是2NF的处理方法):

- S-L-C分解为两个关系模式，以消除这些部分函数依赖
- SC（Sno， Cno， Grade）
- S-L（Sno， Sdept， Sloc）

**函数依赖图：**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162543696.png" alt="image-20220625162543696" style="zoom:50%;"/>

##### ②2NF

###### 2NF的定义

![image-20220625162842925](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162842925.png)

- 
  采用投影分解法将一个1NF的关系分解为多个2NF的关系，可以在一定程度上减轻原1NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。


- 将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余。所以又引入了3NF。


##### ③3NF

###### 3NF 的定义

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162937060.png" alt="image-20220625162937060" style="zoom:50%;"/>

**这里我们对上面的2NF例子再次进行剖析：**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625162958859.png" alt="image-20220625162958859" style="zoom:50%;"/>

**函数依赖图：**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163039408.png" alt="image-20220625163039408" style="zoom:33%;"/>

###### 解决方法：

1.采用**投影分解法**，把S-L分解为两个关系模式，以消除传递函数依赖：

- S-D（Sno， Sdept）
- D-L（Sdept，Sloc）

2.S-D的码为Sno， D-L的码为Sdept。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163155503.png" alt="image-20220625163155503" style="zoom:50%;"/>

3.分解后的关系模式S-D与D-L中不再存在传递依赖

4.采用投影分解法将一个2NF的关系分解为多个3NF的关系，可以在一定程度上解决原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。

5.将一个2NF关系分解为多个3NF的关系后，仍然不能完全消除关系模式中的各种异常情况和数据冗余。

##### ④ BCNF

> BCNF ( Boyce Codd Normal Form)是由Boyce与Codd提出的，比上述的3NF又进了一步，通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163340274.png" alt="image-20220625163340274" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163406427.png" alt="image-20220625163406427" style="zoom: 50%;"/>

**下面用几个例子说明属于3NF的关系模式有的属于BCNF，但有的不属于BCNF。**

[例5]关系模式C（Cno，Cname，Pcno）
C∈3NF
C∈BCNF

> 关系模式C(Cno, Cname, Peno)，它只有一个码Cno,这里没有任何属性对Cno部分依赖或传递依赖，所以C∈3NF。同时C中Cno是唯一的决定因素，所以C ∈BCNF。

[例6]关系模式S(Sno, Sname, Sdept, Sage)
假定S有两个码Sno，Sname
S∈3NF。
S ∈ BCNF

> 假定Sname也具有唯一性，那么S就有两个码，这两个码都由单个属性组成，彼此不相交。其他属性不存在对码的传递依赖与部分依赖，所以S∈3NF。
> 同时S中除Sno、Sname外没有其他决定因素，所以S也属于BCNF。

［例7］关系模式SJP（S，J，P）
SJP∈3NF，
SJP∈BCNF

[例6.7]关系模式SJP(S, J, P)中，S是学生，J表示课程，P表示名次。
每一个学生选修每门课程的成绩有一定的名次，
每门课程中每一名次只有一个学生(即没有并列名次)。
由语义可得到下面的函数依赖:
(S,J)→P; (J,P)→S
所以(S,J)与(J,P)都可以作为候选码。
这两个码各由两个属性组成，而且它们是相交的。
这个关系模式中显然没有属性对码传递依赖或部分依赖。
所以SJP∈3NF，而且除(S,J)与(J,P)以外没有其他决定因素，所以SJP∈BCNF。

[例8]关系模式STJ(S, T, J)中，S表示学生，T表示教师，J表示课程。

> 每一教师只教一门课，
> 每门课有若干教师，
> 某一学生选定某门课，就对应一个固定的教师。
> 由语义可得到如下的函数依赖。
> (S,J)→T，(S,T)-J, T→J
> 函数依赖关系可以用如图表示
>
> <img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163534033.png" alt="image-20220625163534033" style="zoom:50%;"/>
>
> 这里(S,J)、(S,T)都是候选码。
> STJ是3NF,因为没有任何非主属性对码传递依赖或部分依赖，
> 但STJ不是BCNF关系，因为T是决定因素，而T不包含码。

**如何解决才能让STJ是BCNF关系呢？**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163642005.png" alt="image-20220625163642005" style="zoom:50%;"/>

##### ⑤3NF与BCNF的关系

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163704508.png" alt="image-20220625163704508" style="zoom:50%;"/>

- 3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。
- 一个模式中的关系模式如果都属于BCNF,那么在函数依赖范畴内它已实现了彻底的分离，已消除了插入和删除的异常。
- 3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。

#### （5）多值依赖

前面我们讲了数据依赖分为函数依赖和多值依赖，函数依赖在上面已经叙述了，这里我们再讨论多值依赖。

**用一个例子引入多值依赖：**

[例9]学校中某一门课程由多个教师讲授，他们使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用。

可以用一个非规范化的关系来表示教师T、课程C和参考书B之间的关系

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163755886.png" alt="image-20220625163755886" style="zoom:50%;"/>

把这张表变成一张规范化的二维表：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163817738.png" alt="image-20220625163817738" style="zoom:50%;"/>


关系模型Teaching (C, T,B)的码是(C, T, B)，即all-key,因而Teaching∈BCNF。

但是当某一课程(如物理)增加一名讲课教师(如周英)时，必须插入多个(这里是三个)元组:
(物理，周英，普通物理学)，(物理，周英，光学原理)，(物理，周英，物理习题集)。

同样，某一门课(如数学)要去掉一本参考书(如微分方程)，则必须删除多个(这里是两个)元组:
(数学，李勇，微分方程)，(数学，张平，微分方程)。

可以看出对数据的增删改很不方便，数据的冗余也十分明显。

仔细考察这类关系模式，发现它具有一种称之为多值依赖(Multi-Valued Dependency, MVD)的数据依赖。

##### ①多值依赖的定义

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163906685.png" alt="image-20220625163906685" style="zoom:50%;"/>

> 例如，在关系模式Teaching中，对于一个(物理，光学原理)有一组T值{李勇，王军}，这组值仅仅决定于课程C上的值(物理)。
> 也就是说对于另一个(物理，普通物理学)，它对应的一组T值仍是{李勇，王军}，尽管这时参考书B的值已经改变了。
> 因此T多值依赖于C，即C→→T。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163933481.png" alt="image-20220625163933481" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625163955725.png" alt="image-20220625163955725" style="zoom:50%;"/>

##### ②平凡多值依赖和非平凡多值依赖

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164011549.png" alt="image-20220625164011549" style="zoom:50%;"/>

**下面再举一个具有多值依赖的关系模式的例子。**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164029569.png" alt="image-20220625164029569" style="zoom:50%;"/>

对于W的每一个值Wi, S有一个完整的集合与之对应而不问C取何值。所以W→→S(多值依赖)。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164054168.png" alt="image-20220625164054168" style="zoom:50%;"/>

**如果用图下图来表示这种对应**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164119326.png" alt="image-20220625164119326" style="zoom:50%;"/>

- 则对应W的某一个值Wi的全部S值记作{S}wi (表示此仓库工作的全部保管员)
- 全部C值记作{C}wi (表示在此仓库中存放的所有商品)。
- 应当有{S}wi中的每一个值和{C}wi中的每一个C值对应。
- 于是{S}wi与{C}wi之间正好形成一个完全二分图，因而W→→S。
- 由于C与S的完全对称性，必然有W→→C成立。

**多值依赖具有以下性质:**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164149481.png" alt="image-20220625164149481" style="zoom:50%;"/>

##### ③多值依赖与函数依赖的区别

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164209341.png" alt="image-20220625164209341" style="zoom:50%;"/>

#### （6）4NF

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164231165.png" alt="image-20220625164231165" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164259828.png" alt="image-20220625164259828" style="zoom:50%;"/>

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164314727.png" alt="image-20220625164314727" style="zoom:50%;"/>

#### （7）规范化小结—重点归纳步骤

关系数据库的规范化理论是数据库逻辑设计的工具

目的：尽量消除插入、删除异常，修改复杂，数据冗余

基本思想：逐步消除数据依赖中不合适的部分
实质：概念的单一化

**关系模式规范化的基本步骤**

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164347619.png" alt="image-20220625164347619" style="zoom:50%;"/>

# 第7 章数据库设计

## 7.1 数据库设计六步骤

（需求、概念、逻辑、物理、实施、运行维护）

一图总览

![](C:/Users/86184/%E6%A1%8C%E9%9D%A2/%E7%BD%91%E5%AE%89%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/7.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%85%AD%E6%AD%A5%E9%AA%A4.jpg)

### 1.数据库设计概述及六步骤简介

数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求。

#### 1.数据库设计的特点

数据库设计是一项涉及多学科的综合性技术，又是一项庞大的工程项目，具有如下特点：
(1)数据库建设是硬件、软件和干件（技术和管理的界面）的结合。
(2)数据库设计应该和应用系统设计相结合。

#### 2.数据库设计方法

常用的数据库设计方法如下：
（1）新奥尔良方法：将数据库设计分为若干阶段和步骤
（2）基于 E-R 模型的设计方法：概念设计阶段广泛采用
（3）基于3NF 的设计方法：逻辑阶段可采用的有效方法
（4）ODL（Object Definition Language）方法：面向对象的数据库设计方法
（5）计算机辅助设计：ORACLE Designer 2000、SYBASE PowerDesigner

#### 3.数据库设计的基本步骤

数据库设计分为6 个阶段：
（1）需求分析：准确了解与分析用户需求（包括数据与处理）。
（2）概念结构设计：对用户需求进行综合、归纳与抽象，形成一个独立于具体 DBMS的概念模型。
（3）逻辑结构设计：将概念结构转换为某个 DBMS 所支持的数据模型，并对其进行优化。
（4）物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。
（5）数据库实施：建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。
（6）数据库运行和维护：对数据库系统进行评价、调整与修改。

> 需求分析和概念设计独立于任何数据库管理系统
> 逻辑设计和物理设计与选用的DBMS密切相关

### 2.需求分析—步骤一

需求分析是整个数据库设计过程中最重要的步骤之一，是后继各阶段的基础。在需求分析阶段，从多方面对整个组织进行调查，收集和分析各项应用对信息和处理两方面的需求。

![image-20220625164634867](C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164634867.png)

#### 2.1 收集资料

收集资料是数据库设计人员和用户共同完成的任务。确定企业组织的目标，从这些目标导出对数据库的总体要求。通过调研，确定由计算机完成的功能。

#### 2.2 分析整理

分析的过程是对所收集到的数据进行抽象的过程，产生求解的模型。

#### 2.3 数据流图

采用数据流图来描述系统的功能。数据流图可以形象地描述事务处理与所需数据的关联，便于用结构化系统方法，自顶向下，逐层分解，步步细化。

#### 2.4 数据字典

对数据流图中的数据流和加工等进一步定义，从而完整地反映系统需求。
**数据字典的用途：**进行详细的数据收集和数据分析所获得的主要结果
**数据字典的内容：**数据项，数据结构，数据流，数据存储，处理过程

#### 2.5 用户确认

需求分析得到的数据流图和数据字典要返回给用户，通过反复完善，最终取得用户的认可。

### 3.概念结构设计—步骤二

概念设计阶段的目标是产生整体数据库概念结构，即概念模式。概念模式是整个组织各个用户关心的信息结构。描述概念结构的有力工具是 E-R 模型。

#### 3.1 E-R 模型（实体关系模型）

##### （1）基本 E-R 模型（ER图）

E-R 模型通过 E-R 图表示出来。
将所有实体属性和实体之间的联系均描述出来就构成了一个 E-R 图

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164848311.png" alt="image-20220625164848311" style="zoom:50%;"/>

##### （2）基本 E-R 模型的扩展

###### 数据抽象

一般有3 种抽象：
**(1)分类:**它抽象了对象值和型之间“is member of”的语义。例如：“张英”是“学生”实体中的一员。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625164936708.png" alt="image-20220625164936708" style="zoom: 33%;"/>

**(2)聚集**:它抽象了对象内部类型和成分之间“is part of”的语义。例如：若干属性的聚集组成了实体型。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165005174.png" alt="image-20220625165005174" style="zoom:50%;"/>

**(3)概括**:它抽象了类型之间“is subset of”的语义。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165024551.png" alt="image-20220625165024551" style="zoom:50%;"/>

**依赖联系**

在现实世界中，常常有某些实体对于另一些实体具有很强的依赖关系，即一个实体的存在必须以另一实体的存在为前提。通常把前者称为弱实体。
在E-R图中，用双线框表示弱实体，用指向弱实体的箭头表明依赖联系。

**超类和子类**

概括定义了类型之间的一种子集联系。
例如：学生是一个实体型，本科生、研究生也是实体型。本科生、研究生均是学生的子集。把学生称为超类，本科生、研究生称为学生的子类。
在E-R图中，用双竖边的矩形框表示子类，用直线加小圆圈表示超类-子类联系。
子类继承超类上定义的全部属性，其本身还可包含其他属性。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165111250.png" alt="image-20220625165111250" style="zoom:50%;"/>

#### 3.2 建立 E-R 模型

##### （1）设计局部 E-R 模型

确定局部结构范围
定义实体
联系定义
属性分配

##### （2）设计全局 E-R 模型

确定公共实体类型
局部E-R模型的合并
消除冲突

##### （3）全局 E-R 模型的优化

实体类型的合并
冗余属性的消除
冗余联系的消除

### 4.逻辑结构设计—步骤三

逻辑结构设计就是把上述概念模型转换成为某个具体的数据库管理系统所支持的数据模型。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165231478.png" alt="image-20220625165231478" style="zoom:50%;"/>

#### 4.1 E-R 模型向关系模式的转换

##### 转换原则

（1）每一个实体类型转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的码。
（2）联系的转换：
①一般1:1，1:m联系不产生新的关系模式，而是将一方实体的码加入到多方实体对应的关系模式中，联系的属性也一并加入。
②m:n联系要产生一个新的关系模式，该关系模式由联系涉及实体的码加上联系的属性（若有）组成。

##### 具体做法

###### （1）两实体间的1:1 联系

> 一个1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。可将任一方实体的主键纳入另一方实体对应的关系中，若有，联系的属性也一并纳入。

例如，如图6.1 所示的 E-R 图可转换为如下关系模式：
工厂（厂号，厂名，地点，姓名，任期）
厂长（姓名，性别，年龄）
或者：
工厂（厂号，厂名，地点）
厂长（姓名，性别，年龄，厂号，任期）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165409456.png" alt="image-20220625165409456" style="zoom: 33%;"/>

###### （2）两实体间的1:m 联系

> 可将“1”方实体的主键纳入“m”方实体对应的关系中作为外键，同时把联系的属性也一并纳入“m”方对应的关系中。

例如，如图6.2 所示的 E-R 图转换为如下关系模式：
仓库（仓库号，地点，面积）
商品（货号，品名，价格，仓库号，数量）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165440822.png" alt="image-20220625165440822" style="zoom:33%;"/>

###### （3）同一实体间的1:m 联系

> 可在这个实体所对应的关系中多设一个属性，作为与该实体相联系的另一个实体的主键。

例如，如图6.3 所示的 E-R 图可转换为如下关系模式：
职工（工号，姓名，年龄，性别，职称，工资，领导者工号，民意测验）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165510751.png" alt="image-20220625165510751" style="zoom: 50%;"/>

###### （4）两实体间的弱实体联系

> 可将被依赖实体的主键纳入弱实体中，作为弱实体的主键或主键中的一部分。

例如，如图6.4 所示的 E-R 图可转换为如下关系模式：
职工（工号，姓名，年龄，性别，职称）
亲属（工号，亲属姓名，亲属关系）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165538893.png" alt="image-20220625165538893" style="zoom:50%;"/>

###### （5）超类和子类的转换

> 超类、子类实体都可转换为一个关系，并将超类实体的主键加到子类实体中。

例如，如图6.5 所示的 E-R 图中各个实体的属性为：
职员：职工号，姓名，性别，年龄，参加工作时间
飞行员：飞行小时，健康检查，飞机型号
机械师：学历，级别，专业职称
管理员：职务，职称

该 E-R 图转换为如下关系模式：

职员（职工号，姓名，性别，年龄，参加工作时间）
飞行员（职工号，飞行小时，健康检查，飞机型号）
机械师（职工号，学历，级别，专业职称）
管理员（职工号，职务，职称）

为了查询方便，可在超类实体中增加一个指示器属性，根据指示器的值直接查询子类实体表。所以，职员关系又可以为：
职员（职工号，姓名，性别，年龄，参加工作时间，职员类型）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165610952.png" alt="image-20220625165610952" style="zoom:50%;"/>

###### （6）两实体间的 m:n 联系

> 必须对“联系”单独建立一个关系，该关系中至少包含被它所联系的双方实体的“主键”，如果联系有属性，也要纳入这个关系中。

例如，如图6.6 所示的 E-R 图转换为如下关系模式：
学生（学号，姓名，性别，年龄）
课程（课程号，课程名，学时）
选修（学号，课程号，成绩）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165650327.png" alt="image-20220625165650327" style="zoom: 33%;"/>

###### （7）同一实体间的 m:n 联系

> 必须为这个“联系”单独建立一个关系，该关系中至少应包含被它所联系的双方实体的“主键”，如果联系有属性，也要纳入这个关系中。由于这个“联系”只涉及一个实体，所以加入的实体的主键不能同名。

例如，如图6.7 所示的 E-R 图转换为如下关系模式：
零部件（代号，名称，价格）
组装（代号，组装件代号，数量）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165723439.png" alt="image-20220625165723439" style="zoom:50%;"/>

###### （8）两个以上实体间的 m:n 联系

> 必须为这个“联系”单独建立一个关系，该关系中至少应包含被它所联系的各个实体的“主键”，若是联系有属性，也要纳入这个关系中。

例如，如图6.8 所示的 E-R 图可转换为如下关系模式：
供应商（供应商号，供应商名，地址）
零件（零件号，零件名，重量）
项目（项目编号，项目名称，开工日期）
供应（供应商号，项目编号，零件号，零件数）

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165743793.png" alt="image-20220625165743793" style="zoom:50%;"/>

#### 4.2 关系模式的优化

**最核心的就是要遵循数据库设计的NF范式**

应用关系规范化理论对上述产生的关系模式进行优化，具体步骤如下：
（1）确定每个关系模式内部各个属性之间的数据依赖以及不同关系模式属性之间的数据依赖。
（2）对各个关系模式之间的数据依赖进行最小化处理，消除冗余的联系。
（3）确定各关系模式的范式等级。
（4）按照需求分析阶段得到的处理要求，确定要对哪些模式进行合并或分解。
（5）为了提高数据操作的效率和存储空间的利用率，对上述产生的关系模式进行适当的修改、调整和重构。

#### 4.3 设计用户子模式

**全局关系模型设计完成后，还应根据局部应用的需求，结合具体 DBMS 的特点，设计用户的子模式。**

设计子模式时应注意考虑用户的习惯和方便性，主要包括：
（1）使用更符合用户习惯的别名。
（2）可以为不同级别的用户定义不同的视图，以保证系统的安全性。
（3）可将经常使用的复杂的查询定义为视图，简化用户对系统的使用。

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165856031.png" alt="image-20220625165856031" style="zoom:50%;"/>

### 5.物理结构设计—步骤四

数据库的物理设计是指对一个给定的逻辑数据库模型选取一个最适合应用环境的物理结构的过程。物理设计通常分为两步：

<img src="C:/Users/86184/AppData/Roaming/Typora/typora-user-images/image-20220625165916883.png" alt="image-20220625165916883" style="zoom:50%;"/>

#### 5.1 确定数据库的物理结构

##### （1）确定数据的存取方法

索引方法的选择
聚簇方法的选择

##### （2）确定数据的存储结构

1.确定数据的存放位置
基本原则:根据应用情况将易变部分与稳定部分分开存放、存取频率较高部分与存取频率较低部分分开存放

2.确定系统配置
DBMS产品一般都提供了一些存储分配参数
同时使用数据库的用户数
同时打开的数据库对象数
内存分配参数
使用的缓冲区长度、个数
存储分配参数
…….

#### 5.2 物理结构进行评价

> 对时间效率、空间效率、维护开销和各种用户要求进行权衡，从多种设计方案中选择一个较优的方案。

**评价方法（完全依赖于所选用的DBMS ）：**

- 定量估算各种方案：存储空间，存取时间，维护代价
- 对估算结果进行权衡、比较，选择出一个较优的合理的物理结构
- 如果该结构不符合用户需求，则需要修改设计

### 6.数据库实施—步骤五

**实施阶段的工作主要有：**

- 建立数据库结构

- 数据载入：数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。

- 应用程序的编码和调试

- 数据库试运行

  **功能测试**：
  实际运行数据库应用程序，执行对数据库的各种操作，测试应用程序的功能是否满足设计要求
  如果不满足，对应用程序部分则要修改、调整，直到达到设计要求
  **性能测试**：
  测量系统的性能指标，分析是否达到设计目标
  如果测试的结果与设计目标不符，则要返回物理设计阶段，重新调整物理结构，修改系统参数，某些情况下甚至要返回逻辑设计阶段，修改逻辑结构

### 7.数据库运行维护—步骤六

**数据库系统投入正式运行后，对数据库经常性的维护工作主要由 DBA 完成，包括：**

1.数据库的转储和恢复

- 在数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生
- 系统的操作人员对新系统还不熟悉，误操作也不可避免
- 因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏

2.数据库的安全性、完整性控制

3.数据库性能的监督、分析和改造

4.数据库的重组与重构

- 重组织的目标
- 提高系统性能
- 重组织的工作
- 按原设计要求
- 重新安排存储位置
- 回收垃圾
- 减少指针链
- 数据库的重组织不会改变原设计的数据逻辑结构和物理结构
- 数据库重构造
- 根据新环境调整数据库的模式和内模式
- 增加新的数据项
- 改变数据项的类型
- 改变数据库的容量
- 增加或删除索引
- 修改完整性约束条件

